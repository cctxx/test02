C++RAW

#include "UnityPrefix.h"
#include "Runtime/Camera/RenderSettings.h"
#include "Editor/Src/AssetPipeline/ImageOperations.h"
#include "Runtime/Camera/UnityScene.h"
#include "Editor/Src/AsyncProgressBar.h"
#include "Runtime/Filters/Deformation/SkinnedMeshFilter.h"
#include "Runtime/Animation/AnimationManager.h"
#include "Runtime/Misc/PreloadManager.h"
#include "Runtime/Terrain/TerrainData.h"
#include "Runtime/BaseClasses/GameObject.h"
#include "Editor/Src/Prefabs/Prefab.h"
#include "Editor/Src/AssetPipeline/AssetInterface.h"
#include "Editor/Src/AssetPipeline/AssetPathUtilities.h"
#include "Editor/Src/Gizmos/GizmoUtil.h"
#include "Runtime/IMGUI/TextUtil.h"
#include "Editor/Src/CommandImplementation.h"
#include "Runtime/Graphics/Transform.h"
#include "Runtime/Utilities/FileUtilities.h"
#include "Runtime/Utilities/File.h"
#include "Editor/Src/AssetPipeline/AssetDatabase.h"
#include "Editor/Platform/Interface/EditorUtility.h"
#include "Editor/Platform/Windows/Metro/MetroEditorUtility.h"
#include "Runtime/Mono/MonoBehaviour.h"
#include "Editor/Mono/MonoEditorUtility.h"
#include "Editor/Src/AssetPipeline/ShaderImporter.h"
#include "Runtime/Shaders/Shader.h"
#include "Editor/Src/Utility/ObjectNames.h"
#include "Runtime/Serialize/PersistentManager.h"
#include "Runtime/Serialize/TransferUtility.h"
#include "Editor/Src/DragAndDropForwarding.h"
#include "Editor/Src/GUIDPersistentManager.h"
#include "Editor/Src/MenuController.h"
#include "Runtime/Graphics/RenderTexture.h"
#include "Runtime/Misc/SaveAndLoadHelper.h"
#include "Editor/Src/BuildPipeline/BuildSerialization.h"
#include "Runtime/GfxDevice/GfxDevice.h"
#include "Editor/Src/Utility/BuildPlayerUtility.h"
#include "Editor/Src/AssetPipeline/MovieImporter.h"
#include "Editor/Src/LicenseInfo.h"
#include "Runtime/Network/NetworkManager.h"
#include "Runtime/Shaders/VBO.h"
#include "Editor/Src/EditorHelper.h"
#include "Editor/Platform/Interface/DragAndDrop.h"
#include "Runtime/Misc/InputEvent.h"
#include "Editor/Src/PopupMenuUtility.h"
#include "Editor/Src/Panels/HelpPanel.h"
#include "Runtime/Mono/MonoScript.h"
#include "Runtime/Mono/MonoManager.h"
#include "Runtime/Scripting/ScriptingUtility.h"
#include "Runtime/Utilities/PlayerPrefs.h"
#include "Runtime/Misc/QualitySettings.h"
#include "Runtime/Graphics/ScreenManager.h"
#include "Editor/Src/Selection.h"
#include "Editor/Src/SelectionHistory.h"
#include "Runtime/Misc/PlayerSettings.h"
#include "Runtime/Camera/Camera.h"

#include "Editor/Src/Utility/GeometryToolboxImpl.h"
#include "Editor/Src/AssetPipeline/ImportMeshUtility.h"

#include "Editor/Platform/Interface/BugReportingTools.h"
#include "Runtime/BaseClasses/IsPlaying.h"
#include "Editor/Src/Application.h"
#include "Runtime/BaseClasses/Tags.h"
#include "Runtime/GfxDevice/opengl/UnityGL.h"
#include "Editor/Platform/Interface/ColorPicker.h"
#include "Editor/Src/Utility/Analytics.h"
#include "Editor/Src/AssetPipeline/AssetImporterUtil.h"
#include "Runtime/Shaders/GraphicsCaps.h"
#include "Editor/Src/AssetServer/ASMonoUtility.h"
#include "Editor/Src/Utility/DiffTool.h"
#include "Runtime/Scripting/ScriptingExportUtility.h"
#include "Editor/Src/Animation/StateMachine.h"
#include "Editor/Src/Animation/CloneObjectAnimation.h"
#include "Runtime/Scripting/Scripting.h"


extern GraphicsCaps gOriginalCaps;

using namespace std;

CSRAW
using System;
using UnityEngine;
using Object=UnityEngine.Object;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Collections;
using UnityEditorInternal; // for StateMachine

namespace UnityEditor
{


// SelectionMode can be used to tweak the selection returned by Selection.GetTransforms.
ENUM SelectionMode
	// Return the whole selection.
	Unfiltered = 0,
	// Only return the topmost selected transform. A selected child of another selected transform will be filtered out.
	TopLevel = 1,
	// Return the selection and all child transforms of the selection.
	Deep = 2,
	// Excludes any prefabs from the selection.
	ExcludePrefab = 4,

	// Excludes any objects which shall not be modified.
	Editable = 8,

	// Only return objects that are assets in the Asset directory.
	Assets = 16,

	// If the selection contains folders, also include all assets and subfolders within that folder in the file hierarchy.
	DeepAssets = 32,

	// Return a selection that only contains top level selection of all visible assets
	//TopLevelAssets = 64,

	//*undocumented* renamed to Editable
	OnlyUserModifiable = 8
END


// Access to the selection in the editor.
CLASS Selection

	// Returns the top level selection, excluding prefabs.
	CUSTOM_PROP static Transform[] transforms { return CreateScriptingArrayFromUnityObjects (GetTransformSelection(), ClassID(Transform)); }

	// Returns the active transform. (The one shown in the inspector)
	CUSTOM_PROP static Transform   activeTransform { return Scripting::ScriptingWrapperFor(GetActiveTransform()); } { SetActiveObject (value); }

	// Returns the actual game object selection. Includes prefabs, non-modifyable objects.
	CUSTOM_PROP static GameObject[] gameObjects { return CreateScriptingArrayFromUnityObjects (GetGameObjectSelection(), ClassID(GameObject)); }

	// Returns the active game object. (The one shown in the inspector)
	CUSTOM_PROP static GameObject   activeGameObject { return Scripting::ScriptingWrapperFor(GetActiveGO()); } { SetActiveObject (value); }

	// Returns the actual object selection. Includes prefabs, non-modifyable objects.
	CUSTOM_PROP static Object   activeObject { return Scripting::ScriptingWrapperFor(GetActiveObject()); } { SetActiveObject (value); }

	// Returns the instanceID of the actual object selection. Includes prefabs, non-modifyable objects.
	CUSTOM_PROP static int   activeInstanceID { return Selection::GetActiveID(); } { Selection::SetActiveID (value); }

	// The actual unfiltered selection from the Scene.
	CUSTOM_PROP static Object[] objects 
	{
		TempSelectionSet selection;
		GetSceneTracker().GetSelection(selection);
		return CreateScriptingArrayFromUnityObjects (selection, ClassID(Object)); 
	}
	{
		TempSelectionSet objs; 
		MonoObjectArrayToSet(value, objs); 
		GetSceneTracker().SetSelection(objs); 
	}

	// The actual unfiltered selection from the Scene returned as instance ids instead of ::ref::objects.
	CUSTOM_PROP static int[] instanceIDs {
		set<int> ids = GetSceneTracker().GetSelectionID();
		return SetToMonoArray(ids, MONO_COMMON.int_32);
	}
	{
		set<int> instanceIDs;
		MonoArrayToSet(value, instanceIDs);
		GetSceneTracker().SetSelectionID( instanceIDs );
	}

	///*listonly*
	CSRAW public static bool Contains(int instanceID) { return (System.Array.IndexOf<int>( instanceIDs, instanceID ) != -1); }

	// Returns whether an object is contained in the current selection.
	CSRAW public static bool Contains(Object obj) { return Contains(obj.GetInstanceID()); }

	// Allows for fine grained control of the selection type using the [[SelectionMode]] bitmask.
	CUSTOM static Transform[] GetTransforms (SelectionMode mode) { return CreateScriptingArrayFromUnityObjects (GetTransformSelection(mode), ClassID(Transform)); }

	// Returns the current selection filtered by type and mode.
	CSRAW public static Object[] GetFiltered (Type type, SelectionMode mode)
	{
		ArrayList list = new ArrayList();
		// Components are searched
		if (type == typeof (Component) || type.IsSubclassOf (typeof(Component)))
		{
			Transform[] transforms = GetTransforms (mode);
			foreach (Transform t in transforms)
			{
				Component com = t.GetComponent(type);
				if (com)
					list.Add (com);
			}
		}
		else if (type == typeof (GameObject) || type.IsSubclassOf (typeof(GameObject)))
		{
			Transform[] transforms = GetTransforms (mode);
			foreach (Transform t in transforms)
				list.Add (t.gameObject);
		}
		else
		{
			Object[] objects = GetObjectsMode (mode);
			foreach (Object o in objects)
			{
				if (o != null)
				{
					if (o.GetType() == type || o.GetType().IsSubclassOf (type))
						list.Add (o);
				}			}
		}
		return (Object[])list.ToArray(typeof(Object));
	}
	
	CONDITIONAL ENABLE_SELECTIONHISTORY
	CUSTOM static bool HasPrevious()
	{
		return HasPreviousSelection();
	}
	
	CONDITIONAL ENABLE_SELECTIONHISTORY
	CUSTOM static bool HasNext()
	{
		return HasNextSelection();
	}
	
	CONDITIONAL ENABLE_SELECTIONHISTORY
	CUSTOM static void SelectPrevious()
	{
		GotoPreviousSelection();
	}
	
	CONDITIONAL ENABLE_SELECTIONHISTORY
	CUSTOM static void SelectNext()
	{
		GotoNextSelection();
	}

	//* undocumented - utility function
	CUSTOM internal static Object[] GetObjectsMode(SelectionMode mode) 
	{
		TempSelectionSet objects;
		GetObjectSelection(mode,objects);
		return CreateScriptingArrayFromUnityObjects (objects, ClassID(Object));
	}


	CUSTOM_PROP static internal string[] assetGUIDs
	{
		return AssetServer::ConvertToGUIDs (GetSelectedAssets (kDeepAssetsSelection));
	}

END


// Editor utility functions.
CLASS EditorUtility

	CUSTOM static void RevealInFinder (string path)
	{
		RevealInFinder (path);
	}

	/// Marks /target/ object as dirty.
	///
	/// Unity internally uses the dirty flag to find out when assets have changed and need to be saved to disk.
	///
	/// E.g. if you modify a prefab's [[MonoBehaviour]] or [[ScriptableObject]] variables, you must tell Unity that the value has changed.
	/// Unity builtin components internally call SetDirty whenever a property changes.
	/// [[MonoBehaviour]] or [[ScriptableObject]] don't do this automatically so if you want your value to be saved you need to call SetDirty.
	///
	BEGIN EX
	#pragma strict
	// This example shows a custom inspector for an
	// object "MyPlayerEditor", which has two variables, speed and ammo.
	@CustomEditor(MyPlayer)
	class MyPlayerEditor extends Editor {
		function OnInspectorGUI()
		{
			var targetPlayer = target as MyPlayer;
			EditorGUILayout.LabelField ("Some help", "Some other text");

			GUI.changed = false;
			targetPlayer.speed = EditorGUILayout.Slider ("Speed", targetPlayer.speed, 0, 100);
			if (GUI.changed)
				EditorUtility.SetDirty(targetPlayer);
		}
	}
	END EX
	///
	CUSTOM static void SetDirty (Object target) { target->SetDirty(); }

	CUSTOM internal static int GetDirtyIndex (int instanceID)
	{
		Object* asset = Object::IDToPointer (instanceID);

		// If the asset is null then it has not been loaded yet
		if ( asset && asset->IsPersistent() )
		{
			return asset->GetPersistentDirtyIndex ();
		}
		return 0; // not dirty
	}

	CUSTOM internal static bool IsDirty (int instanceID)
	{
		Object* asset = Object::IDToPointer (instanceID);

		// If the asset is null then it has not been loaded yet
		if ( asset && asset->IsPersistent() )
		{
			return asset->IsPersistentDirty ();
		}
		return false;
	}

	//*undocumented*
	CSRAW public static bool LoadWindowLayout(string path)
	{
		bool newProjectLayoutWasCreated = false;
		return UnityEditor.WindowLayout.LoadWindowLayout (path, newProjectLayoutWasCreated);
	}

	// Determines if an object is stored on disk.
	CUSTOM static bool IsPersistent (Object target) { return target->IsPersistent(); }

	// Displays a modal dialog.
	CUSTOM static bool DisplayDialog (string title, string message, string ok, string cancel = "") { return DisplayDialog (title, message, ok, cancel); }

	// Displays a modal dialog with three buttons.
	CUSTOM static int DisplayDialogComplex (string title, string message, string ok, string cancel, string alt) { return DisplayDialogComplex(title, message, ok, cancel, alt); }


	// Displays the "open file" dialog and returns the selected path name.
	CUSTOM static string OpenFilePanel (string title, string directory, string extension)
	{
		return scripting_string_new( RunOpenPanel (title, directory, extension));
	}

	// Displays the "save file" dialog and returns the selected path name.
	CUSTOM static string SaveFilePanel (string title, string directory, string defaultName, string extension)
	{
		return scripting_string_new( RunSavePanel (title, directory, extension, defaultName));
	}

	CUSTOM static internal string SaveBuildPanel (BuildTarget target, string title, string directory, string defaultName, string extension)
	{
		return scripting_string_new( RunSaveBuildPanel (target, title, directory, defaultName, extension));
	}

	// Compares two strings, sorting them like the finder would.
	CUSTOM static internal int SemiNumericCompare (string a, string b)
	{
		return SemiNumericCompare (a, b);
	}


	// Displays the "open folder" dialog and returns the selected path name.
	CUSTOM static string OpenFolderPanel (string title, string folder, string defaultName)
	{
		return scripting_string_new( RunOpenFolderPanel(title, folder, defaultName));
	}

	// Displays the "save folder" dialog and returns the selected path name.
	CUSTOM static string SaveFolderPanel (string title, string folder, string defaultName)
	{
		return scripting_string_new( RunSaveFolderPanel(title, folder, defaultName, true));
	}

	// Displays the "save file" dialog in the Assets folder of the project and returns the selected path name.
	CSRAW public static string SaveFilePanelInProject (string title, string defaultName, string extension, string message)
	{
		return Internal_SaveFilePanelInProject (title, defaultName, extension, message, "Assets");
	}

	// Displays the "save file" dialog in the specified folder of the project and returns the selected path name.
	CSRAW public static string SaveFilePanelInProject (string title, string defaultName, string extension, string message, string path)
	{
		return Internal_SaveFilePanelInProject (title, defaultName, extension, message, path);
	}

	CUSTOM private static string Internal_SaveFilePanelInProject (string title, string defaultName, string extension, string message, string path)
	{
		return scripting_string_new( RunSavePanelInProject (title, defaultName, extension, message, path));
	}

	//*undocumented*
	CUSTOM static bool WarnPrefab (Object target, string title, string warning, string okButton)
	{
		return WarnPrefab(target, title.AsUTF8().c_str(), warning.AsUTF8().c_str(), okButton.AsUTF8().c_str());
	}

	OBSOLETE warning use AssetDatabase.LoadAssetAtPath
	CUSTOM static Object FindAsset (string path, Type type) {
		return FindAssetWithKlass(path, type);
	}

	// Translates an instance ID to a reference to an object.
	CUSTOM static Object InstanceIDToObject (int instanceID)
	{
		return Scripting::ScriptingWrapperFor(PPtr<Object> (instanceID));
	}


	// Compress a texture.
	CUSTOM static void CompressTexture(Texture2D texture, TextureFormat format, int quality)
	{
		CompressTexture(*texture, format, quality);
	}
	//
	CSRAW public static void CompressTexture(Texture2D texture, TextureFormat format, TextureCompressionQuality quality)
	{
		CompressTexture(texture, format, (int)quality);
	}
	//
	CSRAW static void CompressTexture(Texture2D texture, TextureFormat format)
	{
		CompressTexture(texture, format, TextureCompressionQuality.Normal);
	}

	//*undocumented*
	CUSTOM static string InvokeDiffTool( string leftTitle, string leftFile, string rightTitle, string rightFile, string ancestorTitle, string ancestorFile ) {
		return scripting_string_new( InvokeDiffTool( leftTitle, leftFile, rightTitle, rightFile, ancestorTitle, ancestorFile) );
	}

	// Copy all settings of a Unity [[Object]].
	CUSTOM static void CopySerialized (Object source, Object dest)
	{
		CopySerialized(*source, *dest);
	}

	OBSOLETE warning Use AssetDatabase.GetAssetPath
	CSRAW public static string GetAssetPath (Object asset)
	{
		return AssetDatabase.GetAssetPath(asset);
	}

	// Calculates and returns a list of all assets the assets listed in /roots/ depend on.
	CUSTOM static Object[] CollectDependencies (Object[] roots)
	{
		TempSelectionSet croots;
		MonoObjectArrayToSet(roots, croots);
		TempSelectionSet crootdeps;
		CollectAllDependencies(croots, crootdeps);
		return CreateScriptingArrayFromUnityObjects(crootdeps, ClassID(Object));
	}

	// Calculates and returns a list of all assets the assets listed in /roots/ depend on.
	CUSTOM static Object[] CollectDeepHierarchy (Object[] roots)
	{
		set<SInt32> output;
		int i;
		for (i=0;i<mono_array_length_safe(roots);i++)
		{
			int instanceID = Scripting::GetInstanceIDFromScriptingWrapper(GetMonoArrayElement<MonoObject*>(roots, i));
			Object* objectPtr = dynamic_instanceID_cast<Object*> (instanceID);
			if (objectPtr)
				CollectPPtrs(*objectPtr, &output);
		}

		MonoArray* array = mono_array_new (mono_domain_get (), ScriptingClassFor(Object), output.size());

		i = 0;
		for (set<SInt32>::iterator j=output.begin();j!=output.end();j++,i++)
			Scripting::SetScriptingArrayElement(array, i, Scripting::ScriptingWrapperFor(dynamic_instanceID_cast<Object*> (*j)));
		return array;
	}

	CSRAW internal static Object InstantiateRemoveAllNonAnimationComponents  (Object original, Vector3 position, Quaternion rotation)
	{
		if (original==null)
			throw new ArgumentException("The prefab you want to instantiate is null.");		

		return Internal_InstantiateRemoveAllNonAnimationComponentsSingle (original, position, rotation);
	}

	CUSTOM private static Object Internal_InstantiateRemoveAllNonAnimationComponentsSingle (Object data, Vector3 pos, Quaternion rot)
	{
		DISALLOW_IN_CONSTRUCTOR
		Object* obj = &InstantiateObjectRemoveAllNonAnimationComponents (*data, pos, rot);
		return Scripting::ScriptingWrapperFor(obj);
	}


	// Unloads assets that are not used.
	CUSTOM static void UnloadUnusedAssets ()
	{
		UnloadUnusedAssetsImmediate(true);
	}

	// Unloads assets that are not used, including the ones that are referenced only from scripts.
	CUSTOM static void UnloadUnusedAssetsIgnoreManagedReferences ()
	{
		UnloadUnusedAssetsImmediate(false);
	}

	OBSOLETE warning Use BuildPipeline.BuildAssetBundle instead
	CSRAW public static bool BuildResourceFile (Object[] selection, string pathName)
	{
		return BuildPipeline.BuildAssetBundle(null, selection, pathName, BuildAssetBundleOptions.CompleteAssets);
	}

	CUSTOM internal static void Internal_DisplayPopupMenu (Rect position, string menuItemPath, Object context, int contextUserData)
	{
		std::vector<Object*> c;
		if (context != NULL)
			c.push_back (context);
		MenuController::DisplayPopupMenu(position, menuItemPath, c, contextUserData);
	}

	// Displays a popup menu.
	CSRAW static public void DisplayPopupMenu (Rect position, string menuItemPath, MenuCommand command)
	{
		// Validate input. Fixes case 406024: 'Custom context menu in a custom window crashes Unity'
		if (menuItemPath == "CONTEXT" || menuItemPath == "CONTEXT/" || menuItemPath == "CONTEXT\\")
		{
			bool error = false;
			if (command == null)
				error = true;

			if (command != null && command.context == null)
				error = true;

			if (error)
			{
				Debug.LogError("DisplayPopupMenu: invalid arguments: using CONTEXT requires a valid MenuCommand object. If you want a custom context menu then try using the GenericMenu.");
				return;
			}
		}

		Vector2 temp = GUIUtility.GUIToScreenPoint (new Vector2 (position.x, position.y));
		position.x = temp.x;
		position.y = temp.y;
		Internal_DisplayPopupMenu (position, menuItemPath, command == null ? null : command.context, command == null ? 0 : command.userData);
		ResetMouseDown ();
	}

	// Displays the objects context menu
	CSRAW internal static void DisplayObjectContextMenu (Rect position, Object context, int contextUserData)
	{
		DisplayObjectContextMenu (position, new Object[] { context }, contextUserData);
	}
	CSRAW internal static void DisplayObjectContextMenu (Rect position, Object[] context, int contextUserData)
	{
		Vector2 temp = GUIUtility.GUIToScreenPoint (new Vector2 (position.x, position.y));
		position.x = temp.x;
		position.y = temp.y;

		Internal_DisplayObjectContextMenu (position, context, contextUserData);
		ResetMouseDown ();
	}
	CUSTOM internal static void Internal_DisplayObjectContextMenu (Rect position, Object[] context, int contextUserData)
	{
		vector<Object*> monoObjects;
		MonoObjectArrayToVector(context, monoObjects);
		DisplayObjectContextPopupMenu (position, monoObjects, contextUserData);
	}

	//*undocumented
	CSRAW public delegate void SelectMenuItemFunction (object userData, string[] options, int selected);

	//*undocumented
	CSRAW public static void DisplayCustomMenu (Rect position, GUIContent[] options, int selected, SelectMenuItemFunction callback, object userData)
	{
		int[] selectedArray = { selected };
		string[] strings = new string[options.Length];
		for (int i = 0; i < options.Length;i++)
			strings[i] = options[i].text;

		DisplayCustomMenu(position, strings, selectedArray, callback, userData);
	}

	CSRAW internal static void DisplayCustomMenu (Rect position, string[] options, int[] selected, SelectMenuItemFunction callback, object userData)
	{
		Vector2 temp = GUIUtility.GUIToScreenPoint (new Vector2 (position.x, position.y));
		position.x = temp.x;
		position.y = temp.y;

		int[] enabled = new int[options.Length];
		for (int i = 0; i < options.Length;i++)
			enabled[i] = 1;

		Internal_DisplayCustomMenu (position, options, enabled, selected, callback, userData);
		ResetMouseDown ();
	}

	CSRAW internal static void DisplayCustomMenu (Rect position, string[] options, bool[] enabled, int[] selected, SelectMenuItemFunction callback, object userData)
	{
		Vector2 temp = GUIUtility.GUIToScreenPoint (new Vector2 (position.x, position.y));
		position.x = temp.x;
		position.y = temp.y;

		int[] ienabled = new int[options.Length];
		for (int i = 0; i < options.Length;i++)
			ienabled[i] = enabled[i]?1:0;
		Internal_DisplayCustomMenu (position, options, ienabled, selected, callback, userData);
		ResetMouseDown ();
	}

	CUSTOM private static void Internal_DisplayCustomMenu (Rect screenPosition, string[] options, int[] enabled, int[] selected, SelectMenuItemFunction callback, object userData)
	{
		vector<string> cenums;
		StringMonoArrayToVector(options, cenums);
		vector<int> cselected (Scripting::GetScriptingArrayStart<int>(selected), Scripting::GetScriptingArrayStart<int>(selected) + GetScriptingArraySize(selected));
		vector<bool> cenabled (Scripting::GetScriptingArrayStart<int>(enabled), Scripting::GetScriptingArrayStart<int>(enabled) + GetScriptingArraySize(enabled));

		DisplayCustomContextPopupMenu(screenPosition, cenums, cenabled, cselected, callback, userData);
	}

	// Sigh... We never get an event for the mouse up when showing a menu so we need some manual tracking to get to know about it.
	CSRAW internal static void ResetMouseDown ()
	{
		Tools.s_ButtonDown = -1;
		EditorGUIUtility.hotControl = 0;
	}

	CUSTOM internal static void SetTemporarilyAllowIndieRenderTexture (bool allow)
	{
		static GraphicsCaps s_SavedCaps;
		if (allow)
		{
			s_SavedCaps = gGraphicsCaps;
			gGraphicsCaps.InitializeOriginalEmulationCapsIfNeeded(); // make sure gOriginalCaps is initialized
			gGraphicsCaps = gOriginalCaps;
		}
		else
		{
			gGraphicsCaps = s_SavedCaps;
		}
		RenderTexture::SetTemporarilyAllowIndieRenderTexture (allow);
	}

	// Brings the project window to the front and focuses it.
	CUSTOM static void FocusProjectWindow ()
	{
		FocusProjectView();
	}

	// Returns a text for a number of bytes.
	CUSTOM static string FormatBytes (int bytes)
	{
		return scripting_string_new(FormatBytes (bytes));
	}

	// Displays or updates a progress bar.
	CUSTOM static void DisplayProgressBar (string title, string info, float progress)
	{
		DisplayProgressbar(title, info, progress);
	}

	// Displays or updates a progress bar that has a cancel button.
	CUSTOM static bool DisplayCancelableProgressBar(string title, string info, float progress)
	{
		return DisplayProgressbar(title, info, progress, true) == kPBSWantsToCancel;
	}

	// Removes progress bar.
	CUSTOM static void ClearProgressBar ()
	{
		ClearProgressbar();
	}

	// Is the object enabled (0 disabled, 1 enabled, -1 has no enabled button)
	CUSTOM static int GetObjectEnabled (Object target) { return GetObjectEnabled (target); }

	// Set the enabled state of the object
	CUSTOM static void SetObjectEnabled (Object target, bool enabled) { SetObjectEnabled (target, enabled); }

	// Set whether the renderer's wireframe will be hidden when the renderer's gameobject is selected
	CUSTOM static void SetSelectedWireframeHidden (Renderer renderer, bool enabled)
	{
		if (renderer == NULL) return;
		renderer->SetSelectedWireframeHidden(enabled);
	}

	// Helper function to ensure that inspectors are reloaded (caches are cleared etc.)
	CUSTOM internal static void ForceReloadInspectors ()
	{
		GetSceneTracker().ForceReloadInspector(false);
	}

	// Helper function to recreate editors completely.
	CUSTOM internal static void ForceRebuildInspectors ()
	{
		GetSceneTracker().ForceReloadInspector(true);
	}


	// Saves an AudioClip or MovieTexture to a file.
	CUSTOM static bool ExtractOggFile (Object obj, string path)
	{
		return ExtractOggFile(obj, path);
	}

	// Creates a game object with [[HideFlags]] and specified components.
	CSRAW static public GameObject CreateGameObjectWithHideFlags (string name, HideFlags flags, params Type[] components)
	{
		GameObject go = Internal_CreateGameObjectWithHideFlags (name, flags);
		// always add Transform
		go.AddComponent (typeof(Transform));
		foreach (Type t in components)
			go.AddComponent (t);
		return go;
	}

	CUSTOM internal static GameObject Internal_CreateGameObjectWithHideFlags (string name, HideFlags flags)
	{
		GameObject* go = NEW_OBJECT(GameObject);
		go->SetHideFlags(flags);
		go->Reset ();
		go->SetNameCpp(name);
		go->AwakeFromLoad(kInstantiateOrCreateFromCodeAwakeFromLoad);
		go->Activate();
		return Scripting::ScriptingWrapperFor(go);
	}

	//*undocumented*
	// TODO: Remove as soon as Graphs code is moved into UnityEditor assembly. Now need to call this from players assembly.
	CSRAW public static string[] CompileCSharp(string[] sources, string[] references, string[] defines, string outputFile)
	{
		return UnityEditor.Scripting.Compilers.MonoCSharpCompiler.Compile(sources, references, defines, outputFile);
	}

	// *undocumented*
	CUSTOM static void OpenWithDefaultApp(string fileName)
	{
		OpenWithDefaultApp(fileName);
	}

	OBSOLETE warning Use PrefabUtility.InstantiatePrefab
	CSRAW public static Object InstantiatePrefab (Object target)
	{
		return PrefabUtility.InstantiatePrefab (target);
	}

	OBSOLETE warning Use PrefabUtility.ReplacePrefab
	CSRAW public static GameObject ReplacePrefab (GameObject go, Object targetPrefab, ReplacePrefabOptions options)
	{
		return PrefabUtility.ReplacePrefab (go, targetPrefab, options);
	}

	OBSOLETE warning Use PrefabUtility.ReplacePrefab
	CSRAW public static GameObject ReplacePrefab (GameObject go, Object targetPrefab)
	{
		return PrefabUtility.ReplacePrefab (go, targetPrefab, ReplacePrefabOptions.Default);
	}


	OBSOLETE warning Use PrefabUtility.CreateEmptyPrefab
	CSRAW public static Object CreateEmptyPrefab (string path)
	{
		return PrefabUtility.CreateEmptyPrefab (path);
	}

	OBSOLETE warning Use PrefabUtility.CreateEmptyPrefab
	CSRAW public static bool ReconnectToLastPrefab (GameObject go)
	{
		return PrefabUtility.ReconnectToLastPrefab(go);
	}

	OBSOLETE warning Use PrefabUtility.GetPrefabType
	CSRAW public static PrefabType GetPrefabType (Object target)
	{
		return PrefabUtility.GetPrefabType(target);
	}

	OBSOLETE warning Use PrefabUtility.GetPrefabParent
	CSRAW public static Object GetPrefabParent (Object source)
	{
		return PrefabUtility.GetPrefabParent(source);
	}

	OBSOLETE warning Use PrefabUtility.FindPrefabRoot
	CSRAW static public GameObject FindPrefabRoot (GameObject source)
	{
		return PrefabUtility.FindPrefabRoot(source);
	}

	OBSOLETE warning Use PrefabUtility.ResetToPrefabState
	CSRAW static public bool ResetToPrefabState (Object source)
	{
		return PrefabUtility.ResetToPrefabState(source);
	}

	CUSTOM static internal void SetCameraAnimateMaterials (Camera camera, bool animate)
	{
		camera->SetAnimateMaterials (animate);
	}

	CUSTOM static internal string GetInvalidFilenameChars ()
	{
		return scripting_string_new (GetInvalidFilenameChars());
	}

END

// The MenuItem attribute allows you to add menu items to the main menu and inspector context menus.
CSRAW [AttributeUsage(AttributeTargets.Method, AllowMultiple=true)]
CLASS MenuItem : Attribute

	// Creates a menu item and invokes the static function following it, when the menu item is selected.
	CSRAW public MenuItem (string itemName, bool isValidateFunction, int priority) {	menuItem = itemName; validate = isValidateFunction; this.priority = priority; }

	// Creates a menu item and invokes the static function following it, when the menu item is selected.
	CSRAW public MenuItem (string itemName, bool isValidateFunction) {	menuItem = itemName; validate = isValidateFunction; priority = 1000; }

	// Creates a menu item and invokes the static function following it, when the menu item is selected.
	CSRAW public MenuItem (string itemName) { menuItem = itemName; validate = false; priority = 1000; }

	// Creates a menu item and invokes the static function following it, when the menu item is selected.
	CSRAW internal MenuItem (string itemName, bool isValidateFunction, int priority, bool internalMenu)
	{
		if (internalMenu)
			menuItem = "internal:" + itemName;
		else
			menuItem = itemName;
		validate = isValidateFunction;
		this.priority = priority;
	}
	
	//*undocumented*
	CSRAW public string menuItem;
	//*undocumented*
	CSRAW public bool validate;
	//*undocumented*
	CSRAW public int priority;
END

// Used to extract the context for a [[MenuItem]]. MenuCommand objects are passed to custom menu item functions defined using the [[MenuItem]] attribute.
CSRAW [StructLayout (LayoutKind.Sequential)]
CLASS MenuCommand

	// Context is the object that is the target of a menu command.
	CSRAW public Object context;
	// An integer for passing custom information to a menu item.
	CSRAW public int    userData;

	// Creates a new MenuCommand object.
	CSRAW public MenuCommand (Object inContext, int inUserData) { context = inContext; userData = inUserData;  }
	// Creates a new MenuCommand object.
	CSRAW public MenuCommand (Object inContext) { context = inContext; userData = 0;  }
END


// Determines how a gizmo is drawn or picked in the Unity editor.
ENUM GizmoType
	// Draw the gizmo if it is active (shown in the inspector).
	Active = 8,
	// Draw the gizmo if it is selected or a child of the selection.
	SelectedOrChild = 16,

	// Draw the gizmo if it is not selected at all.
	NotSelected = 2,

	// Draw the gizmo if it is selected.
	Selected = 4,

	// The gizmo can be picked in the editor.
	Pickable = 1
END

// The DrawGizmo attribute allows you to supply a gizmo renderer for any [[Component]].
CLASS DrawGizmo : System.Attribute

	// Defines when the gizmo should be invoked for drawing.
	CSRAW public  DrawGizmo (GizmoType gizmo)
	{
		drawOptions = gizmo;
	}

	// Same as above. /drawnGizmoType/ determines of what type the object we are drawing the gizmo of has to be.
	CSRAW public DrawGizmo (GizmoType gizmo, Type drawnGizmoType)
	{
		drawnType = drawnGizmoType;
		drawOptions = gizmo;
	}

	//*undocumented
	CSRAW public Type drawnType;
	//*undocumented
	CSRAW public GizmoType drawOptions;
END

// Stores and accesses Unity editor preferences.
CLASS EditorPrefs

	// Sets the value of the preference identified by /key/.
	CUSTOM public static void SetInt (string key, int value) { EditorPrefs::SetInt (key, value); }

	// Returns the value corresponding to /key/ in the preference file if it exists.
	CUSTOM static int GetInt (string key, int defaultValue = 0) { return EditorPrefs::GetInt (key, defaultValue); }

	// Sets the value of the preference identified by /key/.
	CUSTOM public static void SetFloat (string key, float value) { EditorPrefs::SetFloat (key, value); }

	// Returns the value corresponding to /key/ in the preference file if it exists.
	CUSTOM static float GetFloat (string key, float defaultValue = 0.0F) { return EditorPrefs::GetFloat (key, defaultValue); }

	// Sets the value of the preference identified by /key/.
	CUSTOM public static void SetString (string key, string value) { EditorPrefs::SetString (key, value); }

	// Returns the value corresponding to /key/ in the preference file if it exists.
	CUSTOM static string GetString (string key, string defaultValue = "") { return scripting_string_new(EditorPrefs::GetString (key, defaultValue)); }

	// Sets the value of the preference identified by /key/.
	CUSTOM public static void SetBool (string key, bool value) { EditorPrefs::SetBool (key, (bool)value); }

	// Returns the value corresponding to /key/ in the preference file if it exists.
	CUSTOM static bool GetBool (string key, bool defaultValue = false) { return (short)EditorPrefs::GetBool (key, (bool)defaultValue); }

	// Returns true if /key/ exists in the preferences.
	CUSTOM static bool HasKey(string key) { return (short)EditorPrefs::HasKey(key); }

	// Removes /key/ and its corresponding value from the preferences.
	CUSTOM static void DeleteKey(string key) { EditorPrefs::DeleteKey(key); }

	// Removes all keys and values from the preferences. Use with caution.
	CUSTOM static void DeleteAll() { EditorPrefs::DeleteAll(); }



END





// Helper class to access Unity documentation.
CLASS Help
	// Is there a help page for this object?
	CSRAW public static bool HasHelpForObject (Object obj) { return HasHelpForObject(obj, true); }
	
	// Intentionally internal. Extra argument only used to make doc authoring easier.
	CUSTOM internal static bool HasHelpForObject (Object obj, bool defaultToMonoBehaviour) { return HasHelpForObject(obj, defaultToMonoBehaviour); }
	
	// Intentionally internal.
	CSRAW internal static string GetNiceHelpNameForObject (Object obj)
	{
		return GetNiceHelpNameForObject (obj, true);
	}
	// Intentionally internal.
	CUSTOM internal static string GetNiceHelpNameForObject (Object obj, bool defaultToMonoBehaviour)
	{
		return scripting_string_new(GetNiceHelpNameForObject(obj, defaultToMonoBehaviour));
	}

	// Show help page for this object.
	CUSTOM static void ShowHelpForObject (Object obj) { ShowHelpForObject(obj); }

	// Show a help page.
	CUSTOM static void ShowHelpPage (string page) { ShowNamedHelp (page.AsUTF8().c_str()); }

	// Open /url/ in the default web browser.
	CUSTOM static void BrowseURL (string url) { OpenURLInWebbrowser (url.AsUTF8().c_str()); }
END


// Helper class for constructing displayable names for objects.
CLASS ObjectNames

	// Make a displayable name for a variable.
	CUSTOM static string NicifyVariableName (string name) { return scripting_string_new(MangleVariableName(name.AsUTF8().c_str())); }


	// Inspector title for an object.
	CUSTOM static string GetInspectorTitle (Object obj) { return scripting_string_new(GetPropertyEditorTitle(obj)); }

	// Class name of an object.
	CUSTOM static string GetClassName (Object obj) { return scripting_string_new(obj->GetClassName()); }

	// Like GetClassName but handles folders, scenes, GUISkins, and other default assets as separate types.
	CSRAW internal static string GetTypeName (Object obj)
	{
		string pathLower = AssetDatabase.GetAssetPath (obj).ToLower ();
		if (pathLower.EndsWith (".unity"))
			return "Scene";
		else if (pathLower.EndsWith (".guiskin"))
			return "GUI Skin";
		else if (System.IO.Directory.Exists (AssetDatabase.GetAssetPath (obj)))
			return "Folder";
		else if (obj.GetType () == typeof (Object))
			return System.IO.Path.GetExtension (pathLower) + " File";
		return ObjectNames.GetClassName (obj);
	}

	// Drag and drop title for an object.
	CUSTOM static string GetDragAndDropTitle (Object obj) { return scripting_string_new(GetDragAndDropTitle(obj)); }

	// Sets the name of an Object.
	CUSTOM static void SetNameSmart (Object obj, string name) { SetObjectNameSmart(obj, name); }

	CUSTOM internal static void SetNameSmartWithInstanceID (int instanceID, string name) { SetObjectNameSmart(PPtr<Object> (instanceID), name); }

	OBSOLETE warning Please use NicifyVariableName instead
	CSRAW public static string MangleVariableName (string name) { return NicifyVariableName(name); }

	OBSOLETE warning Please use GetInspectorTitle instead
	CSRAW public static string GetPropertyEditorTitle (Object obj) { return GetInspectorTitle(obj); }

END


// Visual indication mode for Drag & Drop operation.
ENUM DragAndDropVisualMode
	// No indication (drag should not be performed).
	None = 0,
	// Copy dragged objects.
	Copy = 1,
	// Link dragged objects to target.
	Link = 2,
	// Move dragged objects.
	Move = 16,
	// Generic drag operation.
	Generic = 4,
	// Rejected drag operation.
	Rejected = 32
END

// Editor drag & drop operations.
CLASS DragAndDrop

	// HandleDelayedDrag can be used to start a drag and drop
	CSRAW internal static bool HandleDelayedDrag (Rect position, int id, Object objectToDrag)
	{
		Event evt = Event.current;
		switch (evt.GetTypeForControl (id))
		{
		case EventType.MouseDown:
			if (position.Contains (evt.mousePosition) && evt.clickCount == 1)
			{
				if (evt.button == 0 && !(Application.platform == RuntimePlatform.OSXEditor && evt.control == true))
				{
					GUIUtility.hotControl = id;
					DragAndDropDelay delay = (DragAndDropDelay)GUIUtility.GetStateObject (typeof(DragAndDropDelay), id);
					delay.mouseDownPosition = evt.mousePosition;
					return true;
				}
			}
			break;
		case EventType.MouseDrag:
			if (GUIUtility.hotControl == id)
			{
				DragAndDropDelay delay = (DragAndDropDelay)GUIUtility.GetStateObject (typeof(DragAndDropDelay), id);
				if (delay.CanStartDrag()) {
					GUIUtility.hotControl = 0;
					DragAndDrop.PrepareStartDrag ();
					Object[] references = { objectToDrag };
					DragAndDrop.objectReferences = references;
					DragAndDrop.StartDrag (ObjectNames.GetDragAndDropTitle(objectToDrag));
					return true;
				}
			}
			break;
		}
		return false;
	}

	// Clears drag & drop data.
	CSRAW public static void PrepareStartDrag ()
	{
		ms_GenericData = null;
		PrepareStartDrag_Internal();
	}

	CUSTOM private static void PrepareStartDrag_Internal ()
	{
		GetDragAndDrop().PrepareStartDrag();
	}

	// Start a drag operation.
	CSRAW public static void StartDrag (string title)
	{
		if (Event.current.type == EventType.MouseDown || Event.current.type == EventType.MouseDrag)
		{
			StartDrag_Internal(title);
		}
		else
		{
			Debug.LogError("Drags can only be started from MouseDown or MouseDrag events");
		}
	}
	CUSTOM static private void StartDrag_Internal (string title) { GetDragAndDrop().StartDrag(title); }



	// References to [[Object|objects]] being dragged.
	CUSTOM_PROP static Object[] objectReferences
	{
		return CreateScriptingArrayFromUnityObjects(GetDragAndDrop().GetPPtrs(), ClassID(Object));
	}
	{
		vector<Object*> objs;
		MonoObjectArrayToVector(value, objs);
		GetDragAndDrop().SetPPtrs(objs);
	}

	// The file names being dragged.
	CUSTOM_PROP static string[] paths
	{
		return Scripting::StringVectorToMono(GetDragAndDrop().GetPaths());
	}
	{
		vector<string> str;
		StringMonoArrayToVector(value, str);
		GetDragAndDrop().SetPaths(str);
	}

	// The visual indication of the drag.
	CUSTOM_PROP static DragAndDropVisualMode visualMode { return GetDragAndDrop().GetVisualMode(); }  { GetDragAndDrop().SetVisualMode((DragAndDrop::DragVisualMode)value); }

	// Accept a drag operation.
	CUSTOM static void AcceptDrag () { GetDragAndDrop().AcceptDrag(); }

	// Get data associated with current drag and drop operation.
	CSRAW public static object GetGenericData (string type)
	{
		if (ms_GenericData != null && ms_GenericData.Contains(type))
			return ms_GenericData[type];
		else
			return null;
	}

	// Set data associated with current drag and drop operation.
	CSRAW public static void SetGenericData (string type, object data)
	{
		if (ms_GenericData == null)
			ms_GenericData =  new Hashtable ();
		ms_GenericData[type] = data;
	}

	// Get or set ID of currently active drag and drop control.
	CUSTOM_PROP static int activeControlID { return GetDragAndDrop().GetActiveControlID(); } { GetDragAndDrop().SetActiveControlID(value); }

	CSRAW static Hashtable ms_GenericData;

END

//*undocumented*
STRUCT internal MonoReloadableIntPtr
	CSRAW internal IntPtr  m_IntPtr;
END

//*undocumented*
STRUCT internal MonoReloadableIntPtrClear
	CSRAW internal IntPtr  m_IntPtr;
END

//*undocumented*
// Undocumented, but left public. Some people want to figure out draw calls from editor scripts to do some performance checking
// optimizations.
CLASS UnityStats
	// The network statistics
	CUSTOM static string GetNetworkStats(int i)
	{
		return scripting_string_new(GetNetworkManager().GetStats (i));
	}
	// The number of draw calls made this frame.
	CUSTOM_PROP static int drawCalls { return GetGfxDevice().GetFrameStats().GetDrawStats().calls; }
	// The number of batched draw calls made this frame.
	CUSTOM_PROP static int batchedDrawCalls { return GetGfxDevice().GetFrameStats().GetDrawStats().batchedCalls; }
	// The number of batches made this frame.
	CUSTOM_PROP static int batches { return GetGfxDevice().GetFrameStats().GetDrawStats().batches; }
	// The number of triangles rendered in this frame.
	CUSTOM_PROP static int triangles { return GetGfxDevice().GetFrameStats().GetDrawStats().trisSent; }
	// The number of vertices rendered in this frame.
	CUSTOM_PROP static int vertices { return GetGfxDevice().GetFrameStats().GetDrawStats().verts; }
	// The number of shadow casters rendered in this frame.
	CUSTOM_PROP static int shadowCasters { return GetGfxDevice().GetFrameStats().GetClientStats().shadowCasters; }
	// The number of render texture changes made this frame.
	CUSTOM_PROP static int renderTextureChanges { return GetGfxDevice().GetFrameStats().GetStateChanges().renderTexture; }

	CUSTOM_PROP static float frameTime { return GetGfxDevice().GetFrameStats().GetClientFrameTime(); }
	CUSTOM_PROP static float renderTime { return GetGfxDevice().GetFrameStats().GetRenderFrameTime(); }

	CUSTOM_PROP static int renderTextureCount { return RenderTexture::GetCreatedRenderTextureCount(); }
	CUSTOM_PROP static int renderTextureBytes { return RenderTexture::GetCreatedRenderTextureBytes(); }
	CUSTOM_PROP static int usedTextureMemorySize {
		#if ENABLE_PROFILER
			return GetGfxDevice().GetFrameStats().GetDrawStats().usedTextureBytes;
		#else
			return 0;
		#endif
	}
	CUSTOM_PROP static int usedTextureCount {
		#if ENABLE_PROFILER
			return GetGfxDevice().GetFrameStats().GetDrawStats().usedTextureCount;
		#else
			return 0;
		#endif
	}

	CUSTOM_PROP static string screenRes {
		const GfxDeviceStats::MemoryStats& mem = GetGfxDevice().GetFrameStats().GetMemoryStats();
		return scripting_string_new( mem.screenFSAA > 1 ? Format("%ix%i %ixAA", mem.screenWidth, mem.screenHeight, mem.screenFSAA, GetGfxDevice().GetFrameStats().GetMemoryStats().renderTextureBytes/1024/1024) : Format("%ix%i", mem.screenWidth, mem.screenHeight));
	}
	CUSTOM_PROP static int screenBytes {
		return GetGfxDevice().GetFrameStats().GetMemoryStats().screenBytes;
	}

	CUSTOM_PROP static int vboTotal { return GetGfxDevice().GetTotalVBOCount(); }
	CUSTOM_PROP static int vboTotalBytes { return GetGfxDevice().GetTotalVBOBytes(); }

	CUSTOM_PROP static int vboUploads { return GetGfxDevice().GetFrameStats().GetStateChanges().vboUploads; }
	CUSTOM_PROP static int vboUploadBytes { return GetGfxDevice().GetFrameStats().GetStateChanges().vboUploadBytes; }
	CUSTOM_PROP static int ibUploads { return GetGfxDevice().GetFrameStats().GetStateChanges().ibUploads; }
	CUSTOM_PROP static int ibUploadBytes { return GetGfxDevice().GetFrameStats().GetStateChanges().ibUploadBytes; }

	CUSTOM_PROP static int visibleSkinnedMeshes
	{
		#if ENABLE_PROFILER
			return SkinnedMeshRenderer::GetVisibleSkinnedMeshRendererCount();
		#else
			return 0;
		#endif
	}
	CUSTOM_PROP static int visibleAnimations
	{
		#if ENABLE_PROFILER
			return GetAnimationManager().GetUpdatedAnimationCount();
		#else
			return 0;
		#endif
	}
END


// Representation of Script assets.
CLASS MonoScript : TextAsset

	// Returns the System.Type object of the class implemented by this script
	CUSTOM System.Type GetClass()
	{
		return mono_class_get_object(self->GetClass());
	}

	// Returns the MonoScript object containing specified MonoBehaviour
	CUSTOM static MonoScript FromMonoBehaviour(MonoBehaviour behaviour)
	{
		return Scripting::ScriptingWrapperFor(behaviour->GetScript());
	}

	// Returns the MonoScript object containing specified ScriptableObject
	CUSTOM static MonoScript FromScriptableObject(ScriptableObject scriptableObject)
	{
		return Scripting::ScriptingWrapperFor(scriptableObject->GetScript());
	}

	CUSTOM internal bool GetScriptTypeWasJustCreatedFromComponentMenu()
	{
		return self->GetScriptTypeWasJustCreatedFromComponentMenu();
	}
	
	CUSTOM internal void SetScriptTypeWasJustCreatedFromComponentMenu()
	{
		self->SetScriptTypeWasJustCreatedFromComponentMenu();
	}

	// *undocumented*
	CUSTOM MonoScript ()
	{
		MonoScript* script = CreateObjectFromCode<MonoScript>(kDefaultAwakeFromLoad);
		Scripting::ConnectScriptingWrapperToObject (self.GetScriptingObject(), script);
	}

	// *undocumented*
	CUSTOM internal void Init (string scriptContents, string className, string nameSpace, string assemblyName, bool isEditorScript)
	{
		self->Init(scriptContents.AsUTF8(), className.AsUTF8(), nameSpace.AsUTF8(), assemblyName.AsUTF8(), isEditorScript);
	}

	// *undocumented*
	CUSTOM_PROP internal ScriptableObject editorGraphData { return Scripting::ScriptingWrapperFor(self->GetEditorGraphData()); } { self->SetEditorGraphData(value); }
END

//*undocumented*
ENUM NETVersion
	NET_1_1 = 0,
	NET_2_1 = 1
END

//*undocumented*
CLASS Unsupported
	
	CSRAW private static bool s_FakeNonDeveloperBuild = EditorPrefs.GetBool ("FakeNonDeveloperBuild", false);
	CSRAW internal static bool fakeNonDeveloperBuild
	{
		get { return s_FakeNonDeveloperBuild; }
		set { s_FakeNonDeveloperBuild = value; EditorPrefs.SetBool ("FakeNonDeveloperBuild", value); }
	}
	
	
	// TODO: hack, and still does not solve all problems, remove later
	C++RAW
 Vector3f MakeNice(const Vector3f& eulerAngles);
	CUSTOM internal static Vector3 MakeNiceVector3(Vector3 vector)
	{
		return MakeNice(vector);
	}

	C++RAW
 void CaptureScreenshotImmediate(string filePath, int x, int y, int width, int height);
	
	CUSTOM public static void CaptureScreenshotImmediate(string filePath, int x, int y, int width, int height)
	{
		CaptureScreenshotImmediate(filePath, x, y, width, height);
	}
	
	CUSTOM internal static NETVersion GetNETVersion()
	{
		return GetPlayerSettings().GetAPICompatibilityLevel();
	}

	CUSTOM static string[] GetSubmenusCommands (string menuPath)
	{
		return Scripting::StringVectorToMono(MenuController::ExtractSubmenusCommands(menuPath));
	}

	CUSTOM static Type GetTypeFromFullName (string fullName)
	{
		string cppFullName = fullName;
		string nameSpace;
		string className = cppFullName;
		string::size_type pos = cppFullName.rfind ('.');

		if (pos != string::npos)
		{
			nameSpace.assign (cppFullName.begin (), cppFullName.begin () + pos);
			className.assign (cppFullName.begin () + pos + 1, cppFullName.end ());
		}

		MonoClass* klass = GetMonoManager().GetMonoClass(className.c_str (), nameSpace.c_str ());
		return mono_class_get_object (klass);
	}

	// Extracts a list of all submenus that can be executed
	CUSTOM static string[] GetSubmenus (string menuPath)
	{
		return Scripting::StringVectorToMono(MenuController::ExtractSubmenus(menuPath));
	}

	CUSTOM public static void PrepareObjectContextMenu (Object c, int contextUserData)
	{
		std::vector<Object*> context;
		context.push_back (c);
		PrepareObjectContextPopupMenu (context, contextUserData);
	}

	CSRAW public static bool IsDeveloperBuild ()
	{
		return IsDeveloperBuildInternal() && !s_FakeNonDeveloperBuild;
	}

	CUSTOM private static bool IsDeveloperBuildInternal ()
	{
		return IsDeveloperBuild();
	}

	CUSTOM static bool IsBleedingEdgeBuild()
	{
		return UNITY_ISBLEEDINGEDGE_BUILD;
	}

	CUSTOM static bool IsDestroyScriptableObject(ScriptableObject target)
	{
		return target->IsDestroying();
	}

	CUSTOM static bool IsNativeCodeBuiltInReleaseMode()
	{
		return UNITY_RELEASE;
	}

	CUSTOM static string GetBaseUnityDeveloperFolder()
	{
		return scripting_string_new(GetBaseUnityDeveloperFolder());
	}

	CUSTOM static void StopPlayingImmediately() { GetApplication().SetIsPlaying(false); }

	CUSTOM static void SceneTrackerFlushDirty ()
	{
		GetSceneTracker().FlushDirty();
	}

	CUSTOM static void SetAllowCursorHide (bool allow)
	{
		GetScreenManager().SetAllowCursorHide(allow);
	}

	CUSTOM static void SetAllowCursorLock (bool allow)
	{
		GetScreenManager().SetAllowCursorLock(allow);
	}

	CUSTOM static void SetRenderSettingsUseFogNoDirty (bool fog)
	{
		GetRenderSettings().SetUseFogNoDirty(fog);
	}
	CUSTOM static void SetQualitySettingsShadowDistanceTemporarily (float distance)
	{
		GetQualitySettings().SetShadowDistanceTemporarily(distance);
	}

	CUSTOM static bool StripFatMacho (string path, bool generate_x86_64)
	{
		return StripFatMacho(path, generate_x86_64);
	}

	CUSTOM static void DeleteGameObjectSelection ()
	{
		DeleteGameObjectSelection();
	}

	CUSTOM static void CopyGameObjectsToPasteboard ()
	{
		CopyGameObjectsToPasteboard();
	}

	CUSTOM static void PasteGameObjectsFromPasteboard ()
	{
		PasteGameObjectsFromPasteboard();
	}

	CUSTOM static Object GetSerializedAssetInterfaceSingleton (string className)
	{
		return Scripting::ScriptingWrapperFor(AssetInterface::Get().GetSingletonAsset(className));
	}

	CUSTOM static void DuplicateGameObjectsUsingPasteboard ()
	{
		DuplicateGameObjectsUsingPasteboard();
	}

	CUSTOM static bool CopyComponentToPasteboard (Component component)
	{
		return CopyComponentToPasteboard(component);
	}

	CUSTOM static bool PasteComponentFromPasteboard (GameObject go)
	{
		return PasteComponentFromPasteboard(go);
	}

	CUSTOM static bool PasteComponentValuesFromPasteboard (Component component)
	{
		return PasteComponentValuesFromPasteboard(component);
	}


	CUSTOM static void CopyStateToPasteboard (State state, AnimatorController controller)
	{
		CopyStateToPasteboard(state, controller);
	}

	CUSTOM static void CopyStateMachineToPasteboard (StateMachine stateMachine, AnimatorController controller)
	{
		CopyStateMachineToPasteboard(stateMachine, controller);
	}

	CUSTOM static void PasteToStateMachineFromPasteboard (StateMachine sm, AnimatorController controller)
	{
		PasteToStateMachineFromPasteboard(sm, controller);
	}	

	CUSTOM static bool HasStateMachineDataInPasteboard()
	{
		return HasStateMachineDataInPasteboard();
	}

	CUSTOM static void SmartReset(Object obj)
	{
		SmartResetObject(*obj);
	}

	CUSTOM static bool CheckIPhoneXCodeInstalled ()
	{
		return CheckIPhoneXCodeInstalled();
	}

	CUSTOM static bool CheckIPhoneXCode4Installed ()
	{
		return CheckIPhoneXCode4Installed();
	}

	CUSTOM static void LaunchIPhoneXCode4 ()
	{
		LaunchIPhoneXCode4();
	}

	CUSTOM static void TerminateIPhoneXCode4 ()
	{
		TerminateIPhoneXCode4();
	}

	CUSTOM static string ResolveSymlinks (string path)
	{
		return scripting_string_new(ResolveSymlinks(path));
	}

	CUSTOM static void SetApplicationSettingCompressAssetsOnImport (bool value)
	{
		SetApplicationSettingCompressAssetsOnImport(value);
	}

	CUSTOM static bool GetApplicationSettingCompressAssetsOnImport ()
	{
		return GetApplicationSettingCompressAssetsOnImport();
	}

	CUSTOM static unsigned int GetLocalIdentifierInFile(int instanceID)
	{
		return GetPersistentManager().GetLocalFileID(instanceID);
	}

    CUSTOM static bool IsHiddenFile(string path)
	{		
		return isHiddenFile(path);
	}

	//*undocumented*
	STRUCT ProgressiveMesh

		CSRAW internal IntPtr opaquePtr;

		CSRAW public static void Create(Mesh src, out ProgressiveMesh pm)
		{
			pm.opaquePtr = CreateImpl(src);
		}
		CSRAW public static void Destroy(ref ProgressiveMesh pm)
		{
			DestroyImpl(pm.opaquePtr);
			pm.opaquePtr = IntPtr.Zero;
		}

		CSRAW public static void CreateInitialGeometry(ProgressiveMesh pm, Mesh mesh)
		{
			CreateInitialGeometryImpl(pm.opaquePtr, mesh);
		}
		CSRAW public static void UpdateMesh(ProgressiveMesh pm, int targetTriCount, Mesh mesh)
		{
			UpdateMeshImpl(pm.opaquePtr, targetTriCount, mesh);
		}


		CUSTOM internal static IntPtr CreateImpl(Mesh src)
		{
			int vCount    = src->GetVertexCount();
	        int triCount  = src->CalculateTriangleCount();

			Mesh::TemporaryIndexContainer triangles;
			src->GetTriangles(triangles);

			unsigned* tri = (unsigned*)::malloc(triCount*3*sizeof(unsigned));
			for( unsigned triI = 0 ; triI < 3*triCount ; ++triI )
				tri[triI] = (unsigned)triangles[triI];

			unsigned* triMat = (unsigned*)::malloc(triCount*sizeof(unsigned));
			{
				unsigned curTri = 0;
				for( unsigned smi = 0 ; smi < src->GetSubMeshCount() ; ++smi )
				{
					const GfxPrimitiveType topology = src->GetSubMeshFast(smi).topology;
					const unsigned indexCount =  src->GetSubMeshFast(smi).indexCount;

					Assert (topology == kPrimitiveTriangles || topology == kPrimitiveTriangleStripDeprecated);
					if(topology == kPrimitiveTriangles || topology == kPrimitiveTriangleStripDeprecated)
					{
						const unsigned triCount = topology == kPrimitiveTriangles ? indexCount/3 : indexCount-2;
						for( unsigned i = 0 ; i < triCount ; ++i )
							triMat[curTri++] = smi;
					}
				}
			}

			std::vector<Vector3f> vertices (vCount);
			src->ExtractVertexArray (&vertices[0]);

			#define VATTR_LIST(T, InputT, channel, name, getfn)					\
				std::vector<T> name;											\
				do{ if( src->IsAvailable(channel) ) {							\
					StrideIterator<InputT> begin = src->getfn;					\
					name.resize(3*triCount);									\
					for( unsigned indexI = 0 ; indexI < 3*triCount ; ++indexI )	\
						name[indexI] = (T)begin[triangles[indexI]];				\
				}} while(0)

			VATTR_LIST(Vector3f, Vector3f, kShaderChannelNormal, srcNormal, GetNormalBegin());
			VATTR_LIST(Vector2f, Vector2f, kShaderChannelTexCoord0, srcUV, GetUvBegin(0));
			VATTR_LIST(Vector2f, Vector2f, kShaderChannelTexCoord1, srcUV2, GetUvBegin(1));
			VATTR_LIST(ColorRGBAf, ColorRGBA32, kShaderChannelColor, srcColor, GetColorBegin());

			GeometryToolboxImpl::GeometryToolbox_MeshDesc pmSrcMesh =
			{
				(unsigned)vCount, &(vertices[0].x),
				(unsigned)triCount, tri, triMat,
				srcNormal.size()	? (float*)&srcNormal[0]	: 0,
				srcUV.size() 	? (float*)&srcUV[0]		: 0,
				srcUV2.size()	? (float*)&srcUV2[0]	: 0,
				srcColor.size()	? (float*)&srcColor[0]	: 0
			};
			GeometryToolboxImpl::GeometryToolbox_ProgressiveMesh pm = GeometryToolboxImpl::GeometryToolbox_CreateProgressiveMesh(pmSrcMesh);

			::free(tri);
			::free(triMat);

			return pm.implOpaquePtr;

			#undef VATTR_LIST
		}


		CUSTOM internal static void DestroyImpl(IntPtr pmOpaque)
		{
			if( pmOpaque != 0)
			{
				GeometryToolboxImpl::GeometryToolbox_ProgressiveMesh pm = { (void*)pmOpaque };
				GeometryToolboxImpl::GeometryToolbox_DestroyProgressiveMesh(pm);
			}
		}

		C++RAW
 static void ProgressiveMesh_AssignSubmeshTris(Mesh* target, GeometryToolboxImpl::GeometryToolbox_MeshDesc* desc)
		{
			if(desc->triMaterial == 0)
				return;

			// we assume that submesh count is correct already
			const unsigned submeshCount = target->GetSubMeshCount();
			const unsigned triCount = desc->triCount;

			// triangles are ordered per-submesh
			unsigned sStart = 0;
			for( unsigned si = 0 ; si < submeshCount ; ++si )
			{
				for( unsigned i = sStart ; i < triCount ; ++i )
				{
					if( desc->triMaterial[i] != si )
					{
						target->SetIndices ((const UInt32*)(desc->tri + 3*sStart), 3*(i - sStart), si, kPrimitiveTriangles);
						sStart = i;
						break;
					}
				}
			}
			target->SetIndices ((const UInt32*)(desc->tri + 3*sStart), 3*(triCount - sStart), submeshCount-1, kPrimitiveTriangles);
		}

		CUSTOM internal static void CreateInitialGeometryImpl(IntPtr pmOpaque, Mesh target)
		{
			if (!target->CanAccessFromScript())
			{
				ErrorString("Not allowed to access mesh in CreateInitialGeometry()");
				return;
			}
			GeometryToolboxImpl::GeometryToolbox_ProgressiveMesh pm = { (void*)pmOpaque };

			GeometryToolboxImpl::GeometryToolbox_MeshDesc result = {0,0,0,0,0,0,0,0,0};
			GeometryToolboxImpl::GeometryToolbox_PMGenerateGeometry(pm, &result);

			bool needGenNormals = (result.normal == 0);

			unsigned channel = (1 << kShaderChannelVertex) | (1 << kShaderChannelNormal);
			if( result.uv )		channel |= (1 << kShaderChannelTexCoord0);
			if( result.uv2 )	channel |= (1 << kShaderChannelTexCoord1);

			// for now we expect submesh count to be inited here
			unsigned submeshCount = target->GetSubMeshCount();
			target->Clear(false);

			target->SetSubMeshCount(submeshCount);
			target->ResizeVertices (result.posCount, channel);
			target->SetVertices ((const Vector3f*)result.pos, result.posCount);
			if( result.normal )
				target->SetNormals ((const Vector3f*)result.normal, result.posCount);
			if( result.uv )
				target->SetUv (0, (const Vector2f*)result.uv, result.posCount);
			if( result.uv2 )
				target->SetUv (1, (const Vector2f*)result.uv2, result.posCount);
			ProgressiveMesh_AssignSubmeshTris(target, &result);

			target->SetChannelsDirty (channel, true);

			if(needGenNormals)
			target->RecalculateNormals();
			target->RecalculateBounds ();

			GeometryToolboxImpl::GeometryToolbox_DestroyMeshDesc(&result);
		}

		CUSTOM internal static void UpdateMeshImpl(IntPtr pmOpaque, int targetTriCount, Mesh target)
		{
			if (!target->CanAccessFromScript())
			{
				ErrorString("Not allowed to access mesh in UpdateMesh()");
				return;
			}
			GeometryToolboxImpl::GeometryToolbox_ProgressiveMesh pm = { (void*)pmOpaque };

			GeometryToolboxImpl::GeometryToolbox_MeshDesc result = {0,0,0,0,0,0,0,0,0};
			GeometryToolboxImpl::GeometryToolbox_PMUpdateTriangles(pm, targetTriCount, &result);

			ProgressiveMesh_AssignSubmeshTris(target, &result);

			GeometryToolboxImpl::GeometryToolbox_DestroyMeshDesc(&result);
		}
	END

END


// Progress bar located in the status bar. A non blocking way of showing progress of tasks, e.g. lightmapping.
// Currently can properly show progress only for one task at a time.
CLASS internal AsyncProgressBar

	CUSTOM_PROP static float progress { return GetAsyncProgressBar().GetProgress(); }
	CUSTOM_PROP static string progressInfo { return scripting_string_new(GetAsyncProgressBar().GetProgressInfo()); }
	CUSTOM_PROP static bool isShowing { return GetAsyncProgressBar().IsShowing (); }

	CUSTOM static void Display (string progressInfo, float progress)
	{
		GetAsyncProgressBar().Display (progressInfo, progress);
	}
	CUSTOM static void Clear ()
	{
		GetAsyncProgressBar().Clear ();
	}

END

CLASS internal OSColorPicker
	CUSTOM static void Show(bool showAlpha)
	{
		OSColorPickerShow(showAlpha);
	}
	CUSTOM static void Close()
	{
		OSColorPickerClose();
	}
	CUSTOM_PROP static bool visible { return OSColorPickerIsVisible(); }
	CUSTOM_PROP static Color color { return OSColorPickerGetColor(); } { OSColorPickerSetColor(value); }
END


CLASS internal ScriptReloadProperties : ScriptableObject
	CSRAW
	public bool EditorGUI_IsActuallEditing;
	public int EditorGUI_TextEditor_pos;
	public int EditorGUI_TextEditor_selectPos;
	public int EditorGUI_TextEditor_controlID;
	public bool EditorGUI_TextEditor_hasHorizontalCursorPos;
	public Vector2 EditorGUI_TextEditor_scrollOffset;
	public bool EditorGUI_TextEditor_hasFocus;
	public Vector2 EditorGUI_TextEditor_graphicalCursorPos;
	public string EditorGUI_TextEditor_content;
	public string EditorGUI_Current_Editing_String;

	public int EditorGUI_DelayedTextEditor_pos;
	public int EditorGUI_DelayedTextEditor_selectPos;
	public int EditorGUI_DelayedTextEditor_controlID;
	public bool EditorGUI_DelayedTextEditor_hasHorizontalCursorPos;
	public Vector2 EditorGUI_DelayedTextEditor_scrollOffset;
	public bool EditorGUI_DelayedTextEditor_hasFocus;
	public Vector2 EditorGUI_DelayedTextEditor_graphicalCursorPos;
	public string EditorGUI_DelayedTextEditor_content;
	public string EditorGUI_DelayedControlThatHadFocusValue;

	static ScriptReloadProperties Store ()
	{
		ScriptReloadProperties obj = ScriptableObject.CreateInstance<ScriptReloadProperties>();
		obj.hideFlags = HideFlags.HideAndDontSave;
		obj.ManagedStore();
		return obj;
	}

	static void Load (ScriptReloadProperties properties)
	{
		properties.ManagedLoad();
	}

	private void ManagedStore ()
	{
		EditorGUI_IsActuallEditing = EditorGUI.RecycledTextEditor.s_ActuallyEditing;
		EditorGUI_TextEditor_pos = EditorGUI.s_RecycledEditor.pos;
		EditorGUI_TextEditor_selectPos = EditorGUI.s_RecycledEditor.selectPos;
		EditorGUI_TextEditor_controlID = EditorGUI.s_RecycledEditor.controlID;
		EditorGUI_TextEditor_hasHorizontalCursorPos = EditorGUI.s_RecycledEditor.hasHorizontalCursorPos;
		EditorGUI_TextEditor_scrollOffset = EditorGUI.s_RecycledEditor.scrollOffset;
		EditorGUI_TextEditor_hasFocus = EditorGUI.s_RecycledEditor.m_HasFocus;
		EditorGUI_TextEditor_graphicalCursorPos = EditorGUI.s_RecycledEditor.graphicalCursorPos;
		EditorGUI_TextEditor_content = EditorGUI.s_RecycledEditor.content.text;
		EditorGUI_Current_Editing_String = EditorGUI.s_RecycledCurrentEditingString;

		EditorGUI_DelayedTextEditor_pos = EditorGUI.s_DelayedTextEditor.pos;
		EditorGUI_DelayedTextEditor_selectPos = EditorGUI.s_DelayedTextEditor.selectPos;
		EditorGUI_DelayedTextEditor_controlID = EditorGUI.s_DelayedTextEditor.controlID;
		EditorGUI_DelayedTextEditor_hasHorizontalCursorPos = EditorGUI.s_DelayedTextEditor.hasHorizontalCursorPos;
		EditorGUI_DelayedTextEditor_scrollOffset = EditorGUI.s_DelayedTextEditor.scrollOffset;
		EditorGUI_DelayedTextEditor_hasFocus = EditorGUI.s_DelayedTextEditor.m_HasFocus;
		EditorGUI_DelayedTextEditor_graphicalCursorPos = EditorGUI.s_DelayedTextEditor.graphicalCursorPos;
		EditorGUI_DelayedTextEditor_content = EditorGUI.s_DelayedTextEditor.content.text;
		EditorGUI_DelayedControlThatHadFocusValue = EditorGUI.s_DelayedTextEditor.controlThatHadFocusValue;
	}

	private void ManagedLoad ()
	{
		EditorGUI.RecycledTextEditor.s_ActuallyEditing = EditorGUI_IsActuallEditing;
		EditorGUI.s_RecycledEditor.pos = EditorGUI_TextEditor_pos;
		EditorGUI.s_RecycledEditor.selectPos = EditorGUI_TextEditor_selectPos;
		EditorGUI.s_RecycledEditor.controlID = EditorGUI_TextEditor_controlID;
		EditorGUI.s_RecycledEditor.hasHorizontalCursorPos = EditorGUI_TextEditor_hasHorizontalCursorPos;
		EditorGUI.s_RecycledEditor.scrollOffset = EditorGUI_TextEditor_scrollOffset;
		EditorGUI.s_RecycledEditor.m_HasFocus = EditorGUI_TextEditor_hasFocus;
		EditorGUI.s_RecycledEditor.graphicalCursorPos = EditorGUI_TextEditor_graphicalCursorPos;
		EditorGUI.s_RecycledEditor.content.text = EditorGUI_TextEditor_content;
		EditorGUI.s_RecycledCurrentEditingString = EditorGUI_Current_Editing_String;


		EditorGUI.s_DelayedTextEditor.pos = EditorGUI_DelayedTextEditor_pos;
		EditorGUI.s_DelayedTextEditor.selectPos = EditorGUI_DelayedTextEditor_selectPos;
		EditorGUI.s_DelayedTextEditor.controlID = EditorGUI_DelayedTextEditor_controlID;
		EditorGUI.s_DelayedTextEditor.hasHorizontalCursorPos = EditorGUI_DelayedTextEditor_hasHorizontalCursorPos;
		EditorGUI.s_DelayedTextEditor.scrollOffset = EditorGUI_DelayedTextEditor_scrollOffset;
		EditorGUI.s_DelayedTextEditor.m_HasFocus = EditorGUI_DelayedTextEditor_hasFocus;
		EditorGUI.s_DelayedTextEditor.graphicalCursorPos = EditorGUI_DelayedTextEditor_graphicalCursorPos;
		EditorGUI.s_DelayedTextEditor.content.text = EditorGUI_DelayedTextEditor_content;
		EditorGUI.s_DelayedTextEditor.controlThatHadFocusValue = EditorGUI_DelayedControlThatHadFocusValue;
	}
END

// Adds Analytics instrumentation to the code.
CLASS internal Analytics

	// PageView tracking. /page/ can be any path that is meaningful in the context
	CUSTOM static void Track (string page)
	{
		AnalyticsTrackPageView(page);
	}

	// Event tracking. /category/, /action/ and /label/ is the event type and /value/ is an attached value
	CUSTOM static void Event (string category, string action, string label, int value)
	{
		AnalyticsTrackEvent(category, action, label, value);
	}

END

CSRAW }
