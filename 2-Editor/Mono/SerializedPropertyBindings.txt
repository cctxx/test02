C++RAW

#include "UnityPrefix.h"
#include "Editor/Src/Utility/SerializedProperty.h"
#include "Editor/Src/Utility/SerializedObjectCache.h"
#include "Editor/Src/Utility/ActiveEditorTracker.h"
#include "Editor/Src/Prefabs/PropertyModification.h"
#include "Runtime/Math/Gradient.h"
#include "Runtime/Math/Vector2.h"
#include "Runtime/Geometry/AABB.h"
#include "Runtime/Scripting/ScriptingExportUtility.h"
#include "Runtime/Scripting/Backend/ScriptingBackendApi.h"
#include "Runtime/Scripting/Scripting.h"
#include "Runtime/Scripting/ScriptingObjectWithIntPtrField.h"
#include "Editor/Mono/MonoPropertyModification.h"

using namespace std;

inline SerializedProperty* GetPropertyVerify (MonoObject* self)
{
	SerializedProperty* property = ExtractMonoObjectData<SerializedProperty*>(self);
	MonoObject* monoSerializedObject = ExtractMonoObjectData<pair<SerializedProperty*, MonoObject*> > (self).second;
	if (property == NULL || monoSerializedObject == NULL || ExtractMonoObjectData<SerializedObject*> (monoSerializedObject) == NULL)
		Scripting::RaiseNullException("SerializedObject of SerializedProperty has been Disposed.");
		
	property->SyncSerializedObjectVersion();
	return property;
}


CSRAW
using System;
using UnityEngine;
using Object=UnityEngine.Object;
using System.Runtime.InteropServices;


namespace UnityEditor
{

// This MUST be kept synchronized with the enum in SerializedProperty.h
// Type of a [[SerializedProperty]].
ENUM SerializedPropertyType
	//*undocumented
	Generic = -1,
	// Integer property.
	Integer = 0,
	// Boolean property.
	Boolean = 1,
	// Float property.
	Float = 2,
	// String property.
	String = 3,
	// Color property.
	Color = 4,
	// Reference to another object.
	ObjectReference = 5,
	// [[LayerMask]] property.
	LayerMask = 6,
	// Enumeration property.
	Enum = 7,
	// 2D vector property.
	Vector2 = 8,
	// 3D vector property.
	Vector3 = 9,
	// Rectangle property.
	Rect = 10,
	// Array size property.
	ArraySize = 11,
	// Character property.
	Character = 12,
	// AnimationCurve property.
	AnimationCurve = 13,
	
	// Bounds property.
	Bounds = 14,
	
	// Gradient property.
	Gradient = 15,

	// Quaternion property.
	Quaternion = 16
END

// SerializedObject and [[SerializedProperty]] are classes for editing properties on objects in a completely generic way that automatically handles undo and styling UI for prefabs.
CLASS SerializedObject
	CSRAW 
	IntPtr m_Property;
	C++RAW
 #define GET ExtractMonoObjectData<SerializedObject*>(self)

	CUSTOM private void InternalCreate (Object[] monoObjs)
	{
		GET = new SerializedObject ();
		vector<Object*> objs;
		MonoObjectArrayToVector(monoObjs, objs);
		
		for (int i=0;i<objs.size();i++)
		{
			Scripting::RaiseIfNull(objs[i]);
		}
		
		GET->Init(objs);		
	}

	// Create SerializedObject for inspected object.
	CSRAW public SerializedObject (Object obj)
	{
		InternalCreate (new Object[] {obj});
	}

	// Create SerializedObject for inspected object.
	CSRAW public SerializedObject (Object[] objs)
	{
		InternalCreate (objs);
	}

	// Update serialized object's representation.
	CUSTOM void Update ()
	{
		GET->Update();
	}

	// Update /hasMultipleDifferentValues/ cache on the next /Update()/ call.
	CUSTOM void SetIsDifferentCacheDirty ()
	{
		GET->SetIsDifferentCacheDirty();
	}

	// Update serialized object's representation, only if the object has been modified since the last call to Update or if it is a script.
	CUSTOM void UpdateIfDirtyOrScript ()
	{
		GET->UpdateIfDirtyOrScript();
	}

	//*undocumented
	THREAD_SAFE
	CUSTOM public void Dispose ()
	{
		delete GET;
		GET = NULL;
	}
	CSRAW ~SerializedObject () { Dispose (); }

	// The inspected object (RO).
	CUSTOM_PROP Object targetObject { return Scripting::ScriptingWrapperFor(GET->GetTargetObject()); }

	// The inspected objects (RO).
	CUSTOM_PROP Object[] targetObjects { return CreateScriptingArrayFromUnityObjects(GET->GetTargetObjects(), ClassID(Object)); }

	// Get the first serialized property.
	CSRAW public SerializedProperty GetIterator ()
	{
		SerializedProperty i = GetIterator_Internal ();
		// This is so the garbage collector won't clean up SerializedObject behind the scenes,
		// when we are still iterating properties
		i.m_SerializedObject = this;
		return i;
	}

	// Find serialized property by name.
	CSRAW public SerializedProperty FindProperty (string propertyPath)
	{
		SerializedProperty i = GetIterator_Internal ();
		// This is so the garbage collector won't clean up SerializedObject behind the scenes,
		// when we are still iterating properties
		i.m_SerializedObject = this;
		if (i.FindPropertyInternal(propertyPath))
			return i;
		else
			return null;
	}
	
	CUSTOM private SerializedProperty GetIterator_Internal ()
	{
		MonoObject* obj = mono_object_new(mono_domain_get (), GetMonoManager().GetBuiltinEditorMonoClass ("SerializedProperty"));
		ExtractMonoObjectData<SerializedProperty*> (obj) = new SerializedProperty();
		GET->GetIterator (*ExtractMonoObjectData<SerializedProperty*> (obj));
		return obj;
	}
	
	CUSTOM internal void Cache (int instanceID) 
	{ 
		SerializedObjectCache::SaveToCache (GET, instanceID); 
		GET = NULL;
	}
	
	CUSTOM internal static SerializedObject LoadFromCache (int instanceID) 
	{
		SerializedObject *so = SerializedObjectCache::LoadFromCache(instanceID);
		if (so)
		{
			MonoObject* obj = mono_object_new(mono_domain_get (), GetMonoManager().GetBuiltinEditorMonoClass ("SerializedObject"));
			ExtractMonoObjectData<SerializedObject*> (obj) = so;
			return obj;
		}
		else
			return NULL;
	}
	
	CUSTOM private PropertyModification ExtractPropertyModification (string propertyPath)
	{
		PropertyModification modification;
		modification.propertyPath = propertyPath.AsUTF8();
		if (!GET->ExtractPropertyModification(modification))
			return NULL;

		MonoObject* obj = mono_object_new(mono_domain_get (), MONO_COMMON.propertyModification);
		PropertyModificationToMono (modification, obj);
		return obj;
	}
	
	// Apply property modifications.
	CUSTOM public bool ApplyModifiedProperties ()
	{
		return GET->ApplyModifiedProperties();
	}

	CUSTOM internal bool ApplyModifiedPropertiesWithoutUndo ()
	{
		return GET->ApplyModifiedPropertiesWithoutUndo();
	}
	
	// Copies a value from a SerializedProperty to the same serialized property on this serialized object.
	CUSTOM void CopyFromSerializedProperty (SerializedProperty prop)
	{
		GET->CopyFromSerializedProperty(*GetPropertyVerify(prop));
	}
	
	CUSTOM_PROP internal bool hasModifiedProperties { return GET->HasModifiedProperties(); }	
	CUSTOM_PROP internal InspectorMode inspectorMode { return GET->GetInspectorMode(); } { GET->SetInspectorMode(value); }
	
	// Does the serialized object represents multiple objects due to multi-object editing? (RO)
	CUSTOM_PROP bool isEditingMultipleObjects { return GET->IsEditingMultipleObjects(); }
	
	C++RAW
 #undef GET
END

// SerializedProperty and [[SerializedObject]] are classes for editing properties on objects in a completely generic way that automatically handles undo and styling UI for prefabs.
CSRAW [StructLayout (LayoutKind.Sequential)]
CLASS SerializedProperty

	CSRAW
	IntPtr m_Property;
	// This is so the garbage collector won't clean up SerializedObject behind the scenes.
	internal SerializedObject m_SerializedObject; 
	
	internal SerializedProperty () {}
	~SerializedProperty () { Dispose (); }
	
	C++RAW
 
	#define GET GetPropertyVerify(self)
	#define GET_NO_CHECK ExtractMonoObjectData<SerializedProperty*>(self)
	
	THREAD_SAFE
	CUSTOM public void Dispose ()
	{
		delete GET_NO_CHECK;
		GET_NO_CHECK = NULL;
	}
	
	// See if contained serialized properties are equal.
	CUSTOM public static bool EqualContents (SerializedProperty x, SerializedProperty y)
	{
		if (x == NULL) 
			return (y == NULL || ExtractMonoObjectData<SerializedProperty*>(y) == NULL);
		if (y == NULL) 
			return (x == NULL || ExtractMonoObjectData<SerializedProperty*>(x) == NULL);
		return *GetPropertyVerify(x) == *GetPropertyVerify(y);
	}
	
	// [[SerializedObject]] this property belongs to (RO).
	CSRAW public SerializedObject serializedObject { get { return m_SerializedObject; } }
	
	// Does this property represent multiple different values due to multi-object editing? (RO)
	CUSTOM_PROP bool hasMultipleDifferentValues { return (GET->HasMultipleDifferentValues() != 0); }

	CUSTOM_PROP internal int hasMultipleDifferentValuesBitwise { return GET->HasMultipleDifferentValues(); }

	CUSTOM internal void SetBitAtIndexForAllTargetsImmediate (int index, bool value)  { return GET->SetBitAtIndexForAllTargetsImmediate(index, value); }

	// Nice display name of the property (RO)
	CUSTOM_PROP internal string displayName { return scripting_string_new(GET->GetMangledName()); }
	// Name of the property (RO)
	CUSTOM_PROP string name { return scripting_string_new(GET->GetTypeTree().m_Name.c_str()); }
	// Type name of the property (RO)
	CUSTOM_PROP string type { return scripting_string_new(GET->GetTypeTree().m_Type.c_str()); }
	// Tooltip of the property (RO)
	CUSTOM_PROP string tooltip { return scripting_string_new(GET->GetTooltip()); }
	// Nesting depth of the property (RO)
	CUSTOM_PROP int depth { return GET->GetDepth(); }
	// Full path of the property (RO)
	CUSTOM_PROP string propertyPath { return scripting_string_new(GET->GetPropertyPath()); }
	
	CUSTOM_PROP internal string arrayIndexLessPropertyPath
	{
		string path;
		GET->GetArrayIndexLessPropertyPath (path);
		return scripting_string_new(path);
	}
	

	// Is this property editable? (RO)
	CUSTOM_PROP bool editable { return GET->GetEditable(); }
	// Is this property editable? (RO)
	CUSTOM_PROP bool isAnimated { return GET->IsAnimated(); }
	// Is this property expanded in the inspector?
	CUSTOM_PROP bool isExpanded { return GET->GetIsExpanded(); } { return GET->SetIsExpanded(value); }
	// Does it have child properties? (RO)
	CUSTOM_PROP bool hasChildren { return GET->HasChildren(); }
	// Does it have visible child properties? (RO)
	CUSTOM_PROP bool hasVisibleChildren { return GET->HasVisibleChildren(); }
	// Is property part of a prefab instance? (RO)
	CUSTOM_PROP bool isInstantiatedPrefab { return GET->GetIsInstantiatedPrefab(); }
	// Is property's value different from the prefab it belongs to?
	CUSTOM_PROP bool prefabOverride { return GET->GetPrefabOverride(); } { GET->SetPrefabOverride(value); }
	
	
	// Type of this property (RO).
	CUSTOM_PROP SerializedPropertyType propertyType { return GET->GetSerializedPropertyType(); }
	
	// Value of an integer property.
	CUSTOM_PROP int intValue { return GET->GetIntValue(); } { GET->SetIntValue(value); }
	// Value of a boolean property.
	CUSTOM_PROP bool boolValue { return GET->GetBoolValue(); } { GET->SetBoolValue(value); }
	// Value of a float property.
	CUSTOM_PROP float floatValue { return GET->GetFloatValue(); } { GET->SetFloatValue(value); }
	// Value of a string property.
	CUSTOM_PROP string stringValue { return scripting_string_new(GET->GetStringValue()); }  { GET->SetStringValue(value); }
	// Value of a color property.
	CUSTOM_PROP Color colorValue { return GET->GetColorValue(); }  { GET->SetColorValue(value); }	
	// Value of a animation curve property.
	CUSTOM_PROP AnimationCurve animationCurveValue
	{
		AnimationCurve* curve = GET->GetAnimationCurveValueCopy();
		if (curve == NULL)
			return NULL;

		MonoObject* obj = scripting_object_new(MONO_COMMON.animationCurve);
		ScriptingObjectWithIntPtrField<AnimationCurve>(obj).SetPtr(curve);
		return obj;
	}
	{
		AnimationCurve* curve = NULL;
		curve = value.GetPtr();

		GET->SetAnimationCurveValue(curve);
	}
	
	// Value of a gradient property.
	CUSTOM_PROP internal Gradient gradientValue
	{
		GradientNEW* gradient = GET->GetGradientValueCopy();

		if (gradient == NULL)
			return NULL;

		ScriptingObject* obj = scripting_object_new(MONO_COMMON.gradient);
		ScriptingObjectWithIntPtrField<GradientNEW>(obj).SetPtr(gradient);
		return obj;
	}
	{
		GET->SetGradientValue(ScriptingObjectWithIntPtrField<GradientNEW>(value).GetPtr());
	}
	
	// Value of an object reference property.
	CUSTOM_PROP Object objectReferenceValue { return Scripting::ScriptingWrapperFor(GET->GetPPtrValue()); } { GET->SetPPtrValue(value); }
	CUSTOM_PROP int objectReferenceInstanceIDValue { return GET->GetPPtrValue().GetInstanceID(); } { GET->SetPPtrValue(PPtr<Object> (value)); }

	CUSTOM_PROP internal string objectReferenceStringValue { return scripting_string_new(GET->GetPPtrStringValue()); }
	CUSTOM internal bool ValidateObjectReferenceValue (Object obj) { return GET->ValidatePPtrValue(obj); }
	CUSTOM_PROP internal string objectReferenceTypeString { return scripting_string_new(GET->GetPPtrClassName()); }

	CUSTOM internal void AppendFoldoutPPtrValue (Object obj) { GET->AppendFoldoutPPtrValue(obj); }
	CUSTOM_PROP internal string layerMaskStringValue { return scripting_string_new(GET->GetLayerMaskStringValue()); }
	
	// Enum index of an enum property.
	CUSTOM_PROP int enumValueIndex { return GET->GetEnumValueIndex(); } { return GET->SetEnumValueIndex(value); }
	// Names of enumeration of an enum property.
	CUSTOM_PROP string[] enumNames { return Scripting::StringVectorToMono (GET->GetEnumNames()); }
	
	// Value of a 2D vector property.
	CUSTOM_PROP Vector2 vector2Value { return GET->GetValue<Vector2f>(); }  { GET->SetValue (value); }
	// Value of a 3D vector property.
	CUSTOM_PROP Vector3 vector3Value { return GET->GetValue<Vector3f>(); }  { GET->SetValue (value); }
	// Value of a quaternion property.
	CUSTOM_PROP Quaternion quaternionValue { return GET->GetValue<Quaternionf>(); }  { GET->SetValue(value); }
	// Value of a rectangle property.
	CUSTOM_PROP Rect rectValue { return GET->GetValue<Rectf>(); }  { GET->SetValue (value); }
	// Value of bounds property.
	CUSTOM_PROP Bounds boundsValue { return GET->GetValue<AABB>(); }  { GET->SetValue(value); }
	
	
	// Move to next property.
	CUSTOM bool Next (bool enterChildren) { return GET->Next(enterChildren); }
	// Move to next visible property.
	CUSTOM bool NextVisible (bool enterChildren) { return GET->NextVisible(enterChildren); }
	// Move to first property of the object.
	CUSTOM void Reset ()
	{
		if (GET_NO_CHECK)
			GET_NO_CHECK->GetSerializedObject()->GetIterator(*GET);
	}
	
	// Count remaining visible properties.
	CUSTOM int CountRemaining () { return GET->CountRemaining(); }
	
	// Count visible children of this property, including this property itself.
	CUSTOM int CountInProperty () { return GET->CountInProperty(); }
	
	// Returns a copy of the SerializedProperty iterator in its current state. This is useful if you want to keep a reference to the current property but continue with the iteration.
	CSRAW public SerializedProperty Copy ()
	{
		SerializedProperty property = CopyInternal ();
		property.m_SerializedObject = m_SerializedObject;
		return property;
	}
	
	CUSTOM private SerializedProperty CopyInternal ()
	{
		MonoObject* obj = mono_object_new(mono_domain_get (), GetMonoManager().GetBuiltinEditorMonoClass ("SerializedProperty"));
		ExtractMonoObjectData<SerializedProperty*> (obj) = new SerializedProperty();
		*ExtractMonoObjectData<SerializedProperty*> (obj) = *GET;
		return obj;
	}
	
	// Duplicates the serialized property.
	CUSTOM public bool DuplicateCommand () { return GET->DuplicateCommand(); }
	// Deletes the serialized property.
	CUSTOM public bool DeleteCommand () { return GET->DeleteCommand(); }



	// Retrieves the SerializedProperty at a relative path to the current property.
	CSRAW public SerializedProperty FindPropertyRelative (string relativePropertyPath)
	{
		SerializedProperty prop = Copy ();
		if (prop.FindPropertyRelativeInternal (relativePropertyPath))
			return prop;
		else
			return null;
	}
	
	
	// Retrieves the SerializedProperty that defines the end range of this property.
	CSRAW public SerializedProperty GetEndProperty (bool includeInvisible = false)
	{
		SerializedProperty prop = Copy ();
		if (includeInvisible)
			prop.Next (false);
		else
			prop.NextVisible (false);
		return prop;
	}
	
	// Retrieves an iterator that allows you to iterator over the current nexting of a serialized property.
	CSRAW public System.Collections.IEnumerator GetEnumerator()
	{
		if (isArray)
		{
			for (int i = 0; i < arraySize; i++)
			{
				yield return GetArrayElementAtIndex (i);
			}
		}
		else
		{
			var end = GetEndProperty();
			while (NextVisible (true) && !SerializedProperty.EqualContents(this, end))
			{
				yield return this;
			}
		}
	}

	CUSTOM internal bool FindPropertyInternal (string propertyPath) { return GET->FindProperty(propertyPath); }
	CUSTOM internal bool FindPropertyRelativeInternal (string propertyPath) { return GET->FindRelativeProperty(propertyPath); }

	CUSTOM internal int[] GetLayerMaskSelectedIndex ()
	{
		vector<int> selected = GET->GetLayerMaskSelectedIndex();
		return CreateScriptingArray(&selected[0], selected.size(), MONO_COMMON.int_32);
	}
	CUSTOM internal string[] GetLayerMaskNames () { return Scripting::StringVectorToMono(GET->GetLayerMaskNames()); }
	CUSTOM internal void ToggleLayerMaskAtIndex (int index)  { return GET->ToggleLayerMaskAtIndex(index); }
	
	// Is this property an array? (RO)
	CUSTOM_PROP bool isArray { return GET->IsArray(); }
	
	// The number of elements in the array.
	CUSTOM_PROP int arraySize { return GET->GetArraySize(); } { return GET->ResizeArray(value); }
	
	// Returns the element at the specified index in the array.
	CSRAW public SerializedProperty GetArrayElementAtIndex (int index)
	{
		SerializedProperty prop = Copy ();
		if (prop.GetArrayElementAtIndexInternal (index))
			return prop;
		else
			return null;
	}
	
	CUSTOM private bool GetArrayElementAtIndexInternal (int index) { return  GET->GetArrayElementAtIndex(index); }
	
	// Insert an empty element at the specified index in the array.
	// @TODO: What is the value of the element when it hasn't been set yet?
	// SA: ::ref::isArray
	CUSTOM void InsertArrayElementAtIndex (int index) { return GET->InsertArrayElementAtIndex(index); }
	// Delete the element at the specified index in the array.
	CUSTOM void DeleteArrayElementAtIndex (int index) { return GET->DeleteArrayElementAtIndex(index); }
	// Remove all elements from the array.
	CUSTOM void ClearArray () { return GET->ResizeArray (0); }
	
	// Move an array element from srcIndex to dstIndex.
	CUSTOM bool MoveArrayElement (int srcIndex, int dstIndex) { return GET->MoveArrayElement (srcIndex, dstIndex); }


	C++RAW
 #undef GET
	
	CSRAW internal void SetToValueOfTarget (Object target)
	{
		SerializedProperty targetProperty = new SerializedObject (target).FindProperty (propertyPath);
		if (targetProperty == null)
		{
			Debug.LogError (target.name+" does not have the property "+propertyPath);
			return;
		}
		switch (propertyType)
		{
			case SerializedPropertyType.Integer: intValue = targetProperty.intValue; break;
			case SerializedPropertyType.Boolean: boolValue = targetProperty.boolValue; break;
			case SerializedPropertyType.Float: floatValue = targetProperty.floatValue; break;
			case SerializedPropertyType.String: stringValue = targetProperty.stringValue; break;
			case SerializedPropertyType.Color: colorValue = targetProperty.colorValue; break;
			case SerializedPropertyType.ObjectReference: objectReferenceValue = targetProperty.objectReferenceValue; break;
			case SerializedPropertyType.LayerMask: intValue = targetProperty.intValue; break;
			case SerializedPropertyType.Enum: enumValueIndex = targetProperty.enumValueIndex; break;
			case SerializedPropertyType.Vector2: vector2Value = targetProperty.vector2Value; break;
			case SerializedPropertyType.Vector3: vector3Value = targetProperty.vector3Value; break;
			case SerializedPropertyType.Rect: rectValue = targetProperty.rectValue; break;
			case SerializedPropertyType.ArraySize: intValue = targetProperty.intValue; break;
			case SerializedPropertyType.Character: intValue = targetProperty.intValue; break;
			case SerializedPropertyType.AnimationCurve: animationCurveValue = targetProperty.animationCurveValue; break;
			case SerializedPropertyType.Bounds: boundsValue = targetProperty.boundsValue; break;
			case SerializedPropertyType.Gradient: gradientValue = targetProperty.gradientValue; break;
		}
	}
END

CSRAW }
