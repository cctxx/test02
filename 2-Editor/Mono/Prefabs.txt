C++RAW

#include "UnityPrefix.h"
#include "Runtime/Scripting/ScriptingUtility.h"
#include "Runtime/Mono/MonoBehaviour.h"
#include "Editor/Src/Prefabs/Prefab.h"
#include "Editor/Src/Prefabs/AttachedPrefabAsset.h"
#include "Runtime/Scripting/Scripting.h"
#include "Editor/Mono/MonoPropertyModification.h"


using namespace std;

CSRAW
using System;
using UnityEngine;
using Object=UnityEngine.Object;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Collections;
using Boo.Lang;

namespace UnityEditor
{

// Flags for the PrefabUtility.ReplacePrefab function.
ENUM ReplacePrefabOptions
	// Replaces prefabs by matching pre-existing connections to the prefab.
	Default = 0,

	// Connects the passed objects to the prefab after uploading the prefab.
	ConnectToPrefab = 1,

	// Replaces the prefab using name based lookup in the transform hierarchy.
	ReplaceNameBased = 2,
END

// The type of a prefab object as returned by EditorUtility.GetPrefabType.
ENUM PrefabType
	// The object is not a prefab nor an instance of a prefab.
	None = 0,
	// The object is a user created prefab asset.
	Prefab = 1,
	// The object is an imported 3D model asset.
	ModelPrefab = 2,
	// The object is an instance of a user created prefab.
	PrefabInstance = 3,
	// The object is an instance of an imported 3D model.
	ModelPrefabInstance = 4,
	// The object was an instance of a prefab, but the original prefab could not be found.
	MissingPrefabInstance = 5,
	// The object is an instance of a user created prefab, but the connection is broken.
	DisconnectedPrefabInstance = 6,
	// The object is an instance of an imported 3D model, but the connection is broken.
	DisconnectedModelPrefabInstance = 7
END

// Defines a single modified property.
CSRAW [StructLayout (LayoutKind.Sequential)]
CLASS PropertyModification
	// Object that will be modified
	CSRAW public Object target;
	// Property path of the property being modified (Matches as SerializedProperty.propertyPath)
	CSRAW public string propertyPath;
	// The value being applied
	CSRAW public string value;
	// The value being applied when it is a object reference (which can not be represented as a string)
	CSRAW public Object objectReference;
END

// Utility class for any prefab related operations.
CLASS PrefabUtility
	
	// Returns the GameObject parent of /source/, or null if it can't be found.
	CUSTOM static Object GetPrefabParent (Object source)
	{
		return Scripting::ScriptingWrapperFor(GetPrefabParentObject(source));
	}

	// Retrieves the prefab object representation.
	CUSTOM static Object GetPrefabObject (Object targetObject)
	{
		return Scripting::ScriptingWrapperFor(GetPrefabFromAnyObjectInPrefab(targetObject));
	}
	
	// Extract all modifications that are applied to the prefab instance compared to the parent prefab.
	CUSTOM static PropertyModification[] GetPropertyModifications (Object targetPrefab)
	{
		Prefab* prefab = GetPrefabFromAnyObjectInPrefab(targetPrefab);
		if (prefab == NULL)
			return NULL;
		return VectorToMonoClassArray(prefab->GetPropertyModifications(), MONO_COMMON.propertyModification, PropertyModificationToMono);
	}
	
	// Assigns all modifications that are applied to the prefab instance compared to the parent prefab.
	CUSTOM static void SetPropertyModifications (Object targetPrefab, PropertyModification[] modifications)
	{
		Prefab* prefab = GetPrefabFromAnyObjectInPrefab(targetPrefab);
		if (prefab == NULL)
			return;
			
		PropertyModifications cmodifications;
		MonoClassArrayToVector(modifications, cmodifications, MonoToPropertyModification);
		SetPropertyModifications(*prefab, cmodifications);
	}

	// Instantiate an asset that is referenced by a prefab and use it on the prefab instance.
	CUSTOM static Object InstantiateAttachedAsset(Object targetObject)
	{
		return Scripting::ScriptingWrapperFor(InstantiateAttachedAsset(*targetObject));
	}

	
	// Force record property modifications by comparing against the parent prefab.
	CUSTOM static void RecordPrefabInstancePropertyModifications(Object targetObject)
	{
		RecordPrefabInstancePropertyModifications(*targetObject);
	}

	// Force re-merging all prefab instances of this prefab.
	CUSTOM static void MergeAllPrefabInstances(Object targetObject)
	{
		Prefab* prefab = GetPrefabFromAnyObjectInPrefab(targetObject);
		Scripting::RaiseIfNull(prefab);
		MergeAllPrefabInstances(prefab);
	}

	//unsupported
	CUSTOM private static bool IsPrefabExploded(Object targetObject)
	{
		Prefab* prefab = GetPrefabFromAnyObjectInPrefab(targetObject);
		Scripting::RaiseIfNull(prefab);
		return prefab->m_IsExploded;
	}

	//unsupported
	CUSTOM private static void SetIsPrefabExploded(Object targetObject, bool exploded)
	{
		Prefab* prefab = GetPrefabFromAnyObjectInPrefab(targetObject);
		Scripting::RaiseIfNull(prefab);
		SetIsPrefabExploded(*prefab, exploded);
	}
	
	// Disconnects the prefab instance from its parent prefab.
	CUSTOM static void DisconnectPrefabInstance (Object targetObject)
	{
		DisconnectPrefabInstance(targetObject);
	}
	
	
	// Instantiates the given prefab.
	CUSTOM static Object InstantiatePrefab (Object target)
	{
		return Scripting::ScriptingWrapperFor(InstantiatePrefab(target));
	}

	// Creates an empty prefab at given path.
	CUSTOM static Object CreateEmptyPrefab (string path)
	{
		return Scripting::ScriptingWrapperFor(CreateEmptyPrefab(path));
	}
	
	// Creates a prefab from a game object hierarchy
	CUSTOM static GameObject CreatePrefab (string path, GameObject go, ReplacePrefabOptions options = ReplacePrefabOptions.Default)
	{
		return Scripting::ScriptingWrapperFor(CreatePrefab(path, *go, options));
	}

	// Replaces the /targetPrefab/ with a copy of the game object hierarchy /go/.
	CUSTOM static GameObject ReplacePrefab (GameObject go, Object targetPrefab, ReplacePrefabOptions options = ReplacePrefabOptions.Default)
	{
		return Scripting::ScriptingWrapperFor(ReplacePrefab(*go, targetPrefab, options));
	}

	// Returns the topmost game object that has the same prefab parent as /target/
	CUSTOM static GameObject FindRootGameObjectWithSameParentPrefab (GameObject target)
	{
		return Scripting::ScriptingWrapperFor(&FindRootGameObjectWithSameParentPrefab(*target));
	}

	// Returns root game object of the prefab instance if that root prefab instance is a parent of the prefab.
	CUSTOM static GameObject FindValidUploadPrefabInstanceRoot (GameObject target)
	{
		return Scripting::ScriptingWrapperFor(FindValidUploadPrefabRoot(*target));
	}

	// Connects the game object to the prefab that it was last connected to.
	CUSTOM static bool ReconnectToLastPrefab (GameObject go)
	{
		return ReconnectToLastPrefab(*go);
	}

	// Resets the properties of the component or game object to the parent prefab state
	CUSTOM static bool ResetToPrefabState (Object obj)
	{
		EditorExtension* target = dynamic_pptr_cast<EditorExtension*> (&*obj);
		if (target)
			return SmartResetToInstantiatedPrefabState(*target);
		else
			return false;
	}
	
	CUSTOM static bool IsComponentAddedToPrefabInstance (Object source)
	{
		return IsComponentAddedToPrefabInstance(source);
	}


	// Resets the properties of all objects in the prefab, including child game objects and components that were added to the prefab instance
	CUSTOM static bool RevertPrefabInstance (GameObject go)
	{
		return RevertPrefabInstance(*go);
	}

	// Given an object, returns its prefab type (None, if it's not a prefab)
	CUSTOM static PrefabType GetPrefabType (Object target)
	{
		return GetPrefabType(*target);
	}

	// Helper function to find the prefab root of an object (used for picking niceness)
	CUSTOM static GameObject FindPrefabRoot (GameObject source)
	{
		return Scripting::ScriptingWrapperFor(FindPrefabRoot (source));
	}
	
END

CSRAW }
