C++RAW

#include "UnityPrefix.h"
#include "Runtime/Math/AnimationCurve.h"
#include "Runtime/Mono/MonoManager.h"
#include "Runtime/Animation/AnimationClip.h"
#include "Runtime/Utilities/InitializeAndCleanup.h"
#include "Runtime/Scripting/ScriptingUtility.h"
#include "Runtime/Mono/MonoBehaviour.h"
#include "Runtime/Mono/MonoScript.h"
#include "Runtime/Mono/MonoExportUtility.h"
#include "Runtime/Animation/AnimationBinder.h"
#include "Runtime/Animation/GenericAnimationBindingCache.h"
#include "Runtime/Animation/Animation.h"
#include "Runtime/Animation/Animator.h"
#include "Runtime/Animation/AnimationClipStats.h"
#include "Runtime/Animation/AnimationUtility.h"
#include "Runtime/Animation/AnimatorController.h"
#include "Editor/Src/Animation/AnimationModeSnapshot.h"
#include "Editor/Src/Animation/PropertyModificationToEditorCurveBinding.h"
#include "Runtime/Graphics/ParticleSystem/PolynomialCurve.h"
#include "Runtime/Graphics/Transform.h"
#include "Runtime/Scripting/ScriptingExportUtility.h"
#include "Runtime/Scripting/Backend/ScriptingTypeRegistry.h"
#include "Runtime/Scripting/Backend/ScriptingBackendApi.h"
#include "Runtime/Scripting/ScriptingObjectWithIntPtrField.h"
#include "Runtime/Mono/MonoExportUtility.h"
#include "Editor/Mono/MonoPropertyModification.h"

using namespace std;

C++RAW

struct MonoEditorCurveBinding
{
	MonoString* path;
	MonoObject* type;
	MonoString* propertyName;
	int         isPPtrCurve;
	int         classID;
	int         monoScriptInstanceID;
};

struct MonoPPtrKeyframe
{
	float              time;
	ScriptingObjectPtr value;
};

static void MonoToPPtrKeyframe (const MonoPPtrKeyframe& src, PPtrKeyframe& dst)
{
	dst.time = src.time;
	dst.value = ScriptingObjectToObject<Object>(src.value);
}

static void MonoFromPPtrKeyframe (const PPtrKeyframe& src, MonoPPtrKeyframe& dst)
{
	dst.time = src.time;
	dst.value = Scripting::ScriptingWrapperFor(src.value);
}

MonoObject* GetTypeFromClassID (int classID, PPtr<MonoScript> script)
{
	MonoClass* klass = NULL;
	if (classID == ClassID (MonoBehaviour) && script.IsValid())
		klass = script->GetClass();
	if (klass == NULL && Object::ClassIDToRTTI(classID))
		klass = GetMonoManager().ClassIDToScriptingClass(classID);
	if (klass == NULL)
		klass = ScriptingClassFor(Object);
	return mono_class_get_object(klass);
}


bool MonoToEditorCurveBinding (const MonoEditorCurveBinding& src, EditorCurveBinding& dst)
{
	dst.path = scripting_cpp_string_for (src.path);
	dst.attribute = scripting_cpp_string_for (src.propertyName);
	dst.isPPtrCurve = src.isPPtrCurve;
	dst.classID = src.classID;
	dst.script = PPtr<MonoScript> (src.monoScriptInstanceID);

	// Only generate classID/script from type when the the managed type is the only data available
	// (Script might not be loadable or type might not exist in C#)
	if (dst.classID == 0)
	{
		Scripting::RaiseIfNull(src.type);
		MonoClass* klass = GetScriptingTypeRegistry().GetType(src.type);
		dst.classID = Scripting::GetClassIDFromScriptingClass(klass);
		dst.script = NULL;
		if (dst.classID == ClassID(MonoBehaviour))
		{
			dst.script = GetMonoScriptManager().FindRuntimeScript(klass);
			if (dst.script == NULL)
			{
				Scripting::RaiseMonoException("Invalid type");
				return false;
			}
		}
	}
	
	return true;
}

void EditorCurveBindingToMono (const EditorCurveBinding& src, MonoEditorCurveBinding& dst)
{
	dst.path = scripting_string_new (src.path);
	dst.propertyName = scripting_string_new (src.attribute);
	dst.type = GetTypeFromClassID(src.classID, src.script);
	dst.classID = src.classID;
	dst.monoScriptInstanceID = src.script ? src.script->GetInstanceID() : 0;
	dst.isPPtrCurve = src.isPPtrCurve;
}

C++RAW

struct AnimationEventMono
{
	AnimationEvent* m_Ptr;
	int m_OwnsData;
};

inline AnimationEvent* GetAnimationEvent (MonoObject* self)
{
	AnimationEvent* event = ScriptingObjectWithIntPtrField<AnimationEvent>(self).GetPtr();
	if (event)
		return event;

	Scripting::RaiseNullException("Animation Event is out of scope");
	return NULL;
}

CSRAW
using System;
using UnityEngine;
using Object=UnityEngine.Object;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Collections;

namespace UnityEditor
{

// An AnimationClipCurveData object contains all the information needed to identify a specific curve in an AnimationClip. The curve animates a specific property of a component / material attached to a game object / animated bone.
CSRAW [StructLayout (LayoutKind.Sequential)]
CLASS AnimationClipCurveData

	// The path of the game object / bone being animated.
	CSRAW public string path;
	// The type of the component / material being animated.
	CSRAW public Type   type;
	// The name of the property being animated.
	CSRAW public string propertyName;
	// The actual animation curve.
	CSRAW public AnimationCurve curve;

	// This is only used internally for deleting curves
	CSRAW internal int  classID; 
	CSRAW internal int  scriptInstanceID;

	CSRAW public AnimationClipCurveData ()
	{
	
	}
	
	CSRAW public AnimationClipCurveData (EditorCurveBinding binding)
	{
		path = binding.path;
		type = binding.type;
		propertyName = binding.propertyName;
		curve = null;
		classID = binding.m_ClassID;
		scriptInstanceID = binding.m_ScriptInstanceID;
	}
	
END

STRUCT ObjectReferenceKeyframe
	CSRAW public float              time;
	CSRAW public UnityEngine.Object value;
END


STRUCT EditorCurveBinding
	// The path of the game object / bone being animated.
	CSRAW public string path;

	// The type of the component / material being animated.
	CSRAW private Type   m_type;

	// The name of the property being animated.
	CSRAW public string propertyName;

	// is it a PPtr curve
	CSRAW private int   m_isPPtrCurve;

	// This is only used internally for deleting curves
	CSRAW internal int  m_ClassID; 
	CSRAW internal int  m_ScriptInstanceID;


	CSRAW public bool  isPPtrCurve { get { return m_isPPtrCurve != 0; } }
	
	public static bool operator == (EditorCurveBinding lhs, EditorCurveBinding rhs)
	{
		// Only if classID actually has been setup do we compare it (It might only be type)
		if (lhs.m_ClassID != 0 && rhs.m_ClassID != 0)
		{
			if (lhs.m_ClassID != rhs.m_ClassID || lhs.m_ScriptInstanceID != rhs.m_ScriptInstanceID)
				return false;
		}

		return lhs.path == rhs.path && lhs.type == rhs.type && lhs.propertyName == rhs.propertyName && lhs.m_isPPtrCurve == rhs.m_isPPtrCurve;
	}
	
	public static bool operator != (EditorCurveBinding lhs, EditorCurveBinding rhs)
	{
		return !(lhs == rhs);
	}
	
	public override int GetHashCode()
	{
		return path.GetHashCode() ^ (type.GetHashCode()<<2) ^ (propertyName.GetHashCode()<<4);
	}
		
	public override bool Equals(object other)
	{
		if(!(other is EditorCurveBinding)) return false;
		
		EditorCurveBinding rhs = (EditorCurveBinding)other;
		return this == rhs;
	}
	
	CSRAW public Type type
	{
		get { return m_type; }	
		set { m_type = value; m_ClassID = 0; m_ScriptInstanceID = 0; }
	}



	CSRAW static public EditorCurveBinding FloatCurve (string inPath, System.Type inType, string inPropertyName)
	{
		EditorCurveBinding binding = new EditorCurveBinding();
	
		binding.path = inPath;
		binding.type = inType;
		binding.propertyName = inPropertyName;
		binding.m_isPPtrCurve = 0;
		
		return binding;
		//TODO: We should generate classID & scriptInstanceID here???
	}

	CSRAW static public EditorCurveBinding PPtrCurve (string inPath, System.Type inType, string inPropertyName)
	{
		EditorCurveBinding binding = new EditorCurveBinding();
	
		binding.path = inPath;
		binding.type = inType;
		binding.propertyName = inPropertyName;
		binding.m_isPPtrCurve = 1;
		return binding;
		
		//TODO: We should generate classID & scriptInstanceID here???
	}
END


// Must be kept in sync with AnimationClipStats in AnimationClipStats
STRUCT internal AnimationClipStats
	CSRAW public int size;
	CSRAW public int positionCurves;
	CSRAW public int rotationCurves;
	CSRAW public int scaleCurves;
	CSRAW public int muscleCurves;
	CSRAW public int genericCurves;
	CSRAW public int pptrCurves;
	CSRAW public int totalCurves;
END


///@TODO: Why is this a class? Just make it a struct and stop all the conversion code...
CLASS public AnimationClipSettings
	CSRAW public float startTime;
	CSRAW public float stopTime;
	CSRAW public float orientationOffsetY;
	CSRAW public float level;
	CSRAW public float cycleOffset;
	CSRAW public bool loopTime;
	CSRAW public bool loopBlend;
	CSRAW public bool loopBlendOrientation;
	CSRAW public bool loopBlendPositionY;
	CSRAW public bool loopBlendPositionXZ;
	CSRAW public bool keepOriginalOrientation;
	CSRAW public bool keepOriginalPositionY;
	CSRAW public bool keepOriginalPositionXZ;
	CSRAW public bool heightFromFeet;
	CSRAW public bool mirror;
END

C++RAW

struct MonoAnimationClipSettings
{		
	float  startTime;
	float  stopTime;
	float  orientationOffsetY;
	float  level;
	float  cycleOffset;
	UInt8  loopTime;
	UInt8  loopBlend;
	UInt8  loopBlendOrientation;
	UInt8  loopBlendPositionY;
	UInt8  loopBlendPositionXZ;
	UInt8  keepOriginalOrientation;
	UInt8  keepOriginalPositionY;
	UInt8  keepOriginalPositionXZ;
	UInt8  heightFromFeet;
	UInt8  mirror;
};

void AnimationClipSettingsToMono (const AnimationClipSettings& src, MonoAnimationClipSettings &dest)
{
	dest.startTime = src.m_StartTime;
	dest.stopTime = src.m_StopTime;
	dest.orientationOffsetY = src.m_OrientationOffsetY;
	dest.level = src.m_Level;
	dest.cycleOffset = src.m_CycleOffset;
	dest.loopTime = src.m_LoopTime;
	dest.loopBlend = src.m_LoopBlend;
	dest.loopBlendOrientation = src.m_LoopBlendOrientation;
	dest.loopBlendPositionY = src.m_LoopBlendPositionY;
	dest.loopBlendPositionXZ = src.m_LoopBlendPositionXZ;
	dest.keepOriginalOrientation = src.m_KeepOriginalOrientation;
	dest.keepOriginalPositionY = src.m_KeepOriginalPositionY;
	dest.keepOriginalPositionXZ = src.m_KeepOriginalPositionXZ;
	dest.heightFromFeet = src.m_HeightFromFeet;
	dest.mirror = src.m_Mirror;
}

void AnimationClipSettingsFromMono (const MonoAnimationClipSettings& src, AnimationClipSettings &dest)
{
	dest.m_StartTime = src.startTime;
	dest.m_StopTime = src.stopTime;
	dest.m_OrientationOffsetY = src.orientationOffsetY;
	dest.m_Level = src.level;
	dest.m_CycleOffset = src.cycleOffset;
	dest.m_LoopTime = src.loopTime;
	dest.m_LoopBlend = src.loopBlend;
	dest.m_LoopBlendOrientation = src.loopBlendOrientation;
	dest.m_LoopBlendPositionY = src.loopBlendPositionY;
	dest.m_LoopBlendPositionXZ = src.loopBlendPositionXZ;
	dest.m_KeepOriginalOrientation = src.keepOriginalOrientation;
	dest.m_KeepOriginalPositionY = src.keepOriginalPositionY;
	dest.m_KeepOriginalPositionXZ = src.keepOriginalPositionXZ;
	dest.m_HeightFromFeet = src.heightFromFeet;
	dest.m_Mirror = src.mirror;
}

// Editor utility functions for modifying animation clips
CLASS AnimationUtility

	
	OBSOLETE warning GetAnimationClips(Animation) is deprecated. Use GetAnimationClips(GameObject) instead.
	CSRAW public static AnimationClip[] GetAnimationClips (Animation component)
	{
		return GetAnimationClips(component.gameObject);
	}

	// Returns the array of AnimationClips that are referenced in the Animation component
	CUSTOM static AnimationClip[] GetAnimationClips (GameObject gameObject)
	{
		Animation* animation = gameObject->QueryComponent(Animation);
		Animator* animator = gameObject->QueryComponent(Animator);
		if (animator)
		{
			RuntimeAnimatorController* controller = animator->GetRuntimeAnimatorController();
			if (controller != NULL)
				return CreateScriptingArrayFromUnityObjects(controller->GetAnimationClips(), ClassID(AnimationClip));
		}
		else if (animation)
		{
			return CreateScriptingArrayFromUnityObjects(animation->GetClips(), ClassID(AnimationClip));
		}
		
		return CreateScriptingArrayFromUnityObjects(vector<PPtr<AnimationClip> > (), ClassID(AnimationClip));
	}
	
	// Sets the array of AnimationClips to be referenced in the Animation component
	CUSTOM static void SetAnimationClips (Animation animation, AnimationClip[] clips)
	{
		Animation::Animations animationClips;
		animationClips.resize(mono_array_length_safe(clips));
		for (int i=0;i<animationClips.size();i++)
		{
			int instanceID = Scripting::GetInstanceIDFromScriptingWrapper(GetMonoArrayElement<MonoObject*>(clips, i));
			animationClips[i] = PPtr<AnimationClip> (instanceID);
		}
		
		animation->SetClips(animationClips);
	}
	
	CUSTOM static EditorCurveBinding[] GetAnimatableBindings (GameObject targetObject, GameObject root)
	{
		vector<EditorCurveBinding> curves;
		UnityEngine::Animation::GetGenericAnimationBindingCache().GetAllAnimatableProperties (*targetObject, *root, curves);
		return VectorToScriptingStructArray<EditorCurveBinding, MonoEditorCurveBinding> (curves, GetMonoManager().GetBuiltinEditorMonoClass("EditorCurveBinding"), EditorCurveBindingToMono);
	}

	CUSTOM static bool GetFloatValue (GameObject root, EditorCurveBinding binding, out float data)
	{
		EditorCurveBinding cbinding;
		if (!MonoToEditorCurveBinding(binding, cbinding))
			return false;
	
		return UnityEngine::Animation::GetFloatValue (*root, cbinding, data) != ClassID(Undefined);
	}
	
	// Binds the property and returns the type of the bound value (Can be used to display special UI for it and to enforce correct drag and drop)
	// null if it can't be bound.
	CUSTOM static System.Type GetEditorCurveValueType (GameObject root, EditorCurveBinding binding)
	{
		EditorCurveBinding cbinding;
		if (!MonoToEditorCurveBinding(binding, cbinding))
			return NULL;
	
		int classID = UnityEngine::Animation::GetEditorCurveValueClassID (*root, cbinding);
		return ClassIDToScriptingTypeObjectIncludingBasicTypes(classID);
	}

	CUSTOM static bool GetObjectReferenceValue (GameObject root, EditorCurveBinding binding, out Object targetObject)
	{
		*targetObject = NULL;
		EditorCurveBinding cbinding;
		if (!MonoToEditorCurveBinding(binding, cbinding))
			return false;
			
		int instanceID = 0;	
		bool result = UnityEngine::Animation::GetPPtrValue (*root, cbinding, &instanceID) != ClassID(Undefined);
		*targetObject = Scripting::ScriptingWrapperFor(dynamic_instanceID_cast<Object*> (instanceID));
		
		return result;
	}

	CUSTOM static Object GetAnimatedObject (GameObject gameObject, EditorCurveBinding binding)
	{
		EditorCurveBinding cbinding;
		if (!MonoToEditorCurveBinding(binding, cbinding))
			return NULL;

		return Scripting::ScriptingWrapperFor(UnityEngine::Animation::FindAnimatedObject (*gameObject, cbinding));
	}
	

	CUSTOM static Type PropertyModificationToEditorCurveBinding (PropertyModification modification, GameObject gameObject, out EditorCurveBinding binding)
	{
		PropertyModification cModification;
		MonoToPropertyModification (modification, cModification);
		
		EditorCurveBinding cBinding;
		ClassIDType classID = PropertyModificationToEditorCurveBinding (cModification, *gameObject, cBinding);
		
		EditorCurveBindingToMono(cBinding, *binding);
		
		return ClassIDToScriptingTypeObjectIncludingBasicTypes(classID);
	}

	CUSTOM static EditorCurveBinding[] GetCurveBindings (AnimationClip clip)
	{
		AnimationClip::FloatCurves& editorCurves = clip->GetEditorCurvesSync();
		MonoClass* bindingClass = GetMonoManager().GetBuiltinEditorMonoClass("EditorCurveBinding");
		MonoArray* monoArray = mono_array_new (mono_domain_get (), bindingClass, editorCurves.size());
		for (int i=0;i<editorCurves.size();i++)
		{
			AnimationClip::FloatCurve& curve = editorCurves[i];
			
			EditorCurveBinding binding (curve.path, curve.classID, curve.script, curve.attribute, false);
			EditorCurveBindingToMono (binding, Scripting::GetScriptingArrayElement<MonoEditorCurveBinding> (monoArray, i));
		}
		
		return monoArray;
	}
	
	CUSTOM static EditorCurveBinding[] GetObjectReferenceCurveBindings (AnimationClip clip)
	{
		const AnimationClip::PPtrCurves& pptrCurves = clip->GetEditorPPtrCurves();
		MonoClass* curveClass = GetMonoManager().GetBuiltinEditorMonoClass("EditorCurveBinding");
		MonoArray* monoArray = mono_array_new (mono_domain_get (), curveClass, pptrCurves.size());
		for (int i = 0; i < pptrCurves.size(); i++)
		{
			const AnimationClip::PPtrCurve& curve = pptrCurves[i];
			
			EditorCurveBinding binding (curve.path, curve.classID, curve.script, curve.attribute, true);
			EditorCurveBindingToMono (binding, Scripting::GetScriptingArrayElement<MonoEditorCurveBinding> (monoArray, i));
			Scripting::GetScriptingArrayElement<MonoEditorCurveBinding> (monoArray, i).isPPtrCurve = 1;
		}

		return monoArray;
	}
	
	CUSTOM static ObjectReferenceKeyframe[] GetObjectReferenceCurve (AnimationClip clip, EditorCurveBinding binding)
	{
		EditorCurveBinding cbinding;
		if (!MonoToEditorCurveBinding (binding, cbinding))
			return NULL;

		PPtrKeyframes keyframes;
		if (!clip->GetEditorPPtrCurve(cbinding.path, cbinding.classID, cbinding.script, cbinding.attribute, &keyframes))
			return NULL;

		ScriptingClassPtr keyframeClass = GetMonoManager().GetBuiltinEditorMonoClass("ObjectReferenceKeyframe");
		return DynamicArrayToScriptingStructArray(keyframes, keyframeClass, MonoFromPPtrKeyframe);
	}

	CUSTOM private static void Internal_SetObjectReferenceCurve (AnimationClip clip, EditorCurveBinding binding, ObjectReferenceKeyframe[] keyframes)
	{
		EditorCurveBinding cbinding;
		if (!MonoToEditorCurveBinding (binding, cbinding))
			return;

		PPtrKeyframes* keyframesPtr = NULL;
		PPtrKeyframes cKeyframes;

		// If curve == NULL, it means we want to remove it
		if (keyframes != NULL)
		{
			ScriptingArrayToDynamicArray(keyframes, cKeyframes, MonoToPPtrKeyframe);
			keyframesPtr = &cKeyframes;
		}
		
		clip->SetEditorPPtrCurve(cbinding.path, cbinding.classID, cbinding.script, cbinding.attribute, keyframesPtr);
	}

	CUSTOM static AnimationCurve GetEditorCurve (AnimationClip clip, EditorCurveBinding binding)
	{
		EditorCurveBinding cbinding;
		if (!MonoToEditorCurveBinding (binding, cbinding))
			return NULL;

		AnimationCurve* curve = new AnimationCurve();
		if (clip->GetEditorCurve(cbinding.path, cbinding.classID, cbinding.script, cbinding.attribute, curve))
		{
			MonoObject* obj = scripting_object_new(MONO_COMMON.animationCurve);
			ScriptingObjectWithIntPtrField<AnimationCurve>(obj).SetPtr(curve);
			return obj;
		}
		else
		{
			delete curve;
			return NULL;
		}
	}
	
	CUSTOM private static void Internal_SetEditorCurve (AnimationClip clip, EditorCurveBinding binding, AnimationCurve curve)
	{
		EditorCurveBinding cbinding;
		if (!MonoToEditorCurveBinding (binding, cbinding))
			return;

		clip->SetEditorCurve(cbinding.path, cbinding.classID, cbinding.script, cbinding.attribute, curve.GetPtr());
	}
	
	ENUM CurveModifiedType
		CurveDeleted = 0,
		CurveModified = 1,
		ClipModified = 2
	END
	
	CSRAW public delegate void OnCurveWasModified (AnimationClip clip, EditorCurveBinding binding, CurveModifiedType deleted);
	CSRAW public static OnCurveWasModified onCurveWasModified;
	
	private static void Internal_CallAnimationClipAwake (AnimationClip clip)
	{
		if (onCurveWasModified != null)
			onCurveWasModified (clip, new EditorCurveBinding(), CurveModifiedType.ClipModified);
	}
	
	CSRAW public static void SetEditorCurve (AnimationClip clip, EditorCurveBinding binding, AnimationCurve curve)
	{
		Internal_SetEditorCurve (clip, binding, curve);

		//TODO: We should probably move that to the C++ code
		if (onCurveWasModified != null)
			onCurveWasModified (clip, binding, curve != null ? CurveModifiedType.CurveModified : CurveModifiedType.CurveDeleted);
	}

	CSRAW public static void SetObjectReferenceCurve (AnimationClip clip, EditorCurveBinding binding, ObjectReferenceKeyframe[] keyframes)
	{
		Internal_SetObjectReferenceCurve (clip, binding, keyframes);
	
		//TODO: We should probably move that to the C++ code
		if (onCurveWasModified != null)
			onCurveWasModified (clip, binding, keyframes != null ? CurveModifiedType.CurveModified : CurveModifiedType.CurveDeleted);
	}


	OBSOLETE warning GetAllCurves is deprecated. Use GetCurveBindings and GetObjectReferenceCurveBindings instead.
	CSRAW static AnimationClipCurveData[] GetAllCurves (AnimationClip clip, bool includeCurveData = true)
	{
		EditorCurveBinding[] bindings = GetCurveBindings (clip);

		AnimationClipCurveData[] curves = new AnimationClipCurveData[bindings.Length];
		for (int i=0;i<curves.Length;i++)
		{
			curves[i] = new AnimationClipCurveData(bindings[i]);
			
			if (includeCurveData)
				curves[i].curve = GetEditorCurve(clip, bindings[i]);
		}
		
		return curves;
	}

	OBSOLETE warning This overload is deprecated. Use the one with EditorCurveBinding instead.
	CSRAW public static bool GetFloatValue (GameObject root, string relativePath, Type type, string propertyName, out float data)
	{
		return GetFloatValue (root, EditorCurveBinding.FloatCurve (relativePath, type, propertyName), out data);
	}

	OBSOLETE warning This overload is deprecated. Use the one with EditorCurveBinding instead.
	CSRAW public static void SetEditorCurve (AnimationClip clip, string relativePath, Type type, string propertyName, AnimationCurve curve)
	{
		SetEditorCurve (clip, EditorCurveBinding.FloatCurve(relativePath, type, propertyName), curve);
	}

	OBSOLETE warning This overload is deprecated. Use the one with EditorCurveBinding instead.
	CSRAW public static AnimationCurve GetEditorCurve (AnimationClip clip, string relativePath, Type type, string propertyName)
	{
		return GetEditorCurve (clip, EditorCurveBinding.FloatCurve(relativePath, type, propertyName));
	}

	// Retrieves all animation events associated with the animation clip
	CUSTOM static AnimationEvent[] GetAnimationEvents (AnimationClip clip)
	{
		const AnimationClip::Events& events = clip->GetEvents();
		MonoArray* monoArray = mono_array_new (mono_domain_get (), MONO_COMMON.animationEvent, events.size());
		for (int i=0;i<events.size();i++)
		{
			MonoObject* monoEvent = mono_object_new (mono_domain_get (), MONO_COMMON.animationEvent);
			
			ExtractMonoObjectData<AnimationEvent*> (monoEvent) = new AnimationEvent(events[i]);
			ExtractMonoObjectData<AnimationEventMono> (monoEvent).m_OwnsData = 1;
			Scripting::SetScriptingArrayElement<MonoObject*>(monoArray, i, monoEvent);
		}
		return monoArray;
	}

	// Replaces all animation events in the animation clip
	CUSTOM static void SetAnimationEvents (AnimationClip clip, AnimationEvent[] events)
	{
		vector<AnimationEvent> cevents;
		for (int i=0;i<mono_array_length_safe(events);i++)
			cevents.push_back(*GetAnimationEvent(GetMonoArrayElement<MonoObject*>(events, i)));
		sort(cevents.begin(), cevents.end());
		clip->SetEvents(&cevents[0], cevents.size());
		clip->SetDirty();
	}
	
	// Calculates path from root transform to target transform.
	CUSTOM static string CalculateTransformPath (Transform targetTransform, Transform root)
	{
		return scripting_string_new(CalculateTransformPath (*targetTransform, root));
	}
	
	CUSTOM static AnimationClipSettings GetAnimationClipSettings(AnimationClip clip)
	{
		MonoObject *obj = mono_object_new (mono_domain_get(), MONO_COMMON.animationClipSettings);
		AnimationClipSettingsToMono(clip->GetAnimationClipSettings(),ExtractMonoObjectData<MonoAnimationClipSettings>(obj));
		return obj;
	}

	CUSTOM internal static void SetAnimationClipSettings (AnimationClip clip, AnimationClipSettings srcClipInfo)
	{
		AnimationClipSettings clipInfo;
		AnimationClipSettingsFromMono(ExtractMonoObjectData<MonoAnimationClipSettings>(srcClipInfo),clipInfo);
		clip->SetAnimationClipSettings(clipInfo);
	}		
	
	CUSTOM internal static void SetAnimationClipSettingsNoDirty(AnimationClip clip, AnimationClipSettings srcClipInfo)
	{
		AnimationClipSettings clipInfo;
		AnimationClipSettingsFromMono(ExtractMonoObjectData<MonoAnimationClipSettings>(srcClipInfo),clipInfo);
		clip->SetAnimationClipSettingsNoDirty(clipInfo);
	}		
	

	
	CUSTOM static bool IsValidPolynomialCurve (AnimationCurve curve)
	{
		return IsValidPolynomialCurve (*curve);
	}

	CUSTOM static void ConstrainToPolynomialCurve (AnimationCurve curve)
	{
		ConstrainToPolynomialCurve(*curve);
	}
	
	CUSTOM internal static bool CurveSupportsProcedural(AnimationCurve curve)
	{
		return PolynomialCurve::IsValidCurve (*curve);
	}

	CUSTOM internal static ModelImporterAnimationType GetAnimationType(AnimationClip clip)
	{
		return (int)clip->GetAnimationType();
	}

	CUSTOM static void SetAnimationType (AnimationClip clip, ModelImporterAnimationType type)
	{
		clip->SetAnimationType((AnimationClip::AnimationType)type);
	}

	CUSTOM internal static AnimationClipStats GetAnimationClipStats (AnimationClip clip)
	{
		AnimationClipStats stats;
		clip->GetStats(stats);
		return stats;
	}

	OBSOLETE warning Use AnimationMode.InAnimationMode instead
	CSRAW static public bool InAnimationMode ()
	{
		return AnimationMode.InAnimationMode();
	}
	OBSOLETE warning Use AnimationMode.StartAnimationmode instead
	CSRAW public static void StartAnimationMode (Object[] objects)
	{
		Debug.LogWarning ("AnimationUtility.StartAnimationMode is deprecated. Use AnimationMode.StartAnimationMode with the new APIs. The objects passed to this function will no longer be reverted automatically. See AnimationMode.AddPropertyModification");
		AnimationMode.StartAnimationMode();
	}

	OBSOLETE warning Use AnimationMode.StopAnimationMode instead
	CSRAW public static void StopAnimationMode ()
	{
		AnimationMode.StopAnimationMode();
	}

END


CLASS AnimationMode
	
	C++RAW
	
	CSRAW static private Color s_AnimatedPropertyColorLight = new Color (1.00f, 0.65f, 0.60f, 1f);
	CSRAW static private Color s_AnimatedPropertyColorDark = new Color (1.00f, 0.55f, 0.50f, 1f);
	CSRAW static public Color animatedPropertyColor
	{
		get { return EditorGUIUtility.isProSkin ? s_AnimatedPropertyColorDark : s_AnimatedPropertyColorLight; }
	}
	
	CUSTOM static bool IsPropertyAnimated (Object target, string propertyPath)
	{
		AnimationModeSnapshot& snapshot = GetAnimationModeSnapshot ();
		if (!snapshot.IsInAnimationMode())
			return false;

		return snapshot.IsPropertyAnimated (target, propertyPath.AsUTF8().c_str());
	}
	
	// Stops animation mode, as used by the animation editor.
	CUSTOM static void StopAnimationMode ()
	{
		return GetAnimationModeSnapshot ().StopAnimationMode();
	}
	
	// Returns true if the editor is currently in animation mode.
	CUSTOM static bool InAnimationMode ()
	{
		return GetAnimationModeSnapshot ().IsInAnimationMode();
	}

	// Starts animation mode, as used by the animation editor.
	CUSTOM public static void StartAnimationMode ()
	{
		return GetAnimationModeSnapshot ().StartAnimationMode();
	}
	
	CUSTOM static void BeginSampling ()
	{
		GetAnimationModeSnapshot ().BeginSampling();
	}

	CUSTOM static void EndSampling ()
	{
		GetAnimationModeSnapshot ().EndSampling();
	}

	CUSTOM static void SampleAnimationClip (GameObject gameObject, AnimationClip clip, float time)
	{
		GetAnimationModeSnapshot ().UpdateModifiedPropertiesForAnimationClipSampling(*gameObject, *clip);
		SampleAnimation (*gameObject, *clip, time, kClamp);
	}
	
	CUSTOM static void AddPropertyModification (EditorCurveBinding binding, PropertyModification modification, bool keepPrefabOverride)
	{
		PropertyModification cmodification;
		MonoToPropertyModification(modification, cmodification);

		EditorCurveBinding cbinding;
		MonoToEditorCurveBinding(binding, cbinding);
		
		GetAnimationModeSnapshot ().AddPropertyModification (cbinding, cmodification, keepPrefabOverride);
	}

END

C++RAW
static void CallAnimationClipAwake (AnimationClip *clip)
{
	ScriptingInvocation invocation(MONO_COMMON.callAnimationClipAwake);
	invocation.AddObject(Scripting::ScriptingWrapperFor(clip));
	invocation.Invoke();
}

static void RegisterCallbacks ()
{
	AnimationClip::SetOnAnimationClipAwake (CallAnimationClipAwake);
}

static RegisterRuntimeInitializeAndCleanup gRegisterCallbacks (RegisterCallbacks, NULL, 1);

CSRAW }
