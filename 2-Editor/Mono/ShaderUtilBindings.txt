C++RAW

#include "UnityPrefix.h"
#include "Runtime/Graphics/Texture.h"
#include "Editor/Src/AssetPipeline/ShaderImporter.h"
#include "Runtime/Shaders/Shader.h"
#include "Runtime/Utilities/FileUtilities.h"
#include "Editor/Src/EditorHelper.h"
#include "Editor/Src/Application.h"
#include "Runtime/GfxDevice/GfxDevice.h"
#include "Runtime/Utilities/Argv.h"
#include "External/shaderlab/Library/intshader.h"
#include "External/shaderlab/Library/SLParserData.h"
#include "Runtime/Math/Rect.h"
#include "Runtime/Shaders/Material.h"
#include "Editor/Src/Utility/ShaderUtility.h"
#include "Runtime/Scripting/Scripting.h"
#include "Runtime/Scripting/ScriptingUtility.h"
#include "Runtime/Scripting/ScriptingObjectWithIntPtrField.h"

extern GraphicsCaps gOriginalCaps;

using namespace std;

CSRAW
using System;
using UnityEngine;
using Object=UnityEngine.Object;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Collections;
using System.Reflection;
using System.Collections.Generic;
using System.IO;
using UnityScript.Scripting;
using UnityEditor;
using UnityEditorInternal;


namespace UnityEditor
{

CLASS ShaderUtil 
	CSRAW public enum ShaderPropertyType {
		Color,			
		Vector,		
		Float,		
		Range,		
		TexEnv,		
	};
	
	CUSTOM internal static int GetErrorCount (Shader s) {
		return s->GetErrors().GetErrors().size();
	} 
	CUSTOM internal static string GetShaderErrorMessage (Shader s, int index) {
		const ShaderErrors::ErrorContainer& errors = s->GetErrors().GetErrors();
		ShaderErrors::ErrorContainer::const_iterator it = errors.begin();
		std::advance (it, index);
		return scripting_string_new(it->message);
	} 
	CUSTOM internal static bool GetShaderErrorWarning (Shader s, int index) {
		const ShaderErrors::ErrorContainer& errors = s->GetErrors().GetErrors();
		ShaderErrors::ErrorContainer::const_iterator it = errors.begin();
		std::advance (it, index);
		return it->warning;
	} 
	CUSTOM internal static int GetShaderErrorLine (Shader s, int index) {
		const ShaderErrors::ErrorContainer& errors = s->GetErrors().GetErrors();
		ShaderErrors::ErrorContainer::const_iterator it = errors.begin();
		std::advance (it, index);
		return it->line;
	} 

	// Get the number of properties in Shader s
	CUSTOM static int GetPropertyCount (Shader s) {
		return s->GetPropertyCount();
	 } 
	 
	 CUSTOM static string GetPropertyDescription (Shader s, int propertyIdx) {
		return scripting_string_new(s->GetPropertyInfo(propertyIdx)->m_Description);
	 }

	 CUSTOM static string GetPropertyName (Shader s, int propertyIdx) {
		return scripting_string_new(s->GetPropertyInfo(propertyIdx)->m_Name);
	 }

	 CUSTOM static ShaderPropertyType GetPropertyType (Shader s, int propertyIdx) {
		return (int) s->GetPropertyInfo(propertyIdx)->m_Type;
	 }

	// Get Limits for for a range property ONLY.
	 CUSTOM static float GetRangeLimits (Shader s, int propertyIdx, int defminmax) {
		return s->GetPropertyInfo (propertyIdx)->m_DefValue[defminmax];
	 }

	CSRAW public enum ShaderPropertyTexDim {
		TexDimUnknown = -1, // unknown
		TexDimNone = 0, // no texture
		TexDimDeprecated1D = 1, // not used anymore, value there for backwards compatibility in serialization
		TexDim2D = 2,
		TexDim3D = 3,
		TexDimCUBE = 4,
		TexDimAny = 5,

		TexDimRECT = 5, // deprecated
	};

	CUSTOM public static ShaderPropertyTexDim GetTexDim (Shader s, int propertyIdx) {
		return (int)s->GetPropertyInfo (propertyIdx)->m_DefTexture.m_TexDim;
	}
	
	CUSTOM internal static int GetTextureDimension (Texture t) {
		return t->GetDimension();
	}

	CUSTOM public static bool IsShaderPropertyHidden (Shader s, int propertyIdx) {
		if (propertyIdx == -1)
			return false;
		return s->GetPropertyInfo(propertyIdx)->m_Flags & ShaderLab::ParserProperty::kPropFlagHideInInspector;
	}

	CUSTOM internal static string GetShaderPropertyAttribute (Shader s, string name) {
		const int propertyIdx = FindShaderPropertyIndex (s, name);
		if (propertyIdx == -1)
			return SCRIPTING_NULL;
		const ShaderLab::ParserProperty* prop = s->GetPropertyInfo (propertyIdx);
		if (!prop || prop->m_Attributes.empty())
			return SCRIPTING_NULL;
		return scripting_string_new(prop->m_Attributes[0].text);
	}
	
	CUSTOM internal static bool HasShadowCasterPass (Shader s)
	{
		return s->AnySubshaderHasShadowCasterPass();
	}
	CUSTOM internal static bool HasShadowCollectorPass (Shader s)
	{
		return s->HasShadowCollectorPass();
	}
	CUSTOM internal static bool HasTangentChannel (Shader s)
	{
		UInt32 mask = s->GetShaderLabShader()->GetActiveSubShader().GetAllUsedChannels();
		return mask & (1 << kShaderChannelTangent);
	}
	CUSTOM internal static string GetSourceChannels (Shader s)
	{
		UInt32 mask = s->GetShaderLabShader()->GetActiveSubShader().GetAllUsedChannels();
		std::string ch;
		static const char* const kChannelNames[kShaderChannelCount] = {
			"position",
			"normal",
			"color",
			"uv",
			"uv2",
			"tangent",
		};
		for( int i = 0; i < kShaderChannelCount; ++i )
		{
			if( mask & (1<<i) ) {
				if( !ch.empty() )
					ch += ',';
				ch += kChannelNames[i];
			};
		}
		return scripting_string_new(ch);
	}
	//CUSTOM static bool IsPixelLit (Shader s)
	//{
	//	return s->GetShaderLabShader()->GetIsPixelLit();
	//}
	//CUSTOM static bool DoesSupportShadows (Shader s)
	//{
	//	return s->GetShaderLabShader()->GetSupportsShadows();
	//}
	CUSTOM internal static bool DoesIgnoreProjector (Shader s)
	{
		return s->GetShaderLabShader()->GetNoProjector();
	}
	CUSTOM internal static int GetRenderQueue (Shader s)
	{
		return s->GetShaderLabShader()->GetRenderQueue();
	}
	CUSTOM internal static int GetLOD (Shader s)
	{
		ShaderLab::IntShader* ss = s->GetShaderLabShader();
		if (ss->HasNoSubShaders())
			return 0;
		return ss->GetActiveSubShader().GetLOD();
	}
	CUSTOM internal static string GetFallback (Shader s)
	{
		return scripting_string_new(s->GetShaderLabShader()->GetFallback());
	}
	CUSTOM internal static int GetSubShaderCount (Shader s)
	{
		return s->GetShaderLabShader()->GetSubShaders().size();
	}
	
	CUSTOM internal static string GetDependency (Shader s, string name)
	{
		const std::string* val = s->GetShaderLabShader()->GetDependency (name);
		return val ? scripting_string_new(*val) : NULL;
	}
	
	CSRAW internal enum ShaderModel {
		None,
		SM1,
		SM2,
		SM3,
		SM5,
	};
	CUSTOM internal static ShaderModel GetVertexModel (Shader s)
	{
		const ShaderLab::SubShader& ss = s->GetShaderLabShader()->GetActiveSubShader();
		int npasses = ss.GetValidPassCount();
		int maxLevel = 0;
		for( int i = 0; i < npasses; ++i ) {
			const ShaderLab::Pass& pass = *ss.GetPass(i);
			int level = pass.GetShaderProgramLevel(kShaderVertex);
			if( level > maxLevel )
				maxLevel = level;
		}
		return maxLevel;
	}

	CUSTOM internal static ShaderModel GetFragmentModel (Shader s)
	{
		const ShaderLab::SubShader& ss = s->GetShaderLabShader()->GetActiveSubShader();
		int npasses = ss.GetValidPassCount();
		int maxLevel = 0;
		for( int i = 0; i < npasses; ++i ) {
			const ShaderLab::Pass& pass = *ss.GetPass(i);
			int level = pass.GetShaderProgramLevel(kShaderFragment);
			if( level > maxLevel )
				maxLevel = level;
		}
		return maxLevel;
	}
		
	CUSTOM internal static void OpenCompiledShader (Shader shader)
	{
		Shader* s = shader;
		if( !s )
			return;
		std::string path = Format("Temp/Compiled-%s.shader", s->GetNamedObjectName());
		if( !WriteStringToFile( s->GetScript(), path, kNotAtomic, kFileFlagDontIndex | kFileFlagTemporary ) )
			return;

		path = PathToAbsolutePath(path);
		if (!OpenScriptFile (path, 0))
			WarningStringWithoutStacktrace ("Unable to open " + path + ": Check external editor in preferences");
	}
	
	CUSTOM_PROP internal static Rect rawViewportRect
	{
		int coords[4];
		GetGfxDevice().GetViewport (coords);
		return Rectf(coords[0], coords[1], coords[2], coords[3]);
	} 
	{ 
		int coords[4];
		coords[0] = RoundfToInt( value.x );
		coords[1] = RoundfToInt( value.y );
		coords[2] = RoundfToInt( value.width );
		coords[3] = RoundfToInt( value.height );
		GetGfxDevice().SetViewport( coords[0], coords[1], coords[2], coords[3] );
	}
	
	CUSTOM_PROP internal static Rect rawScissorRect
	{
		int coords[4];
		GetGfxDevice().GetScissorRect (coords);
		return Rectf(coords[0], coords[1], coords[2], coords[3]);
	}
	{
		int coords[4];
		coords[0] = RoundfToInt( value.x );
		coords[1] = RoundfToInt( value.y );
		coords[2] = RoundfToInt( value.width );
		coords[3] = RoundfToInt( value.height );
		if (GetGfxDevice().IsScissorEnabled())
		{
			GetGfxDevice().SetScissorRect( coords[0], coords[1], coords[2], coords[3] );
		}
	}

	// Does not check for non-RT license, only for hardware support.
	CUSTOM_PROP static bool hardwareSupportsRectRenderTexture
	{
		if (IsBatchmode())
			return false;
		gGraphicsCaps.InitializeOriginalEmulationCapsIfNeeded(); // make sure gOriginalCaps is initialized
		return (gOriginalCaps.hasRenderToTexture && (gOriginalCaps.npotRT != kNPOTNone));
	}
	
	CUSTOM_PROP internal static bool wireframeMode
	{
		return GetGfxDevice().GetWireframe();
	}
	{
		GetGfxDevice().SetWireframe( value );
	}

	CUSTOM internal static bool HasClip (Shader s)
	{
		return s->HasClip();
	}

	CUSTOM internal static void RecreateGfxDevice()
	{
		GetApplication().RequestRecreateGfxDevice();
	}

	CUSTOM internal static void RecreateSkinnedMeshResources()
	{
		GetApplication().RequestRecreateSkinnedMeshResources();
	}

	CUSTOM static Shader CreateShaderAsset (string source)
	{
		return Scripting::ScriptingWrapperFor (CreateShaderAsset (source));
	}

	CUSTOM static void UpdateShaderAsset (Shader shader, string source)
	{
		UpdateShaderAsset (shader, source);
	}

	CUSTOM internal static MaterialProperty[] GetMaterialProperties (Object[] mats)
	{
		if (GetScriptingArraySize(mats) == 0)
			return SCRIPTING_NULL;

		Shader* s = ScriptingObjectToObject<Material>(Scripting::GetScriptingArrayElementNoRef<ScriptingObjectPtr>(mats,0))->GetShader();
		int size = s->GetPropertyCount();

		MonoClass* klass = GetMonoManager().GetBuiltinEditorMonoClass("MaterialProperty");
		MonoArray* arr = mono_array_new (mono_domain_get(), klass, size);
		for (int i = 0; i < size; ++i)
		{
			MonoObject* obj = ScriptingInstantiateObject (klass);
			GetMonoArrayElement<MonoObject*> (arr,i) = obj;
			MonoMaterialProperty& res = ExtractMonoObjectData<MonoMaterialProperty>(obj);
			ExtractMonoMaterialProperty (s, i, mats, res);
		}
		return arr;
	}

	CUSTOM internal static MaterialProperty GetMaterialProperty (Object[] mats, string name)
	{
		if (GetScriptingArraySize(mats) == 0)
			return SCRIPTING_NULL;

		Shader* s = ScriptingObjectToObject<Material>(Scripting::GetScriptingArrayElementNoRef<ScriptingObjectPtr>(mats,0))->GetShader();

		MonoClass* klass = GetMonoManager().GetBuiltinEditorMonoClass("MaterialProperty");
		MonoObject* obj = ScriptingInstantiateObject (klass);
		MonoMaterialProperty& res = ExtractMonoObjectData<MonoMaterialProperty>(obj);
		int propertyIndex = FindShaderPropertyIndex (s, name);
		ExtractMonoMaterialProperty (s, propertyIndex, mats, res);
		return obj;
	}

	CSRAW internal static MaterialProperty GetMaterialProperty (Object[] mats, int propertyIndex)
	{
		return GetMaterialProperty_Index (mats, propertyIndex);
	}

	CUSTOM internal static MaterialProperty GetMaterialProperty_Index (Object[] mats, int propertyIndex)
	{
		if (GetScriptingArraySize(mats) == 0)
			return SCRIPTING_NULL;

		Shader* s = ScriptingObjectToObject<Material>(Scripting::GetScriptingArrayElementNoRef<ScriptingObjectPtr>(mats,0))->GetShader();

		MonoClass* klass = GetMonoManager().GetBuiltinEditorMonoClass("MaterialProperty");
		MonoObject* obj = ScriptingInstantiateObject (klass);
		MonoMaterialProperty& res = ExtractMonoObjectData<MonoMaterialProperty>(obj);
		ExtractMonoMaterialProperty (s, propertyIndex, mats, res);
		return obj;
	}

	CUSTOM internal static void ApplyProperty (MaterialProperty prop, int propertyMask, string undoName)
	{
		ApplyMonoMaterialProperty (ExtractMonoObjectData<MonoMaterialProperty>(prop), propertyMask, undoName);
	}

	CUSTOM internal static void ApplyMaterialPropertyBlockToMaterialProperty (MaterialPropertyBlock propertyBlock, MaterialProperty materialProperty)
	{
		ApplyMaterialPropertyBlockToMaterialProperty (*propertyBlock, ExtractMonoObjectData<MonoMaterialProperty>(materialProperty));
	}

	CUSTOM internal static void ApplyMaterialPropertyToMaterialPropertyBlock (MaterialProperty materialProperty, int propertyMask, MaterialPropertyBlock propertyBlock)
	{
		ApplyMaterialPropertyToMaterialPropertyBlock (ExtractMonoObjectData<MonoMaterialProperty>(materialProperty), propertyMask, *propertyBlock);
	}

END


CSRAW }
