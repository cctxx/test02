C++RAW
#include "UnityPrefix.h"
#include "Configuration/UnityConfigure.h"
#include "Runtime/Scripting/ScriptingExportUtility.h"
#include "Runtime/Scripting/Scripting.h"
#if ENABLE_SPRITES
#include "Runtime/Mono/MonoBehaviour.h"
#include "Runtime/Filters/Mesh/SpriteRenderer.h"
#include "Runtime/Graphics/SpriteFrame.h"
#include "Runtime/Graphics/SpriteUtility.h"
#include "Runtime/Graphics/Texture2D.h"
#include "Runtime/Scripting/ScriptingExportUtility.h"
#include "Editor/Src/AssetPipeline/SpriteImporterUtility.h"
#include "Editor/Src/AssetPipeline/SpriteFrameMetaData.h"
#endif //ENABLE_SPRITES

CSRAW
using UnityEngine;
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Collections;

#if ENABLE_SPRITES
namespace UnityEditor.Sprites
{
CONDITIONAL ENABLE_SPRITES
CLASS DataUtility

	CUSTOM static public Texture2D GetSpriteTexture(Sprite sprite, bool getAtlasData)
	{
		const SpriteRenderData& rd = sprite->GetRenderData(getAtlasData); // User specifies which RenderData is needed.
		if (getAtlasData && !rd.settings.packed)
			Scripting::RaiseArgumentException("Could not get atlas data - Sprite is not packed.");

		return Scripting::ScriptingWrapperFor(rd.texture);
	}

	CUSTOM static public Vector2[] GetSpriteMesh(Sprite sprite, bool getAtlasData)
	{
		const SpriteRenderData& rd = sprite->GetRenderData(getAtlasData); // User specifies which RenderData is needed.
		if (getAtlasData && !rd.settings.packed)
			Scripting::RaiseArgumentException("Could not get atlas data - Sprite is not packed.");

		const size_t count = rd.vertices.size();
		ScriptingArrayPtr array = CreateScriptingArray<Vector2f>(GetScriptingManager().GetCommonClasses().vector2, count);
		for (int i = 0; i < count; i++)
		{
			Scripting::SetScriptingArrayElement<Vector2f>(array, i, *(Vector2f*)&rd.vertices[i].pos);
		}
		return array;
	}

	CUSTOM static public Vector2[] GetSpriteUVs(Sprite sprite, bool getAtlasData)
	{
		const SpriteRenderData& rd = sprite->GetRenderData(getAtlasData); // User specifies which RenderData is needed.
		if (getAtlasData && !rd.settings.packed)
			Scripting::RaiseArgumentException("Could not get atlas data - Sprite is not packed.");

		const size_t count = rd.vertices.size();
		ScriptingArrayPtr array = CreateScriptingArray<Vector2f>(GetScriptingManager().GetCommonClasses().vector2, count);
		for (int i = 0; i < count; i++)
		{
			Scripting::SetScriptingArrayElement<Vector2f>(array, i, rd.vertices[i].uv);
		}
		return array;
	}

	CUSTOM static public UInt16[] GetSpriteIndices(Sprite sprite, bool getAtlasData)
	{
		const SpriteRenderData& rd = sprite->GetRenderData(getAtlasData); // User specifies which RenderData is needed.
		if (getAtlasData && !rd.settings.packed)
			Scripting::RaiseArgumentException("Could not get atlas data - Sprite is not packed.");

		const size_t count = rd.indices.size();
		ScriptingArrayPtr array = CreateScriptingArray<UInt16>(GetScriptingManager().GetCommonClasses().uInt_16, count);
		for (int i = 0; i < count; i++)
		{
			Scripting::SetScriptingArrayElement<UInt16>(array, i, rd.indices[i]);
		}
		return array;
	}

	CUSTOM internal static void GenerateOutline(Texture2D texture, Rect rect, float detail, byte alphaTolerance, bool holeDetection, out Vector2[][] paths)
	{
		const CommonScriptingClasses& commonScriptingClasses = GetScriptingManager().GetCommonClasses();
		MonoClass* vector2ArrayClass = mono_array_class_get(commonScriptingClasses.vector2, 1);

		std::vector< dynamic_array<Vector2f> > generatedPaths;
		GenerateSpriteOutline(texture, 1.0f, rect, Vector2f(0.0f, 0.0f), detail, alphaTolerance, holeDetection, 0.0f, kPathEmbed, &generatedPaths);
		
		const int pathCount = generatedPaths.size();
		*paths = mono_array_new(mono_domain_get(), vector2ArrayClass, pathCount);
		for (int i = 0; i < pathCount; ++i)
		{
			const dynamic_array<Vector2f>& generatedPath = generatedPaths[i];
			ScriptingArrayPtr& elem = Scripting::GetScriptingArrayElement<ScriptingArrayPtr>(*paths, i);
			elem = CreateScriptingArray<Vector2f>(generatedPath.data(), generatedPath.size(), commonScriptingClasses.vector2);
		}
	}

	CUSTOM internal static void GenerateOutlineFromSprite(Sprite sprite, float detail, byte alphaTolerance, bool holeDetection, out Vector2[][] paths)
	{
		const CommonScriptingClasses& commonScriptingClasses = GetScriptingManager().GetCommonClasses();
		MonoClass* vector2ArrayClass = mono_array_class_get(commonScriptingClasses.vector2, 1);

		std::vector< dynamic_array<Vector2f> > generatedPaths;
		sprite->GenerateOutline(detail, alphaTolerance, holeDetection, generatedPaths, 0);
		
		const int pathCount = generatedPaths.size();
		*paths = mono_array_new(mono_domain_get(), vector2ArrayClass, pathCount);
		for (int i = 0; i < pathCount; ++i)
		{
			const dynamic_array<Vector2f>& generatedPath = generatedPaths[i];
			ScriptingArrayPtr& elem = Scripting::GetScriptingArrayElement<ScriptingArrayPtr>(*paths, i);
			elem = CreateScriptingArray<Vector2f>(generatedPath.data(), generatedPath.size(), commonScriptingClasses.vector2);
		}
	}
END
}

namespace UnityEditorInternal
{
CONDITIONAL ENABLE_SPRITES
CLASS InternalSpriteUtility

	CUSTOM public static Rect[] GenerateAutomaticSpriteRectangles (Texture2D texture, int minRectSize, int extrudeSize)
	{
		dynamic_array<Rectf> spriteRectangles;
		
		GenerateAutomaticSpriteRectangles (minRectSize, extrudeSize, *texture, spriteRectangles);
		
		return CreateScriptingArray(&spriteRectangles[0], spriteRectangles.size(), MONO_COMMON.rect);
	}

	CUSTOM public static Rect[] GenerateGridSpriteRectangles (Texture2D texture, int offsetX, int offsetY, int sizeX, int sizeY, int padding)
	{
		dynamic_array<Rectf> spriteRectangles;
		GenerateGridSpriteRectangles (*texture, offsetX, offsetY, sizeX, sizeY, padding, spriteRectangles);
		
		return CreateScriptingArray(&spriteRectangles[0], spriteRectangles.size(), MONO_COMMON.rect);
	}
END
}
#endif //ENABLE_SPRITES
