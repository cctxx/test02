C++RAW

#include "UnityPrefix.h"
#include "Editor/Src/AssetServer/ASMonoUtility.h"
#include "Runtime/Camera/Camera.h"
#include "Runtime/Camera/RenderManager.h"
#include "Runtime/Shaders/Material.h"
#include "Editor/Src/Gizmos/GizmoManager.h"
#include "Runtime/Dynamics/PhysicsManager.h"
#include "Editor/Platform/Interface/EditorWindows.h"
#include "Editor/Src/AssetServer/ASController.h"
#include "Editor/Src/AssetServer/ASAdmin.h"
#include "Editor/Src/GUIDPersistentManager.h"
#include "Editor/Src/PackageUtility.h"
#include "Editor/Src/Application.h"
#include "Editor/Src/Selection.h"
#include "Editor/Src/PackageUtility.h"
#include "Editor/Src/BuildPipeline/BuildSerialization.h"
#include "Runtime/Mono/MonoScript.h"

using namespace AssetServer;


CSRAW
using System;
using UnityEngine;
using Object=UnityEngine.Object;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Collections;
using System.ComponentModel;
using System.Collections.Generic;

namespace UnityEditor
{
//*undocumented*
ENUM public AssetStatus  
	Calculating = -1,							// pseudostatus: currently unknown
	ClientOnly = 0,							// exists only on client [c]
	ServerOnly = 1,							// exists only on server [s]
	Unchanged = 2,								// no new versions, same data on client and server [=]
	Conflict = 3,								// client changed its data, and server has a new version (conflict case!) [~]
	Same = 4,									// new version on server, but client has the same data as it [&]
	NewVersionAvailable = 5,					// client didn't change its data, and server has a new verison [<]
	NewLocalVersion = 6,						// client changed its data, the server didn't [>]
	RestoredFromTrash = 7,						// pseudostatus: set when an asset has been restored from the trash. Will behave as kNewLocalVersion,
												// but is shown in the server view as if it was kClientOnly
	Ignored = 8,								// set on assets that have been excluded from versioning
	BadState = 9								// pseudostatus: connection error (new version of server protocol perhaps?)
END

//*undocumented*
ENUM internal ASRefreshState
	RefreshUpdate= 1,
	RefreshCommit = 2
END

//*undocumented*
ENUM internal DownloadResolution
	Unresolved = 0,
	SkipAsset = 1,
	TrashMyChanges = 2,
	TrashServerChanges = 3,
	Merge = 4
END

//*undocumented*
ENUM internal NameConflictResolution
	Unresolved = 0,
	RenameLocal = 1,
	RenameRemote = 2
END


CSRAW [Flags]
//*undocumented*
ENUM internal ChangeFlags
	None = 0,
	Modified = 1,
	Renamed = 2,
	Moved = 4,
	Deleted = 8,
	Undeleted = 16,
	Created = 32
END

//*undocumented*
STRUCT internal CompareInfo
	CSRAW 
	public CompareInfo(int ver1, int ver2, int binary, int abinary)
	{
		left = ver1;
		right = ver2;
		convert_binary = binary;
		autodetect_binary = abinary;
	}
	
	public int left;
	public int right;
	public int convert_binary;
	public int autodetect_binary;
END


CSRAW [StructLayout (LayoutKind.Sequential)]
CSRAW [System.Serializable]
//*undocumented*
CLASS internal MaintUserRecord
	CSRAW
	public int enabled;
	public string userName;
	public string fullName;
	public string email;
END

CSRAW [StructLayout (LayoutKind.Sequential)]
CSRAW [System.Serializable]
//*undocumented*
CLASS internal MaintDatabaseRecord
	CSRAW
	public string name;
	public string dbName;
END


CSRAW [StructLayout (LayoutKind.Sequential)]
CSRAW [System.Serializable]
//*undocumented*
CLASS internal DeletedAsset
	CSRAW
	public int changeset;
	public string guid;
	public string parent;
	public string name;
	public string fullPath;
	public string date;
	public int assetIsDir;
	
	static internal int Compare (DeletedAsset p1, DeletedAsset p2) 
	{ 
		return p1.changeset > p2.changeset ? -1 : 
			(p1.changeset < p2.changeset ? 1 : 
			string.Compare(p1.fullPath, p2.fullPath, true)); 
	}
END

CSRAW [StructLayout (LayoutKind.Sequential)]
CSRAW [System.Serializable]
//*undocumented*
CLASS internal Changeset
	CSRAW
	public int changeset;			// The changeset id on server or -1 for a changeset that has not yet been committed
	public string message;			// The commit message
	public string date;				// The timestamp of the commit.
	public string owner;			// The user who performed the commit.
	public ChangesetItem[] items;
END

CSRAW [StructLayout (LayoutKind.Sequential)]
CSRAW [System.Serializable]
//*undocumented*
CLASS internal ChangesetItem
	CSRAW
	public string fullPath;
	public string guid;
	public string assetOperations;
	public int assetIsDir;
	public ChangeFlags changeFlags;
	
	static internal int Compare (ChangesetItem p1, ChangesetItem p2) 
	{ 
		return string.Compare(p1.fullPath, p2.fullPath, true);
	}
END

CSRAW [StructLayout (LayoutKind.Sequential)]
[System.Serializable]
//*undocumented*
CLASS public AssetsItem
    CSRAW
	public string guid;
	public string parentGuid;
	public string pathName;
	public string message;
	public string exportedAssetPath;
	public string guidFolder;
	public int enabled;
	public int assetIsDir;
	public int changeFlags;
	public string previewPath;
	public int exists;
END


//*undocumented*
CLASS internal AssetServer

CUSTOM internal static AssetStatus GetStatus(Object asset) 
{
	Object* assetObj = asset;
		if (assetObj)
		{
			GUIDPersistentManager& pm = GetGUIDPersistentManager ();
			string path = pm.GetPathName (assetObj->GetInstanceID ());
			UnityGUID guid = pm.GUIDFromAnySerializedPath (path);
			if (guid == UnityGUID())
				return -2;
				
			AssetServer::Configuration& conf = AssetServer::Configuration::Get();
			
			AssetServer::Item item = conf.GetWorkingItem(guid);

			AssetServer::Status status = item.GetStatus();
			return status;
		}
		else
			return -2;
	
}

//*undocumented*
CUSTOM internal static AssetStatus GetStatusGUID(string guidString) 
{
	UnityGUID guid = StringToGUID(guidString);
	
	if (guid == UnityGUID())
			return -2;
				
	AssetServer::Configuration& conf = AssetServer::Configuration::Get();
	
	AssetServer::Item item = conf.GetWorkingItem(guid);
	if(! item )
		item = conf.GetServerItem(guid);

	AssetServer::Status status = item.GetStatus();
	return status;
	
}

CUSTOM internal static ChangeFlags GetChangeFlags(string guid)
{
	return Configuration::Get().GetWorkingItem(StringToGUID(guid)).GetChangeFlags();
}

CUSTOM internal static void DoUpdateWithoutConflictResolutionOnNextTick(string[] guids)
{
	set<UnityGUID> cguids = ConvertToGUIDs(guids);
	return Controller::Get().DoUpdateWithoutConflictResolutionOnNextTick(cguids);
}

CUSTOM internal static void ShowDialogOnNextTick(string title, string text, string button1, string button2)
{
	Controller::Get().DoShowDialogOnNextTick(title, text, button1, button2);
}

// Returns null if a failure has occurred
CUSTOM internal static string[] UpdateGetConflicts ()
{
	set<UnityGUID> cguids;
	if (Controller::Get().UpdateGetConflicts(&cguids))
	{
		return ConvertToGUIDs(cguids);
	}
	else
		return NULL;
}

CUSTOM internal static bool UpdateSetResolutions(string[] guids, DownloadResolution[] resolutions)
{
	return Controller::Get().UpdateSetResolutions(ConvertToResolutions(guids, resolutions));
}

CUSTOM static bool UpdateStartDownload()
{
	return Controller::Get().UpdateStartDownload();
}

CUSTOM static bool UpdateComplete()
{
	return Controller::Get().UpdateComplete();
}

CUSTOM static bool UpdateAbort()
{
	return Controller::Get().UpdateAbort();
}

// Commit changes

CUSTOM static bool CommitBegin(string changeDescription, string[] candidates)
{
	string cChangeDesc = changeDescription;
	set<UnityGUID> cguids = ConvertToGUIDs(candidates);
	
	return Controller::Get().CommitBegin(cChangeDesc, cguids);
}

CUSTOM static bool CommitStartUpload()
{
	return Controller::Get().CommitStartUpload();
}

C++RAW
 string progressText;

CUSTOM static float UpdateGetDownloadProgress()
{
	return Controller::Get().UpdateGetDownloadProgress(progressText);
}

CUSTOM static float CommitGetUploadProgress()
{
	return Controller::Get().CommitGetUploadProgress(progressText);
}

CUSTOM static string GetProgressText()
{
	return scripting_string_new(progressText);
}

CUSTOM static bool CommitComplete()
{
	return Controller::Get().CommitComplete();
}

CUSTOM static bool CommitAbort()
{
	return Controller::Get().CommitAbort();
}

CUSTOM static void SetAssetServerError(string error, bool isConnectionError)
{
	if (isConnectionError)
		Controller::Get().SetConnectionError(error);
	else
		Controller::Get().SetError(error);
}

CUSTOM static string GetAssetServerError()
{ 
	return scripting_string_new(Controller::Get().GetErrorString()); 
}

CUSTOM static void ClearAssetServerError()
{
	Controller::Get().ClearError();
}

CUSTOM static bool HasConnectionError()
{
	return Controller::Get().HasConnectionError();
}

CUSTOM static bool RevertVersion(string assetGUID, int version)
{
	UnityGUID guid = StringToGUID(assetGUID);
	
	return Controller::Get().RevertVersion(guid, version);
}

CUSTOM static bool RecoverDeleted(string assetGUID, int version, string name, string parentGUID)
{
	UnityGUID cguid = StringToGUID(assetGUID);
	UnityGUID cParentGUID = StringToGUID(parentGUID);
	
	string cname = name;
	
	return Controller::Get().RecoverDeleted(cguid, version, cname, cParentGUID);
}

CUSTOM static bool CompareFiles(string[] guids, CompareInfo[] selection)
{	
	return Controller::Get().CompareFiles(ConvertToCompareInfo(guids, selection));
}

CUSTOM static string[] GetAllRootGUIDs()
{
	set<UnityGUID> roots = AssetDatabase::Get().GetAllRootGUIDs();
	return ConvertToGUIDs(roots);
}

CUSTOM static string GetRootGUID()
{
	return scripting_string_new(GUIDToString(kAssetFolderGUID));
}

CUSTOM static string[] CollectAllChildren (string guid, string[] collection)
{
	set<UnityGUID> roots = ConvertToGUIDs(collection);
	AssetDatabase::Get().CollectAllChildren(StringToGUID(guid), &roots);
	
	return ConvertToGUIDs(roots);
}

CUSTOM static string GetAssetPathName(string guid)
{
	string cguid = guid;
	
	return scripting_string_new(AssetServer::Controller::Get().GetAssetPathName(StringToGUID(cguid)));
}

CUSTOM static void RemoveMaintErrorsFromConsole()
{
	AssetServer::Controller::Get().RemoveMaintErrorsFromConsole();
}

CUSTOM static DownloadResolution GetDownloadResolution(string guid)
{
	return AssetServer::Controller::Get().GetDownloadResolution(StringToGUID(guid));
}

// Returns NULL if there is no naming conflict
CUSTOM static string GetPathNameConflict(string guid)
{
	UnityGUID cguid = AssetServer::Configuration::Get().GetPathNameConflict(StringToGUID(guid));
	
	if (cguid == UnityGUID())
		return NULL;
	
	return scripting_string_new(GUIDToString(cguid));
}

CUSTOM static bool HasDeletionConflict(string guid)
{
	UnityGUID cguid = StringToGUID(guid);
	
	if (!AssetServerCache::Get().IsItemDeleted(cguid))
		return false;
	else
		return AssetServer::Configuration::Get().HasDeletionConflict(cguid);
}

CUSTOM static NameConflictResolution GetNameConflictResolution(string guid)
{
	return AssetServer::Controller::Get().GetNameConflictResolution(StringToGUID(guid));
}

CUSTOM static void SetDownloadResolution(string guid, DownloadResolution res)
{
	AssetServer::Controller::Get().SetDownloadResolution(StringToGUID(guid), (DownloadResolution)res);
}

CUSTOM static void SetDownloadResolutionInt(string guid, int res)
{
	AssetServer::Controller::Get().SetDownloadResolution(StringToGUID(guid), (DownloadResolution)res);
}

CUSTOM static void SetNameConflictResolution(string guid, NameConflictResolution res)
{
	UnityGUID cguid = StringToGUID(guid);
	g_NameConflicts.push_back(cguid);

	AssetServer::Controller::Get().SetNameConflictResolution(cguid, (NameConflictResolution)res );
}

CUSTOM static string UnityGUID(int a, int b, int c, int d)
{
	return scripting_string_new(GUIDToString(UnityGUID(a, b, c, d)));
}

CUSTOM static string[] BuildExportPackageAssetListGUIDs(string[] guids, bool dependencies, bool includeUnmodified = true, bool includeNameConflicts = false)
{
	vector<ImportPackageAsset> assets;
	set<UnityGUID> cguids = ConvertToGUIDs(guids);
	vector<string> cstrings;
	
	BuildExportPackageAssetList (&cguids, &assets, dependencies, includeUnmodified, includeNameConflicts);
	
	cstrings.reserve(assets.size());
	
	for (vector<ImportPackageAsset>::iterator i = assets.begin(); i != assets.end(); i++)
	{
		cstrings.push_back(GUIDToString(i->guid));
	}
	
	return Scripting::StringVectorToMono(cstrings);
}

CUSTOM static AssetsItem[] BuildExportPackageAssetListAssetsItems(string[] guids, bool dependencies, bool includeUnmodified = true, bool includeNameConflicts = false)
{
	vector<ImportPackageAsset> assets;
	set<UnityGUID> cguids = ConvertToGUIDs(guids);
	
	BuildExportPackageAssetList (&cguids, &assets, dependencies, includeUnmodified, includeNameConflicts);
	
	return VectorToMonoClassArray<ImportPackageAsset, MonoAssetsItem> (assets, GetMonoManager().GetBuiltinEditorMonoClass("AssetsItem"), AssetsItemToMono);
}

CUSTOM static AssetsItem[] BuildAllExportPackageAssetListAssetsItems()
{
	typedef UNITY_MAP(kMemAssetServerCache, UnityGUID, Item) ItemMap;
	return MapToMonoClassArray<ItemMap, UnityGUID, Item, MonoAssetsItem> (AssetServerCache::Get().GetCachedChanges(), GetMonoManager().GetBuiltinEditorMonoClass("AssetsItem"), AssetsItemToMono);
}

CUSTOM static void ExportPackage(string[] guids, string fileName )
{
	set<UnityGUID> cguids = ConvertToGUIDs(guids);
	DelayedExportPackage( cguids, fileName );
}

CSRAW static AssetsItem[] ImportPackageStep1(string packagePath)
{
	string dummy;
	return ImportPackageStep1(packagePath, out dummy);
}

CUSTOM static AssetsItem[] ImportPackageStep1(string packagePath, out string packageIconPath)
{
	vector<ImportPackageAsset> assets;
	string cppIconPath;
	
	if (ImportPackageStep1 ( packagePath, assets, cppIconPath) )
	{
		packageIconPath->str = MonoStringNew(cppIconPath);
		return VectorToMonoClassArray<ImportPackageAsset, MonoAssetsItem> (assets, GetMonoManager().GetBuiltinEditorMonoClass("AssetsItem"), ImportAssetsItemToMono);
	}	
	
	packageIconPath->str = MonoStringNew("");
	return NULL;
}

CUSTOM static void ImportPackageStep2(AssetsItem[] assets)
{
	vector<ImportPackageAsset> c_assets; 	
	MonoClassArrayToVector ( assets, c_assets, AssetsItemToCpp );
	DelayedImportPackageStep2( c_assets );
}

CUSTOM static AssetsItem[] GetLocalDeletedItems()
{
	vector<AssetServerCache::DeletedItem> assets;
	AssetServerCache::Get().GetDeletedItems(assets);
	return VectorToMonoClassArray<AssetServerCache::DeletedItem, MonoAssetsItem> (assets, GetMonoManager().GetBuiltinEditorMonoClass("AssetsItem"), AssetsItemToMono);
}

CUSTOM static bool IsItemDeleted(string guid)
{
	return AssetServerCache::Get().IsItemDeleted(StringToGUID(guid));
}

CUSTOM static string GetDeletedItemPathAndName(string guid)
{
	AssetServerCache::DeletedItem item;
	
	if (!AssetServerCache::Get().GetDeletedItem(StringToGUID(guid), item))
		return scripting_string_new("");
	else
		return scripting_string_new(item.fullPath);
}

CUSTOM static Changeset[] GetHistorySelected(string[] guids)
{
	/*vector<Changeset> history;
	set<UnityGUID> cguids = ConvertToGUIDs(guids);

	if(!Configuration::Get().GetHistory(cguids, &history))
		return NULL;
		
	return VectorToMonoClassArray<Changeset, MonoChangeset> (history, GetMonoManager().GetBuiltinEditorMonoClass("Changeset"), ChangesetToMono);*/
	
	vector<Changeset> history;
	vector<ChangesetDummy> hisotryForMono;
	set<UnityGUID> cguids = ConvertToGUIDs(guids);
	
	if (!AssetServer::Configuration::Get().GetHistory(cguids, &history))
		return NULL;
		
	// convert to ChangesetDummies
	for (vector<Changeset>::iterator i = history.begin(); i != history.end(); i++)
	{
		ChangesetDummy cd;
		i->GetItems(&cd.items);
		cd.srcChangeset = *i;
		hisotryForMono.push_back(cd);
	}

	return VectorToMonoClassArray<ChangesetDummy, MonoChangeset> (hisotryForMono, GetMonoManager().GetBuiltinEditorMonoClass("Changeset"), ChangesetToMono);
}

// Returns NULL on error
CUSTOM static Changeset[] GetHistory(int downToRevision = -1)
{
	vector<Changeset> history;
	vector<ChangesetDummy> hisotryForMono;
	set<UnityGUID> guids;
	
	if (!AssetServer::Configuration::Get().GetHistory(guids, &history))
		return NULL;
		
	if (downToRevision != -1)
	{
		vector<Changeset>::iterator iFrom = history.end();
		
		for (vector<Changeset>::iterator i = history.begin(); i != history.end(); i++)
		{
			if (i->changeset == downToRevision)
			{
				iFrom = i;
				break;
			}
		}
		
		if (iFrom != history.end())
			history.erase(iFrom, history.end());
	}
	
	// convert to ChangesetDummies
	for (vector<Changeset>::iterator i = history.begin(); i != history.end(); i++)
	{
		ChangesetDummy cd;
		i->GetItems(&cd.items);
		cd.srcChangeset = *i;
		hisotryForMono.push_back(cd);
	}

	return VectorToMonoClassArray<ChangesetDummy, MonoChangeset> (hisotryForMono, GetMonoManager().GetBuiltinEditorMonoClass("Changeset"), ChangesetToMono);
}

CUSTOM static Changeset[] GetNewItems()
{
	typedef UNITY_MAP(kMemTempAlloc, int, ChangesetDummy) ChangesetMap;
	ChangesetMap availableUpdates;

	AssetServer::Configuration::Get().GetUpdatesForMono(-1, availableUpdates);

	MonoArray* arr = MapToMonoClassArray<ChangesetMap, int, ChangesetDummy, MonoChangeset> (availableUpdates, GetMonoManager().GetBuiltinEditorMonoClass("Changeset"), ChangesetMapToMono);
	
	ASMonoUtility::Get().SetLatestPassedChangeset(availableUpdates.begin()->first);
	
	return arr;
}

CUSTOM static void SetProjectName(string name)
{
	GetApplication().SetAssetServerProjectName(name);
}

CUSTOM static void Initialize(string userName, string connectionString, int timeout)
{
	Controller::Get().Initialize (userName, connectionString, timeout);
}

CUSTOM static string[] CollectSelection()
{
	set<UnityGUID> guids;
	CollectSelection(&guids);
	return ConvertToGUIDs(guids);
}

CUSTOM static string[] CollectDeepSelection()
{
	set<UnityGUID> tmp;
	set<UnityGUID> cguids;

	AssetDatabase* db = &AssetDatabase::Get();	
	
	CollectSelection(&tmp);
	
	if (!tmp.empty() ) 
	{
		for (set<UnityGUID>::iterator i = tmp.begin(); i != tmp.end(); i++)
		{
			cguids.insert (*i);
			db->CollectAllChildren (*i, &cguids);
		}
	}
	// Nothing selected, use the root
	else 
	{
		set<UnityGUID> roots = db->GetAllRootGUIDs();
		cguids.insert(roots.begin(), roots.end());
		db->CollectAllChildren (kAssetFolderGUID, &cguids);
	}
	
	return ConvertToGUIDs(cguids);
}

CUSTOM static bool AssetIsDir(string guid)
{
	AssetServerCache::DeletedItem di;
	UnityGUID cguid = StringToGUID(guid);
		
	if (AssetServerCache::Get().GetDeletedItem(cguid, di))
	{
		return di.type == kTDir;
	}

	return AssetServer::Controller::Get().AssetIsDir(cguid);
}

CUSTOM static void DoUpdateOnNextTick(bool forceShowConflictResolutions, string backendFunctionForConflictResolutions)
{
	AssetServer::Controller::Get().DoUpdateOnNextTick(forceShowConflictResolutions, 
							backendFunctionForConflictResolutions, 
							g_DownloadResolutions, g_NameConflicts);
}

CUSTOM static void DoCommitOnNextTick(string description, string[] guids)
{
	set<UnityGUID> cguids = ConvertToGUIDs(guids);
	AssetServer::Controller::Get().DoCommitOnNextTick(description, cguids);
}

CUSTOM static void DoUpdateStatusOnNextTick()
{
	AssetServer::Controller::Get().DoUpdateStatusOnNextTick();
}

CUSTOM static void DoRefreshAssetsOnNextTick()
{
	AssetServer::Controller::Get().DoRefreshAssetsOnNextTick();
}

CUSTOM static void DoRefreshAssetsAndUpdateStatusOnNextTick()
{
	AssetServer::Controller::Get().DoRefreshAssetsAndUpdateStatusOnNextTick();
}

CUSTOM static string GetDatabaseName(string server, string user, string password, string port, string projectName)
{
	return scripting_string_new(AssetServer::Configuration::Get().GetDatabaseName(server, user, 
		password, port, projectName));
}

CUSTOM static string GetParentGUID(string itemGUID, int changeset)
{
	AssetServer::Item item;
	AssetServer::Configuration &conf = AssetServer::Configuration::Get();
	
	if (changeset != -1)
	{
		item = conf.GetServerItem(StringToGUID(itemGUID), changeset);
		
		if (item.parent == kTrashGUID)
		{
			item = conf.GetAncestor(item, true);		
		}
	}else
	{
		item = AssetServer::Configuration::Get().GetWorkingItem(StringToGUID(itemGUID));
	
		// not yet downloaded?
		if (item == Item())
			item = AssetServer::Configuration::Get().GetServerItem(StringToGUID(itemGUID));
		
		if (item.parent == kTrashGUID)
		{
			AssetServerCache::DeletedItem di;
		
			if (AssetServerCache::Get().GetDeletedItem(item.guid, di))
				return scripting_string_new(GUIDToString(di.parent));
		}
	}
	
	return scripting_string_new(GUIDToString(item.parent));
}

CUSTOM static DeletedAsset[] GetServerDeletedItems()
{
	vector<DeletedAsset> recoverAssets;
	
	if(!Configuration::Get().ListDeletedAssets(&recoverAssets) )
		return NULL;
		
	return VectorToMonoClassArray<DeletedAsset, MonoDeletedAsset> (recoverAssets, GetMonoManager().GetBuiltinEditorMonoClass("DeletedAsset"), DeletedAssetToMono);
}

CUSTOM static void DoRecoverOnNextTick(DeletedAsset[] assets)
{
	vector<DeletedAsset> cassets;
	
	for (int i = 0; i < mono_array_length_safe(assets); i++) 
	{
		MonoObject* mobj = GetMonoArrayElement<MonoObject*> (assets, i);
		MonoDeletedAsset masset = ExtractMonoObjectData<MonoDeletedAsset> (mobj);
		DeletedAsset asset;
		asset.changeset = masset.changeset;
		asset.guid = StringToGUID(scripting_cpp_string_for(masset.guid));
		asset.parent = StringToGUID(scripting_cpp_string_for(masset.parent));
		asset.name = scripting_cpp_string_for(masset.name);
		asset.type = masset.assetIsDir != 0 ? kTDir : kTText;
		cassets.push_back(asset);
	}

	AssetServer::Controller::Get().DoRecoverOnNextTick(cassets);
}

CUSTOM static void DoRevertOnNextTick(int changeset, string guid)
{
	AssetServer::Controller::Get().DoRevertOnNextTick(changeset, StringToGUID(guid));
}

CUSTOM static void SetStickyChangeset(int changeset)
{
	Configuration::Get().SetStickyChangeset(changeset);
}

CUSTOM static void AdminSetCredentials(string server, int port, string user, string password)
{
	Admin& adm = Admin::Get();
	adm.AdminSetCredentials(server, port, user, password);
}

CUSTOM static MaintDatabaseRecord[] AdminRefreshDatabases()
{
	Admin& adm = Admin::Get();
	if (adm.AdminRefreshDatabases())
	{
		return SetToMonoClassArray<MaintDatabaseRecord, MonoMaintDatabaseRecord> (adm.GetDatabases(), 
			GetMonoManager().GetBuiltinEditorMonoClass("MaintDatabaseRecord"), MaintDatabaseRecordToMono);
	}
	else
		return NULL;
}

CUSTOM static MaintUserRecord[] AdminGetUsers(string databaseName)
{
	Admin& adm = Admin::Get();
	if (adm.AdminGetUsers(databaseName))
	{
		return SetToMonoClassArray<MaintUserRecord, MonoMaintUserRecord> (adm.GetUsers(),
			GetMonoManager().GetBuiltinEditorMonoClass("MaintUserRecord"), MaintUserRecordToMono);
	}
	else
		return NULL;
}

CUSTOM static void AdminChangePassword(string userName, string newPassword)
{
	Admin::Get().AdminChangePassword(userName, newPassword);
}

CUSTOM static int AdminCreateDB(string newProjectName, string copyFromProjectName="")
{
	return Admin::Get().AdminCreateDB(newProjectName, copyFromProjectName);
}

CUSTOM static int AdminDeleteDB(string projectName)
{
	return Admin::Get().AdminDeleteDB(projectName);
}

CUSTOM static int AdminCreateUser(string userName, string userFullName, string userEmail, string userPassword)
{
	return Admin::Get().AdminCreateUser(userName, userFullName, userEmail, userPassword);
}

CUSTOM static int AdminDeleteUser(string userName)
{
	return Admin::Get().AdminDeleteUser(userName);
}

CUSTOM static bool AdminSetUserEnabled(string databaseName, string userName, string fullName, string email, int enabled)
{
	return Admin::Get().SetUserEnabled(databaseName, userName, fullName, email, enabled);
}

CUSTOM static bool AdminModifyUserInfo(string databaseName, string userName, string fullName, string email)
{
	return Admin::Get().ModifyUserInfo(databaseName, userName, fullName, email);
}

CUSTOM static int IsGUIDValid(string guid)
{
	UnityGUID cguid = StringToGUID(guid);
	
	return cguid != UnityGUID();
}

CUSTOM static int GetServerItemChangeset(string guid, int changeset)
{
	Item found = AssetServer::Configuration::Get().GetServerItem(StringToGUID(guid), changeset);
	
	if( found )
		return found.changeset;
	else
		return -1;
}

CUSTOM static int GetWorkingItemChangeset(string guid)
{
	Item found = AssetServer::Configuration::Get().GetWorkingItem(StringToGUID(guid));
	
	if( found )
		return found.changeset;
	else
		return -1;
}

CUSTOM static bool AssetIsBinaryByGUID(string guid)
{
	return AssetServer::Controller::Get().AssetIsBinary(StringToGUID(guid));
}

CUSTOM static int IsAssetBinary(string name)
{
	return AssetServer::Controller::Get().AssetIsBinary(name);
}

CUSTOM static string[] CollectAllDependencies(string[] selection)
{
	set<UnityGUID> cguids = ConvertToGUIDs(selection);
	cguids = CollectAllDependencies(cguids);
	return ConvertToGUIDs(cguids);
}

CUSTOM static string GetLastCommitMessage()
{
	return scripting_string_new(AssetServerCache::Get().GetLastCommitMessage());
}

CUSTOM static void SetLastCommitMessage(string message)
{
	AssetServerCache::Get().SetLastCommitMessage(message);
}

CUSTOM static string[] GetCommitSelectionGUIDs()
{
	return ConvertToGUIDs(AssetServerCache::Get().GetCommitSelectionGUIDs());
}

CUSTOM static void SetCommitSelectionGUIDs(string[] guids)
{
	AssetServerCache::Get().SetCommitSelectionGUIDs(ConvertToGUIDs(guids));
}

CUSTOM static void ClearCommitPersistentData()
{
	AssetServerCache::Get().ClearCommitPersistentData();
}

CUSTOM static int IsControllerBusy()
{
	return AssetServer::Controller::Get().IsBusy();
}

CUSTOM static int GetLastControllerActionResult()
{
	return AssetServer::Controller::Get().GetLastActionResult();
}

CUSTOM static void SetAfterActionFinishedCallback(string className, string functionName)
{
	AssetServer::Controller::Get().SetAfterActionFinishedCallback(className, functionName);
}

CUSTOM static void SetSelectionFromGUID(string guid)
{
	AssetDatabase &db = AssetDatabase::Get();
	UnityGUID cguid = StringToGUID(guid);
	
	if (db.IsAssetAvailable(cguid))
		Selection::SetActive (db.AssetFromGUID(cguid).mainRepresentation.object);
	else
		Selection::SetActive ( NULL );
}

CUSTOM static int IsAssetAvailable(string guid)
{
	return AssetDatabase::Get().IsAssetAvailable(StringToGUID(guid));
}

CUSTOM static void SetSelectionFromGUIDs(string[] guids)
{
	AssetDatabase &db = AssetDatabase::Get();
	set<UnityGUID> cguids = ConvertToGUIDs(guids);
	TempSelectionSet sel;

	for (set<UnityGUID>::const_iterator i = cguids.begin(); i != cguids.end(); i++)
	{
		if (db.IsAssetAvailable(*i))
			sel.insert(db.AssetFromGUID(*i).mainRepresentation.object);
	}
	
	Selection::SetSelection (sel);
}

CUSTOM static bool GetRefreshUpdate()
{
	return ASMonoUtility::Get().GetRefreshUpdate();
}

CUSTOM static bool GetRefreshCommit()
{
	return ASMonoUtility::Get().GetRefreshCommit();
}

CUSTOM static void ClearRefreshUpdate()
{
	ASMonoUtility::Get().ClearRefreshUpdate();
}

CUSTOM static void ClearRefreshCommit()
{
	ASMonoUtility::Get().ClearRefreshCommit();
}

CUSTOM static void CheckForServerUpdates()
{
	ASMonoUtility::Get().CheckForServerUpdates();
}

CUSTOM static int GetCachesInitialized()
{
	return AssetServerCache::Get().GetCachesInitialized();
}

CUSTOM static int IsConstantGUID(string guid)
{
	return GetGUIDPersistentManager().IsConstantGUID(StringToGUID(guid));
}

// Asset server testing
CUSTOM static void Clear()
{
	Configuration::Get().Clear();
}

// Need to save static data between recompiles
C++RAW
 map<string, string> testingStrings;

CUSTOM static void SaveString(string strName, string strValue)
{
	testingStrings[strName] = strValue;
}

CUSTOM static string GetAndRemoveString(string strName)
{
	map<string, string>::iterator i = testingStrings.find(strName);
	
	if (i == testingStrings.end())
		return scripting_string_new("");
	
	MonoString *str = scripting_string_new(i->second);
	testingStrings.erase(i);
	
	return str;
}

CUSTOM static string GetString(string strName)
{
	map<string, string>::iterator i = testingStrings.find(strName);
	
	if (i == testingStrings.end())
		return scripting_string_new("");
	
	return scripting_string_new(i->second);
}

END

C++RAW

struct MonoPackageInfo
{
	MonoString * packagePath;
	MonoString * jsonInfo;
	MonoString * iconURL;
};
	
//*undocumented*
STRUCT public PackageInfo
    CSRAW
	public string packagePath;
	public string jsonInfo;
	public string iconURL;

CUSTOM static internal PackageInfo[] GetPackageList()
{
	vector<PackageInfo> packages;
	GetPackageList(packages);
	size_t size = packages.size();
	MonoArray *arr = mono_array_new (mono_domain_get (), GetMonoManager().GetBuiltinEditorMonoClass("PackageInfo"), size );
	
	for (int i = 0; i < size ;i++) 
	{
		MonoPackageInfo& info = GetMonoArrayElement<MonoPackageInfo> (arr,i);
		info.packagePath = scripting_string_new (packages[i].packagePath);
		info.jsonInfo = scripting_string_new (packages[i].jsonInfo);
		info.iconURL = scripting_string_new (packages[i].GetIconDataURL());
	}
	return arr;
	
}

END
CSRAW }
