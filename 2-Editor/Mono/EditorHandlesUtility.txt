C++RAW

#include "UnityPrefix.h"
#include "Runtime/Camera/Camera.h"
#include "Runtime/Camera/RenderManager.h"
#include "Runtime/Shaders/Material.h"
#include "Editor/Src/Gizmos/GizmoManager.h"
#include "Editor/Platform/Interface/EditorWindows.h"
#include "Editor/Src/Picking.h"
#include "Runtime/Camera/CameraUtil.h"
#include "Runtime/GfxDevice/GfxDevice.h"
#include "Runtime/Camera/HaloManager.h"
#include "Runtime/Camera/RenderLayers/GUILayer.h"
#include "Runtime/Camera/Flare.h"
#include "Runtime/Scripting/ScriptingUtility.h"
#include "Runtime/Camera/Culler.h"
#include "Runtime/Graphics/Transform.h"
#include "Runtime/Graphics/Texture2D.h"
#include "Runtime/Filters/Mesh/LodMesh.h"
#include "Runtime/Geometry/Intersection.h"
#include "Runtime/Dynamics/PhysicsManager.h"
#include <limits>
#include <vector>
#include "Runtime/Scripting/Scripting.h"

extern ColorRGBAf g_EditorCameraWireframeColor;
extern ColorRGBAf g_EditorCameraOverlayColor;
extern ColorRGBAf g_EditorCameraActiveColor;
extern ColorRGBAf g_EditorCameraOtherSelectedColor;


CSRAW

using UnityEngine;
using System.Runtime.CompilerServices;
using System.Collections;


namespace UnityEditor
{

// Helper functions for Scene View style 3D GUI
CLASS HandleUtility

	// Helper function for doing arrows.
	CSRAW static public float CalcLineTranslation (Vector2 src, Vector2 dest, Vector3 srcPosition, Vector3 constraintDir) {
		// Apply handle matrix
		srcPosition = Handles.matrix.MultiplyPoint (srcPosition);
		constraintDir = Handles.matrix.MultiplyVector (constraintDir);
		

		// The constrained direction is facing towards the camera, THATS BAD when the handle is close to the camera
		// The srcPosition  goes through to the other side of the camera 
		float invert = 1.0F;
		Vector3 cameraForward = Camera.current.transform.forward;
		if (Vector3.Dot(constraintDir, cameraForward) < 0.0F)
			invert = -1.0F;
					
		// Ok - Get the parametrization of the line
		// p1 = src position, p2 = p1 + ConstraintDir.
		// we then parametrise the perpendicular position of dest into the line (p1-p2)
		Vector3 cd = constraintDir;
		cd.y = -cd.y; 
		Camera cam = Camera.current;
		Vector2 p1 = cam.WorldToScreenPoint (srcPosition);
		Vector2 p2 = cam.WorldToScreenPoint (srcPosition + constraintDir * invert);
		Vector2 p3 = dest;
		Vector2 p4 = src;

		if (p1 == p2)
			return 0;

		p3.y = -p3.y;
		p4.y = -p4.y;
		float t0 = GetParametrization (p4, p1, p2);
		float t1 = GetParametrization (p3, p1, p2);
		
		float output = (t1 - t0) * invert;
		return output;
	}

	CSRAW internal static float GetParametrization (Vector2 x0, Vector2 x1, Vector2 x2) {
		return -(Vector2.Dot (x1 - x0, x2 - x1) / (x2 - x1).sqrMagnitude);
	}

	// Returns the parameter for the projection of the /point/ on the given line
	CSRAW public static float PointOnLineParameter(Vector3 point, Vector3 linePoint, Vector3 lineDirection)
	{
		return ( Vector3.Dot(lineDirection , (point - linePoint)) ) / lineDirection.sqrMagnitude;
	}

	// Project /point/ onto a line.
	CSRAW public static Vector3 ProjectPointLine (Vector3 point, Vector3 lineStart, Vector3 lineEnd) {
		Vector3 relativePoint = point - lineStart;
		Vector3 lineDirection = lineEnd - lineStart;
		float length = lineDirection.magnitude;
		Vector3 normalizedLineDirection = lineDirection;
		if (length > .000001f)
			normalizedLineDirection /= length;
		
		float dot = Vector3.Dot (normalizedLineDirection, relativePoint);
		dot = Mathf.Clamp (dot, 0.0F, length);
		
		return lineStart + normalizedLineDirection * dot;
	}
	
	// Calculate distance between a point and a line.
	CSRAW public static float DistancePointLine (Vector3 point, Vector3 lineStart, Vector3 lineEnd) {
		return Vector3.Magnitude (ProjectPointLine (point, lineStart, lineEnd) - point);
	}

	// Get standard acceleration for dragging values (RO).
	CSRAW static public float acceleration { get { return (Event.current.shift ? 4 : 1) * (Event.current.alt ? .25f : 1); } }

	// Get nice mouse delta to use for dragging a float value (RO).
	CSRAW static public float niceMouseDelta { get {
		Vector2 d = Event.current.delta;
		d.y = -d.y;
		
		// Decide which direction the mouse delta goes.
		// Problem is that when the user zooms horizontal and vertical, it can jitter back and forth.
		// So we only update from which axis we pick the sign if x and y 
		// movement is not very close to each other
		if (Mathf.Abs (Mathf.Abs (d.x) - Mathf.Abs (d.y)) / Mathf.Max (Mathf.Abs (d.x), Mathf.Abs (d.y)) > .1f)	{
			if (Mathf.Abs (d.x) > Mathf.Abs (d.y))
				s_UseYSign = false;
			else
				s_UseYSign = true;
		}

		if (s_UseYSign)
			return Mathf.Sign (d.y) * d.magnitude * acceleration;
		else
			return Mathf.Sign (d.x) * d.magnitude * acceleration;
	} }
	static bool s_UseYSign = false;

	// Get nice mouse delta to use for zooming (RO).
	CSRAW static public float niceMouseDeltaZoom { get {
		Vector2 d = -Event.current.delta;
		
		// Decide which direction the mouse delta goes.
		// Problem is that when the user zooms horizontal and vertical, it can jitter back and forth.
		// So we only update from which axis we pick the sign if x and y 
		// movement is not very close to each other
		if (Mathf.Abs (Mathf.Abs (d.x) - Mathf.Abs (d.y)) / Mathf.Max (Mathf.Abs (d.x), Mathf.Abs (d.y)) > .1f)	{
			if (Mathf.Abs (d.x) > Mathf.Abs (d.y))
				s_UseYSignZoom = false;
			else
				s_UseYSignZoom = true;
		}

		if (s_UseYSignZoom)
			return Mathf.Sign (d.y) * d.magnitude * acceleration;
		else
			return Mathf.Sign (d.x) * d.magnitude * acceleration;
	} }
	static bool s_UseYSignZoom = false;



	// Calculate distance between a point and a bezier
	CUSTOM public static float DistancePointBezier (Vector3 point, Vector3 startPosition, Vector3 endPosition, Vector3 startTangent, Vector3 endTangent) 
	{
		return DistancePointBezier (point, startPosition, endPosition, startTangent, endTangent);
	}

	// Pixel distance from mouse pointer to line.
	CSRAW public static float DistanceToLine (Vector3 p1, Vector3 p2) {
		p1 = WorldToGUIPoint (p1);
		p2 = WorldToGUIPoint (p2);
		
		Vector2 point = Event.current.mousePosition;
	
		float retval = DistancePointLine (point, p1, p2);
		if (retval < 0) retval = 0.0f;
		return retval;
	}
	
	// Pixel distance from mouse pointer to camera facing circle.
	CSRAW public static float DistanceToCircle (Vector3 position, float radius) {
		Vector2 screenCenter = WorldToGUIPoint (position);
		Camera cam = Camera.current;
		Vector2 screenEdge = Vector2.zero;
		if (cam) {
			screenEdge = WorldToGUIPoint (position+ cam.transform.right * radius);
			radius = (screenCenter - screenEdge).magnitude;
		}
		float dist = (screenCenter - Event.current.mousePosition).magnitude;
		if (dist < radius)
			return 0;
		return dist - radius;
	}
	
	// Pixel distance from mouse pointer to a rectangle on screen
	static Vector3[] points = {Vector3.zero, Vector3.zero, Vector3.zero, Vector3.zero, Vector3.zero};
	CSRAW public static float DistanceToRectangle  (Vector3 position, Quaternion rotation, float size){
		Vector3 sideways = rotation * new Vector3 (size, 0, 0);
		Vector3 up = rotation * new Vector3 (0, size, 0);
		points[0] = WorldToGUIPoint (position + sideways + up);
		points[1] = WorldToGUIPoint (position + sideways - up);
		points[2] = WorldToGUIPoint (position - sideways - up);
		points[3] = WorldToGUIPoint (position - sideways + up);
		points[4] = points[0];

		Vector2 pos = Event.current.mousePosition;
		bool oddNodes = false;
		int j = 4;	
		for (int i = 0; i < 5; i++) {
			if ((points[i].y > pos.y) != (points[j].y>pos.y))
			{
				if (pos.x < (points[j].x-points[i].x) * (pos.y-points[i].y) / (points[j].y-points[i].y) + points[i].x)
				{
					oddNodes = !oddNodes;
				}
			}
			j = i;
		}
		if(!oddNodes)
		{
			// Distance to closest edge (not so fast)
			float dist, closestDist = -1f;
			j = 1;
			for (int i = 0; i < 4; i++) {
				dist = DistancePointToLineSegment(pos, points[i], points[j++]);
				if(dist < closestDist || closestDist < 0)
					closestDist = dist;
			}
			return closestDist;
		}
		else
			return 0;
	}
	
	// Distance from a point /p/ in 2d to a line defined by two points /a/ and /b/
	CSRAW public static float DistancePointToLine(Vector2 p, Vector2 a, Vector2 b) 
	{
		return Mathf.Abs((b.x-a.x)*(a.y-p.y)-(a.x-p.x)*(b.y-a.y))/(b-a).magnitude;
	}
	
	// Distance from a point /p/ in 2d to a line segment defined by two points /a/ and /b/
	CSRAW public static float DistancePointToLineSegment (Vector2 p, Vector2 a, Vector2 b) 
	{
		float l2 = (b-a).sqrMagnitude;			// i.e. |b-a|^2 -  avoid a sqrt
		if (l2 == 0.0) 
			return (p-a).magnitude;				// a == b case
		float t = Vector2.Dot(p-a, b-a) / l2;
		if (t < 0.0)
			return (p-a).magnitude;				// Beyond the 'a' end of the segment
		else 
			if (t > 1.0)
				return (p-b).magnitude;			// Beyond the 'b' end of the segment
		Vector2 projection = a + t * (b - a);	// Projection falls on the segment
		return (p-projection).magnitude;
	}	
	
	// Pixel distance from mouse pointer to a 3D disc.
	CSRAW public static float DistanceToDisc (Vector3 center, Vector3 normal, float radius) {
		Vector3 tangent = Vector3.Cross (normal, Vector3.up);
		if (tangent.sqrMagnitude < .001f)
			tangent = Vector3.Cross (normal, Vector3.right);
		return DistanceToArc (center, normal, tangent, 360, radius);
	}	
		
	// Get the nearest 3D point.
	CSRAW public static Vector3 ClosestPointToDisc (Vector3 center, Vector3 normal, float radius) {
		Vector3 tangent = Vector3.Cross (normal, Vector3.up);
		if (tangent.sqrMagnitude < .001f)
			tangent = Vector3.Cross (normal, Vector3.right);
		return ClosestPointToArc (center, normal, tangent, 360, radius);
	}

	// Pixel distance from mouse pointer to a 3D section of a disc.
	CSRAW public static float DistanceToArc (Vector3 center, Vector3 normal, Vector3 from, float angle, float radius) {
		Vector3[] points = new Vector3[60];
		Handles.SetDiscSectionPoints (points, 60, center, normal, from, angle, radius);
		return DistanceToPolyLine (points);
	}
	
	// Get the nearest 3D point.
	CSRAW public static Vector3 ClosestPointToArc (Vector3 center, Vector3 normal, Vector3 from, float angle, float radius) {
		Vector3[] points = new Vector3[60];
		Handles.SetDiscSectionPoints (points, 60, center, normal, from, angle, radius);
		return ClosestPointToPolyLine (points);
	}
	
	// Pixel distance from mouse pointer to a polyline.
	CSRAW public static float DistanceToPolyLine (params Vector3[] points) {
		float dist = HandleUtility.DistanceToLine (points[0], points[1]);
		for (int i = 2; i < points.Length; i++) {
			float d = HandleUtility.DistanceToLine (points[i -1], points[i]);
			if (d < dist)
				dist = d;
		}
		return dist;
	}

	// Get the nearest 3D point.
	CSRAW public static Vector3 ClosestPointToPolyLine (params Vector3[] vertices) {
		float dist = HandleUtility.DistanceToLine (vertices[0], vertices[1]);
		int nearest = 0;// Which segment we're closest to
		for (int i = 2; i < vertices.Length; i++) {
			float d = HandleUtility.DistanceToLine (vertices[i -1], vertices[i]);
			if (d < dist) {
				dist = d;
				nearest = i - 1;
			}
		}

		Vector3 lineStart = vertices[nearest];
		Vector3 lineEnd = vertices[nearest + 1];
		
		Vector2 relativePoint = Event.current.mousePosition - WorldToGUIPoint (lineStart);
		Vector2 lineDirection = WorldToGUIPoint (lineEnd) - WorldToGUIPoint (lineStart);
		float length = lineDirection.magnitude;
		float dot = Vector3.Dot (lineDirection, relativePoint);
		if (length > .000001f)
			dot /= length * length;
		dot = Mathf.Clamp01 (dot);
		
		return Vector3.Lerp(lineStart, lineEnd, dot); 
	}


	// Record a distance measurement from a handle.
	CSRAW public static void AddControl (int controlId, float distance) {
		if (distance <= s_NearestDistance) {
			s_NearestDistance = distance;
			s_NearestControl = controlId;
		}
	}
	
	// Add the ID for a default control. This will be picked if nothing else is
	CSRAW public static void AddDefaultControl (int controlId) {
		AddControl (controlId, kPickDistance);
	}

	static int s_NearestControl;
	static float s_NearestDistance; 
	internal const float kPickDistance = 5.0f;
	// *undocumented*
	CSRAW public static int nearestControl { get { return s_NearestDistance <= kPickDistance ? s_NearestControl : 0; } set { s_NearestControl = value; } }

	CUSTOM internal static bool CameraNeedsToRenderIntoRT (Camera camera)
	{
		return camera->CalculateNeedsToRenderIntoRT ();
	}

	CSRAW
	static private void BeginHandles () {
		Handles.Init ();
		switch (Event.current.type) {
		case EventType.layout:
			s_NearestControl = 0;
			s_NearestDistance = kPickDistance;
			break;
		}
		Handles.lighting = true;
		Handles.color = Color.white;	
		Handles.Internal_SetCurrentCamera (null);
		EditorGUI.s_DelayedTextEditor.BeginGUI();
	}

	static private void SetViewInfo (Vector2 screenPosition) {
		GUIUtility.s_EditorScreenPointOffset = screenPosition;
	}

	static private void EndHandles () {
		EventType type = Event.current.type;
		if (type != EventType.Layout) {
			GUIUtility.s_HasKeyboardFocus = false;
			GUIUtility.s_EditorScreenPointOffset = Vector2.zero;
		}
		// Give the delayed text editor a chance to notice that it lost focus.
		EditorGUI.s_DelayedTextEditor.EndGUI(type);
	}

	const float kHandleSize = 80.0f;
	
	// Get world space size of a manipulator handle at given position.
	public static float GetHandleSize (Vector3 position) {
		Camera cam = Camera.current;
		position = Handles.matrix.MultiplyPoint (position);
		if (cam) {
			Transform tr = cam.transform;
			Vector3 camPos = tr.position;
			float distance = Vector3.Dot (position - camPos, tr.TransformDirection (new Vector3(0,0,1)));
			Vector3 screenPos = cam.WorldToScreenPoint (camPos + tr.TransformDirection (new Vector3 (0,0,distance)));
			Vector3 screenPos2 = cam.WorldToScreenPoint (camPos + tr.TransformDirection (new Vector3 (1,0,distance)));
			float screenDist = (screenPos - screenPos2).magnitude;
			return kHandleSize / Mathf.Max( screenDist, 0.0001f );
		} else {
			return 20.0f;
		}
	
	}
	
	// Convert world space point to a 2D GUI position.
	CSRAW public static Vector2 WorldToGUIPoint (Vector3 world) {
		world = Handles.matrix.MultiplyPoint (world);
		Camera cam = Camera.current;
		if (cam) {
			Vector2 pos = cam.WorldToScreenPoint (world);
			pos.y = Screen.height - pos.y;
			return GUIClip.Clip (pos);
		} else {
			return new Vector2 (world.x, world.y);
		}
	}

	// Convert 2D GUI position to a world space ray.
	CSRAW public static Ray GUIPointToWorldRay (Vector2 position) {
		if (!Camera.current) {
			Debug.LogError ("Unable to convert GUI point to world ray if a camera has not been set up!");
			return new Ray (Vector3.zero, Vector3.forward);
		}
		Vector2 screenPosition = GUIClip.Unclip (position);
		screenPosition.y = Screen.height - screenPosition.y;		// Convert to proper ScreenSpace
		Camera camera = Camera.current;
		return camera.ScreenPointToRay (new Vector2 (screenPosition.x, screenPosition.y));	
	}
	
	// Figure out a rectangle to display a 2D GUI element in 3D space.
	public static Rect WorldPointToSizedRect (Vector3 position, GUIContent content, GUIStyle style) {
		Vector2 screenpos = HandleUtility.WorldToGUIPoint (position);
		Vector2 size = style.CalcSize (content);
		Rect r = new Rect (screenpos.x, screenpos.y, size.x, size.y);
		switch (style.alignment) {
		case TextAnchor.UpperLeft:
			break;
		case TextAnchor.UpperCenter:	
			r.xMin -= r.width * .5f;
			break;
		case TextAnchor.UpperRight:	
			r.xMin -= r.width;
			break;
		case TextAnchor.MiddleLeft:
			r.yMin -= r.height * .5f;
			break;
		case TextAnchor.MiddleCenter:	
			r.xMin -= r.width * .5f;
			r.yMin -= r.height * .5f;
			break;
		case TextAnchor.MiddleRight:	
			r.xMin -= r.width;
			r.yMin -= r.height * .5f;
			break;
		case TextAnchor.LowerLeft:
			r.yMin -= r.height * .5f;
			break;
		case TextAnchor.LowerCenter:	
			r.xMin -= r.width * .5f;
			r.yMin -= r.height;
			break;
		case TextAnchor.LowerRight:	
			r.xMin -= r.width;
			r.yMin -= r.height;
			break;
		}
		return style.padding.Add (r);			
	}
    
    // Pick game object in specified rectangle
    CSRAW public static GameObject[] PickRectObjects (Rect rect)
    {
        return PickRectObjects(rect, true);
    }
    // *undocumented*
    CSRAW public static GameObject[] PickRectObjects (Rect rect, bool selectPrefabRootsOnly)
    {
        Camera cam = Camera.current;
        rect.x /= cam.pixelWidth;
        rect.width /= cam.pixelWidth;
        rect.y /= cam.pixelHeight;
        rect.height /= cam.pixelHeight;
        return Internal_PickRectObjects(cam, rect, selectPrefabRootsOnly);
    }

    CUSTOM static internal GameObject[] Internal_PickRectObjects (Camera cam, Rect rect, bool selectPrefabRoots)
    {
        std::set<GameObject*> retval;
        PickRectObjects(*cam, rect, &retval, selectPrefabRoots);
        int length = retval.size ();
		MonoArray* array = mono_array_new (mono_domain_get (), ScriptingClassFor(GameObject), length);

        int idx = 0;
        for (std::set<GameObject*>::iterator i = retval.begin(); i != retval.end(); i++)
			Scripting::SetScriptingArrayElement (array, idx++, Scripting::ScriptingWrapperFor (*i));
		return array;
    }
    
	CSRAW internal static bool FindNearestVertex (Vector2 screenPoint, Transform[] objectsToSearch, out Vector3 vertex) {
		Camera cam = Camera.current;
		screenPoint.y = cam.pixelRect.yMax - screenPoint.y;
		return Internal_FindNearestVertex (cam, screenPoint, objectsToSearch, ignoreRaySnapObjects, out vertex);
	}
	
	CUSTOM static private bool Internal_FindNearestVertex (Camera cam, Vector2 point, Transform[] objectsToSearch, Transform[] ignoreObjects, out Vector3 vertex) 
	{
		std::vector<Transform*> *transforms = NULL;
		if (objectsToSearch)
		{
			transforms = new std::vector<Transform*> ();
			MonoObjectArrayToVector (objectsToSearch, *transforms);
		}

		std::set<Transform*> *ignoreTransforms = NULL;
		if (ignoreObjects)
		{
			ignoreTransforms = new std::set<Transform*> ();
			MonoObjectArrayToSet (ignoreObjects, *ignoreTransforms);
		}

		bool retval = FindNearestVertex (transforms, ignoreTransforms, point, *cam, vertex);
		
		delete transforms;
		delete ignoreTransforms;
		
		return retval;
	}
	
	// Pick game object closest to specified position.
	CSRAW public static GameObject PickGameObject (Vector2 position, bool selectPrefabRoot) 
	{
		Camera cam = Camera.current;
		int layers = cam.cullingMask;
		position = GUIClip.Unclip (position);
		position.y = Screen.height - position.y - cam.pixelRect.yMin;

		GameObject picked = Internal_PickClosestGO (cam, layers, position);
		if (picked && selectPrefabRoot) 
		{
			PrefabType pickedType = PrefabUtility.GetPrefabType (picked);
			if (pickedType == PrefabType.PrefabInstance || pickedType == PrefabType.ModelPrefabInstance) 
			{
				GameObject prefabRoot = PrefabUtility.FindPrefabRoot (picked);
				Transform atc = Selection.activeTransform;
				GameObject selectionRoot = atc ? PrefabUtility.FindPrefabRoot (atc.gameObject) : null;
				if (prefabRoot == selectionRoot) 
					return picked;
				else
					return prefabRoot;
			}
		}
		return picked;
	}

	CUSTOM static internal GameObject Internal_PickClosestGO (Camera cam, int layers, Vector2 position) {
		GUIView *view = GUIView::GetCurrent ();
		if (view) {
			view->BeginCurrentContext ();
		} else {
			ErrorString ("Handles.PickGameObject called outside an editor OnGUI");
		}
		MonoObject* result = Scripting::ScriptingWrapperFor (PickClosestGO (*cam, layers, position));
		#if UNITY_WIN
		if (view)
			view->Repaint();
		#endif
		if (view)
			view->EndCurrentContext ();
		
		return result;
	}
	
	// The materials used to draw handles - Don't use unless you're Nicholas.
	// *undocumented*
	CSRAW public static Material handleMaterial { get {
		if (!s_HandleMaterial) {
			s_HandleMaterial = (Material)EditorGUIUtility.Load ("SceneView/Handles.mat");
		}
		return s_HandleMaterial;
	} }
	static Material s_HandleMaterial;

	CSRAW internal static Material handleWireMaterial { get {
		if (!s_HandleWireMaterial) {
			s_HandleWireMaterial = (Material)EditorGUIUtility.LoadRequired ("SceneView/HandleLines.mat");
			s_HandleWireMaterial2D = (Material)EditorGUIUtility.LoadRequired ("SceneView/2DHandleLines.mat");
		}
		return Camera.current ? s_HandleWireMaterial : s_HandleWireMaterial2D;
	} }
	static private Material s_HandleWireMaterial, s_HandleWireMaterial2D;
	
	/*CSRAW internal static Material handleIconMaterial { get {
		if (!s_HandleIconMaterial) {
			s_HandleIconMaterial = (Material)EditorGUIUtility.LoadRequired ("SceneView/HandleIcon.mat");
		}
		return s_HandleIconMaterial;
	} }
	static private Material s_HandleIconMaterial;
	*/

	// Store all camera settings
	CSRAW public static void PushCamera (Camera camera) {
		s_SavedCameras.Push (new SavedCamera (camera));
	}
	// Retrieve all camera settings
	CSRAW public static void PopCamera (Camera camera) {
		SavedCamera cam = (SavedCamera)s_SavedCameras.Pop ();
		cam.Restore (camera);
	}
	CSRAW
	CLASS private SavedCamera 
		CSRAW
		float near, far;
		Rect pixelRect;
		Vector3 pos;
		Quaternion rot;
		CameraClearFlags clearFlags;
		int cullingMask;
		float fov;
		float orthographicSize;
		bool isOrtho;
		
		internal SavedCamera (Camera source) {
			near = source.nearClipPlane;
			far = source.farClipPlane;
			pixelRect = source.pixelRect;
			pos = source.transform.position;
			rot = source.transform.rotation;
			clearFlags = source.clearFlags;
			cullingMask = source.cullingMask;
			fov = source.fieldOfView;
			orthographicSize = source.orthographicSize;
			isOrtho = source.orthographic;
		}
		
		internal void Restore (Camera dest) {
			dest.nearClipPlane = near;
			dest.farClipPlane = far;
			dest.pixelRect = pixelRect;
			dest.transform.position = pos;
			dest.transform.rotation = rot;
			dest.clearFlags = clearFlags;
			dest.fieldOfView = fov;
			dest.orthographicSize = orthographicSize;
			dest.orthographic = isOrtho;
			dest.cullingMask = cullingMask;
		}	
	END
	static private Stack s_SavedCameras = new Stack();
	
	// Objects to ignore when raysnapping (typically the objects being dragged by the handles)
	CSRAW internal static Transform[] ignoreRaySnapObjects = null;
	
	
	// Casts /ray/ against the scene.
	CSRAW public static object RaySnap (Ray ray) {
		RaycastHit[] hits = Physics.RaycastAll (ray, Mathf.Infinity, Camera.current.cullingMask);
		
		// We are not sure at this point if the hits returned from RaycastAll are sorted or not, so go through them all
		float nearestHitDist = Mathf.Infinity;
		int nearestHitIndex = -1;
		if (ignoreRaySnapObjects != null)
		{
			for (int i=0; i<hits.Length; i++)
			{
				if (!hits[i].collider.isTrigger && hits[i].distance < nearestHitDist)
				{
					bool ignore = false;
					for (int j=0; j<ignoreRaySnapObjects.Length; j++)
					{
						if (hits[i].transform == ignoreRaySnapObjects[j])
						{
							ignore = true;
							break;
						}
					}
					if (!ignore)
					{
						nearestHitDist = hits[i].distance;
						nearestHitIndex = i;
					}
				}
			}
		}
		else
		{
			for (int i=0; i<hits.Length; i++)
			{
				if (hits[i].distance < nearestHitDist)
				{
					nearestHitDist = hits[i].distance;
					nearestHitIndex = i;
				}
			}
		}
		
		if (nearestHitIndex >= 0)
			return hits[nearestHitIndex];
		return null;
	}
	
	CUSTOM internal static float CalcRayPlaceOffset (Transform[] objects, Vector3 normal)
	{
		std::vector<Transform*> gos;
		MonoObjectArrayToVector(objects, gos);
		std::vector<bool> used (gos.size());

		float offset = std::numeric_limits<float>::infinity ();
		bool foundAny = false;
		int mostProtudingBounds;
		do {
			float boundOff = offset;
			
			// Go over all objects in array, get the one with the most protuding bounding volume
			mostProtudingBounds = -1;
			for(int i = 0; i < gos.size(); i++) 
			{
				if (used[i])
					continue;

				MinMaxAABB minmax = CalculateObjectBounds (&gos[i]->GetGameObject(), true, &foundAny);
				if (!minmax.IsValid())
					continue;
					
				float d = Dot (normal, Vector3f (minmax.m_Min.x, minmax.m_Min.y, minmax.m_Min.z));
				if (d < boundOff) { boundOff = d; mostProtudingBounds = i; }

				d = Dot (normal, Vector3f (minmax.m_Max.x, minmax.m_Min.y, minmax.m_Min.z));
				if (d < boundOff) { boundOff = d; mostProtudingBounds = i; }

				d = Dot (normal, Vector3f (minmax.m_Min.x, minmax.m_Max.y, minmax.m_Min.z));
				if (d < boundOff) { boundOff = d; mostProtudingBounds = i; }

				d = Dot (normal, Vector3f (minmax.m_Max.x, minmax.m_Max.y, minmax.m_Min.z));
				if (d < boundOff) { boundOff = d; mostProtudingBounds = i; }

				d = Dot (normal, Vector3f (minmax.m_Min.x, minmax.m_Min.y, minmax.m_Max.z));
				if (d < boundOff) { boundOff = d; mostProtudingBounds = i; }

				d = Dot (normal, Vector3f (minmax.m_Max.x, minmax.m_Min.y, minmax.m_Max.z));
				if (d < boundOff) { boundOff = d; mostProtudingBounds = i; }

				d = Dot (normal, Vector3f (minmax.m_Min.x, minmax.m_Max.y, minmax.m_Max.z));
				if (d < boundOff) { boundOff = d; mostProtudingBounds = i; }

				d = Dot (normal, Vector3f (minmax.m_Max.x, minmax.m_Max.y, minmax.m_Max.z));
				if (d < boundOff) { boundOff = d; mostProtudingBounds = i; }
				
				used[i] = true;
			}
		
			// If we didn't find any bounding volumes, we return with -inf
			// This can only happen on the first run - if we found something there, this will have become true
			if (!foundAny)
				return std::numeric_limits<float>::infinity ();
				
			// If we found one that protudes, go over that and figure out its most protuding point
			if (mostProtudingBounds != -1)
			{
				float newOffset = CalculateRaySnapOffset (&gos[mostProtudingBounds]->GetGameObject(), normal);
				if (newOffset < offset)
					offset = newOffset;
			}
		} while (mostProtudingBounds != -1);		
		
		return offset;
	}

	// Repaint the current view
	CSRAW public static void Repaint () {
		Internal_Repaint ();
	}

	CUSTOM private static void Internal_Repaint () {
		GUIView *view = GUIView::GetCurrent ();
		if (view) {
			view->RequestRepaint ();
		} else {
			ErrorString ("Handles.Repaint called outside an editor OnGUI");
		}
	}
	
	// Test a mesh for intersection agains a ray
	CUSTOM internal static bool IntersectRayMesh (Ray ray, Mesh mesh, Matrix4x4 matrix, out RaycastHit hit)
	{
		Vector3f v1 = matrix.MultiplyPoint3 (ray.GetPoint (0));
		Vector3f v2 = matrix.MultiplyPoint3 (ray.GetPoint (1));
//		Ray convertedRay (v1, Normalize (v2 - v1));
		
		Mesh *m = mesh;
		int vertexCount = mesh->GetVertexCount ();
		
		dynamic_array<Vector3f> verts;
		verts.resize_uninitialized (vertexCount);
		m->ExtractVertexArray (verts.data ());
		
		Mesh::TemporaryIndexContainer triangles;
		m->GetTriangles(triangles);
		float minT = std::numeric_limits<float>::infinity ();
		float t = 0;
		int result = -1;
		
		for (int i = 0; i < triangles.size(); i+=3)
		{
			Vector3f p1 = matrix.MultiplyPoint3 (verts[triangles[i]]);
			Vector3f p2 = matrix.MultiplyPoint3 (verts[triangles[i + 1]]);
			Vector3f p3 = matrix.MultiplyPoint3 (verts[triangles[i + 2]]);
			
			if (IntersectRayTriangle (ray, p1, p2, p3, &t) && t > 0 && t < minT)
			{
				minT = t;
				result = i;
			}
		}
		
		if (result == -1)
			return false;
		
		hit->point = ray.GetPoint (minT);
		hit->distance = minT;
		hit->faceID = result / 3;
		hit->collider = NULL;
		
		int index[] = { triangles[result], triangles[result + 1], triangles[result + 2] };
		Vector3f coords[] = { matrix.MultiplyPoint3 (verts[index[0]]), matrix.MultiplyPoint3 (verts[index[1]]), matrix.MultiplyPoint3 (verts[index[2]]) };
		Vector3f bary = BarycentricCoordinates3DTriangle (coords, hit->point);
		hit->uv = Vector2f (bary.x, bary.y);
		
		if (m->IsAvailable (kShaderChannelNormal))
		{
			dynamic_array<Vector3f> normals;
			normals.resize_uninitialized (vertexCount);
			m->ExtractNormalArray (normals.data ());
			Matrix4x4f mat2 = matrix;
			mat2.Invert_Full().Transpose ();
			hit->normal = matrix.MultiplyVector3 (normals[index[0]] * bary.x + normals[index[1]] * bary.y + normals[index[2]] * bary.z);
		}
		return true;
	}

END

CSRAW }
