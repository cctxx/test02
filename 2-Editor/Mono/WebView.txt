C++RAW

#include "UnityPrefix.h"
#include "Editor/Src/WebViewWrapper.h"
#include "Editor/Src/WebViewScripting.h"
#include "Runtime/Misc/InputEvent.h"
#include "Runtime/Scripting/Scripting.h"
#include "Runtime/Scripting/ScriptingObjectWithIntPtrField.h"

CSRAW
using System;
using UnityEngine;
using Object=UnityEngine.Object;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Collections;
using System.Collections.Generic;
using UnityEngineInternal;
using UnityEditorInternal;

namespace UnityEditor
{


// Render web content in Editor GUI.

[StructLayout (LayoutKind.Sequential)]
CLASS internal WebView : ScriptableObject
	CSRAW [SerializeField]
	private MonoReloadableIntPtr webViewWrapper;

	C++RAW
 inline WebViewWrapper* GetWebViewChecked (MonoObject* self)
	{
		#if ENABLE_ASSET_STORE
		WebViewWrapper* obj = ExtractMonoObjectData<MonoWebViewData> (self).m_WrapperPtr;
		if (obj)
			return obj;
		else
		{
			Scripting::RaiseNullException("WebView class has already been disposed.");
			return NULL;
		}	
		#else
		return NULL;
		#endif
	}
	
	C++RAW
 
	#define GET GetWebViewChecked (self)

	//*undocumented*
	CSRAW public void OnDestroy ()
	{
		DestroyWebView();
	}
	
	//*undocumented*
	THREAD_SAFE
	CUSTOM private void DestroyWebView() 
	{
		#if ENABLE_ASSET_STORE
		if ( ExtractMonoObjectData<MonoWebViewData> (self).m_WrapperPtr)
		{
			delete ExtractMonoObjectData<MonoWebViewData> (self).m_WrapperPtr;
			ExtractMonoObjectData<MonoWebViewData> (self).m_WrapperPtr = NULL;
		}
		#endif
	}

	//*undocumented*
	CUSTOM void InitWebView( int width, int height, bool showResizeHandle ) {
		#if ENABLE_ASSET_STORE
		ExtractMonoObjectData<MonoWebViewData> (self).m_WrapperPtr = new WebViewWrapper(width, height, showResizeHandle );
		#endif
	}
	
	CUSTOM void LoadURL ( string url ) {
		string cpp_string = url;
		GET->LoadURL(cpp_string);
	}

	CUSTOM void LoadFile ( string path ) {
		string cpp_string = path;
		GET->LoadFile(cpp_string);
	}
	
	CSRAW public WebView (int width, int height, bool showResizeHandle  ) {
		InitWebView(width, height, showResizeHandle);
	}

	CSRAW public WebView (int width, int height, string url) {
		InitWebView(width, height, false);
		LoadURL(url);
	}

	CUSTOM_PROP internal Texture2D texture { GET->UpdateTexture(); return Scripting::ScriptingWrapperFor (GET->m_TargetTexture); }
	
	CSRAW public static implicit operator bool (WebView exists)
	{
		return exists != null && !exists.IntPtrIsNull ();
	}
	
	CUSTOM private bool IntPtrIsNull() 
	{
		return GET == NULL;
	}
		
	CUSTOM public void SetDelegateObject(ScriptableObject value) 
	{
		GET->SetDelegateMonoObject( value ); 
	}
	
	CUSTOM void SetWebkitControlsGlobalLocation(int x, int y)
	{
		GET->SetWebkitControlsGlobalLocation(x,y);
	}
	
	CUSTOM internal void Resize( int width, int height ) { GET->Resize(width, height); }
	CUSTOM internal void InjectMouseDown( int x, int y, int button, int clickCount )
	{
		GET->InjectMouseDown( x, y, button, clickCount );
	}

	CUSTOM internal void Cut ()
	{
		GET->Cut();
	}

	CUSTOM internal void Copy ()
	{
		GET->Copy();
	}

	CUSTOM internal void Paste ()
	{
		GET->Paste();
	}

	CUSTOM internal void SelectAll ()
	{
		GET->SelectAll();
	}

	CUSTOM internal void InjectMouseUp( int x, int y, int button, int clickCount )
	{
		GET->InjectMouseUp( x, y, button, clickCount );
	}

	CUSTOM internal void InjectMouseMove( int x, int y )
	{
		GET->InjectMouseMove( x, y );
	}

	CUSTOM internal void InjectMouseDrag( int x, int y, int button )
	{
		GET->InjectMouseDrag( x, y, button );
	}
	CUSTOM internal void InjectScrollWheel( int x, int y, Vector2 delta )
	{
		GET->InjectMouseWheel( x, y, delta.x, delta.y );
	}

	CUSTOM internal void InjectKeyboardEvent( Event e )
	{
		#if UNITY_WIN
		GET->InjectKeyboardEvent( e.object );
		#else
		GET->InjectKeyboardEvent( WebViewWrapper::GetCurrentKeyboardEvent() );
		#endif
	}
	
	//*undocumented*
	CUSTOM public void Focus()
	{
		GET->Focus();
	}
	
	//*undocumented*
	CUSTOM public void UnFocus()
	{
		GET->UnFocus();
	}
	
	CSRAW internal bool InjectEvent(Event e, Rect position)
	{
		switch( e.type )
		{
			case EventType.MouseDown:
				InjectMouseDown( (int)(e.mousePosition.x-position.x), (int)( e.mousePosition.y-position.y), (Application.platform == RuntimePlatform.OSXEditor && e.control && e.button == 0) ? 1 :  e.button, e.clickCount);
				break;
			case EventType.MouseUp:
				InjectMouseUp( (int)(e.mousePosition.x-position.x), (int)( e.mousePosition.y-position.y), (Application.platform == RuntimePlatform.OSXEditor && e.control && e.button == 0) ? 1 :  e.button, e.clickCount);
				break;
			case EventType.MouseMove:
				InjectMouseMove( (int)(e.mousePosition.x-position.x), (int)( e.mousePosition.y-position.y) );
				break;
			case EventType.MouseDrag:
				InjectMouseDrag( (int)(e.mousePosition.x-position.x), (int)( e.mousePosition.y-position.y), e.button );
				break;
			case EventType.ScrollWheel:
				InjectScrollWheel( (int)(e.mousePosition.x-position.x), (int)( e.mousePosition.y-position.y), e.delta );
				break;
			case EventType.KeyDown:
				InjectKeyboardEvent( e );
				break;
			case EventType.KeyUp:
				goto case EventType.KeyDown;
			default:
				//Debug.Log("Unhandled event type" + e.type.ToString());
				return false;
		}
		// In some cases such as holding the mouse down over a scroll bar, the webkit will loop capturing all events directly until the
		// mouse button is released, Event.current will be invalid upon returning from InjectXX and we will have to abort the current OnGUI by
		// calling GUIUtility.ExitGUI()
		if (Event.current == null)   {
			//Debug.Log("event.current is null");
			
			GUIUtility.ExitGUI ();
		}
		return true;
	}
	
	// Returns a representation of the main window javascript object. Use this to interface with javascript code inside the browser view
	CUSTOM_PROP public WebScriptObject windowScriptObject
	{ 
		MonoObject* obj = mono_object_new (mono_domain_get(), GetMonoManager().GetBuiltinEditorMonoClass("WebScriptObject"));
		 ExtractMonoObjectData<WebScriptObjectWrapper*> (obj) = GET->GetWindowScriptObject();
		return obj;
	}
	
	// Query this property inside Update() or OnInspectorUpdate() to ensure that any changes in the web view are updated on-screen.
	
	CUSTOM_PROP public bool needsRepaint { return GET->IsDirty(); }
	
	
	// Call this method inside your Window's OnGUI function. Ensures that any GUI events are forwarded to the web view and that it is rendered on-screen.
	CSRAW public void DoGUI(Rect position)
	{
		int id = GUIUtility.GetControlID (GetHashCode(), FocusType.Native, position);
		switch (Event.current.type) 
		{
			case EventType.Layout:
				Resize((int)position.width, (int)position.height);
				break;
			case EventType.Repaint:
				GUI.DrawTexture(position, texture);
				break;
			case EventType.MouseDown:
				//HACK: to make mouse work on windows (read more in WebViewWrapper.h)
				//... and to make native pop-up menues show up in the correct location
				Vector2 v = GUIUtility.GUIToScreenPoint(new Vector2(position.x, position.y));
				SetWebkitControlsGlobalLocation((int)v.x, (int)v.y);
			
				// If the mouse is inside the button, we say that we're the hot control
				if (position.Contains (Event.current.mousePosition)) 
					GUIUtility.hotControl = id;
				
				goto default;
			case EventType.MouseUp:
				if (GUIUtility.hotControl == id) 
					GUIUtility.hotControl = 0;
				
				goto default;
			case EventType.MouseDrag:
				if (GUIUtility.hotControl == id)
					Event.current.Use ();
				goto default;
			case EventType.ValidateCommand:
				switch (Event.current.commandName) {
					case "Cut":
					case "Copy":
					case "Paste":
					case "SelectAll":
				/*	Need to integrate with UndoManager.
					case "UndoRedoPerformed":*/
						Event.current.Use();
						break;
				}
				break;
			case EventType.ExecuteCommand:
				switch (Event.current.commandName) {
					case "Cut":
						Cut();
						break;
					case "Copy":
						Copy();
						break;
					case "Paste":
						Paste();
						break;
					case "SelectAll":
						SelectAll();
						break;
				/*	Need to integrate with UndoManager.
					case "UndoRedoPerformed":
						Undo();
						break;*/
				}
				break;
			default:
				if (InjectEvent(Event.current, position))
					Event.current.Use();
				else if (GUIUtility.hotControl == id) 
					GUIUtility.hotControl = 0;
				
				break;
		}
	}
	
	// Call this method instead of DoGUI when using GUILayout to arrange the layout of the window
	CSRAW public void DoGUILayout (params GUILayoutOption[] options)
	{
		Rect r = GUILayoutUtility.GetRect(new GUIContent(),EditorStyles.textField, options) ;
		if (Event.current.type != EventType.Layout  && Event.current.type != EventType.MouseUp)
		{
			Resize((int)r.width, (int)r.height);
			DoGUI(r);
		}
		
	}
	
	C++RAW
 
	#undef GET
	
	// Tells the web view to navigate to the previously visited page
	CSRAW public void Back()
	{
		windowScriptObject.EvalJavaScript("history.back();");
	}
	
	// Tells the web view to navigate to the next page in the browser history
	CSRAW public void Forward()
	{
		windowScriptObject.EvalJavaScript("history.forward();");
	}

	// Reloads the current URL
	CSRAW public void Reload() 
	{
		windowScriptObject.EvalJavaScript("document.location.reload(true);");
		
	}

	// Called when the web view begins loading a new page.
	CSNONE void OnBeginNavigation( string url, string frame);
	// Called when the web view begins loading a resource.
	CSNONE void OnBeginLoading( string url, string frame, string mimeType);
	// Called when the web view has finished loading all components of a web page.
	CSNONE void OnFinishLoading( );
	
	// Called when the title of the current web page has changed. Use this to show the page title somewhere such as in the window title
	CSNONE void OnReceiveTitle( string newTitle, string frame);
	
	
	// Called when opening an URL that would have resulted in opening a new window in a normal browser. 
	CSNONE void OnOpenExternalLink( string url, string source );

END

CSRAW
[StructLayout (LayoutKind.Sequential)]
CLASS internal WebScriptObject : IDisposable
	CSRAW
	private IntPtr webScriptObjectWrapper;

	C++RAW
 inline WebScriptObjectWrapper* GetScriptObjectChecked (MonoObject* self)
	{
		WebScriptObjectWrapper* obj =  ExtractMonoObjectData<WebScriptObjectWrapper*> (self);
		if (obj)
			return obj;
		else
		{
			Scripting::RaiseNullException(" WebScriptObject class has already been disposed.");
			return NULL;
		}	
	}
	
	C++RAW
 
	#define GET GetScriptObjectChecked (self)

	//*undocumented*
	CSRAW public void Dispose ()
	{
		DestroyScriptObject();
	}

	CSRAW ~WebScriptObject ()
	{
		DestroyScriptObject();
	}

	//*undocumented*
	THREAD_SAFE
	CUSTOM private void DestroyScriptObject() 
	{
		if ( ExtractMonoObjectData<WebScriptObjectWrapper*> (self))
		{
			ExtractMonoObjectData<WebScriptObjectWrapper*> (self)->DeleteOnMainThread();
			ExtractMonoObjectData<WebScriptObjectWrapper*> (self) = NULL;
		}
	}

	CUSTOM public object MonoObjectFromJSON(string json) 
	{
		return GET->MonoObjectFromJSON(json);
	}

	CUSTOM public WebScriptObject EvalJavaScript(string script) 
	{
		return GET->EvalJavaScript(script);
	}

	CUSTOM public WebScriptObject InvokeMethodArray(string method, object[] args) 
	{
		return GET->InvokeMethod(method, args);
	}

	CSRAW public WebScriptObject InvokeMethod(string method, params object[] args) 
	{
		return InvokeMethodArray(method, args);
	}
	
	CSRAW public WebScriptObject Invoke(params object[] args) 
	{
		object[] extendedArgs = new object[args.Length+1];
		args.CopyTo(extendedArgs, 1);
		extendedArgs[0]=this;
		return InvokeMethodArray("call", extendedArgs);
	}
	
	CUSTOM private WebScriptObject Internal_GetKey(string key) 
	{
		return GET->GetKey(key);
	}

	CUSTOM private void Internal_SetKey(string key, object value) 
	{
		GET->SetKey(key, value);
	}

	CUSTOM public void Remove(string key) 
	{
		GET->RemoveKey(key);
	}

	CUSTOM private WebScriptObject Internal_GetIndex(int i ) 
	{
		return GET->GetIndex(i);
	}

	CUSTOM private void Internal_SetIndex(int i, object value) 
	{
		GET->SetIndex(i, value);
	}

	
	CSRAW public WebScriptObject Get(int key)
	{
		return Internal_GetIndex(key);
	}
	
	CSRAW public WebScriptObject Get(string key)
	{
		WebScriptObject value = this;
		foreach( string part in key.Split('.') ) 
		{
			value = value.Internal_GetKey(part);
			if (value == null)
				break;
		}
		return value;
	}

	CSRAW public T Get<T>(int key)
	{
		return Internal_GetIndex(key).Convert<T>();
	}
	
	CSRAW public T Get<T>(string key)
	{
		return Get<WebScriptObject>(key).Convert<T>();
	}
	
	CSRAW public void Set<T>(int key, T value)
	{
		Internal_SetIndex(key, value);
	}
	
	CSRAW public void Set<T>(string key, T value)
	{
		Internal_SetKey(key, value);
	}
	
	CUSTOM private object ConvertToType(Type t) 
	{
		MonoType* type = ExtractMonoObjectData<MonoType*> (t);
		return GET->ToMonoType(type);
	}
	
	CUSTOM private bool IsValid() 
	{
		return ExtractMonoObjectData<WebScriptObjectWrapper*> (self)?true:false;
	}
	
	CSRAW public T Convert<T>() 
	{
		return (T)ConvertToType(typeof(T));
	}
	
	CSRAW public static implicit operator bool (WebScriptObject o)
	{
		if (o == null || ! o.IsValid())
			return false;
		return o.Convert<bool>();
	}
	
	CSRAW public static implicit operator int (WebScriptObject o)
	{
		return o.Convert<int>();
	}
	
	CSRAW public static implicit operator float (WebScriptObject o)
	{
		return o.Convert<float>();
	}
	
	CSRAW public static implicit operator double (WebScriptObject o)
	{
		return o.Convert<double>();
	}
	
	CSRAW public static implicit operator string (WebScriptObject o)
	{
		if (o == null || ! o.IsValid())
			return "";
		return o.ToString();
	}

	CSRAW public string GetAsJSON( string key, int indent = 0) {
		return Internal_GetKey( key ).ToJSON(indent);
	}

	CSRAW public string GetAsJSON( int i, int indent = 0  ) {
		return Internal_GetIndex( i ).ToJSON(indent);
	}

	CSRAW public void SetFromJSON( string key, string value ) {
		Internal_SetKey( key, this.ParseJSON(value) );
	}

	CSRAW public void SetFromJSON( int i, string value ) {
		Internal_SetIndex( i, this.ParseJSON(value) );
	}

	CUSTOM public string ToJSON(int indent = 0) 
	{
		return scripting_string_new(GET->ToJSON(indent));
	}

	CUSTOM public override string ToString()
	{
		return scripting_string_new(GET->ToString());
	}
	
	CUSTOM public WebScriptObject ParseJSON( string json )
	{
		return GET->MonoObjectFromJSON( json );
	}

END

C++RAW
#undef GET

CSRAW }
