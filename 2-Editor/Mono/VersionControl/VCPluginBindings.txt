C++RAW

#include "UnityPrefix.h"
#include "Runtime/Mono/MonoBehaviour.h"
#include "Runtime/Scripting/ScriptingExportUtility.h"
#include "Runtime/Scripting/Backend/ScriptingTypeRegistry.h"
#include "Runtime/Scripting/Backend/ScriptingBackendApi.h"
#include "Editor/Src/VersionControl/VCPlugin.h"
#include "Runtime/Allocator/MemoryMacros.h"

CSRAW
using System;
using UnityEngine;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace UnityEditor.VersionControl
{
//*undocumented* 
CLASS ConfigField
	CSRAW 
	IntPtr m_thisDummy;
	string m_guid;

	C++RAW

	#define SELF ExtractMonoObjectData<VCConfigField*>(self)
	#define GET(x) ExtractMonoObjectData<VCConfigField*>(x)

	//*undocumented
	THREAD_SAFE
	CUSTOM public void Dispose ()
	{
		UNITY_DELETE(SELF, kMemVersionControl);
		SELF = NULL;
	}

	CSRAW
	~ConfigField()
	{
		Dispose ();
	}


	CUSTOM_PROP string name { return scripting_string_new(SELF->GetName()); }
	CUSTOM_PROP string label { return scripting_string_new(SELF->GetLabel()); }
	CUSTOM_PROP string description { return scripting_string_new(SELF->GetDescription()); }
	CUSTOM_PROP bool isRequired { return SELF->IsRequired(); }
	CUSTOM_PROP bool isPassword { return SELF->IsPassword(); }
	
	C++RAW
 
	#undef SELF
	#undef GET
END

//*undocumented* 
CLASS Plugin
	CSRAW IntPtr m_thisDummy;
	string m_guid;

	C++RAW

	#define SELF ExtractMonoObjectData<VCPlugin*>(self)
	#define GET(x) ExtractMonoObjectData<VCPlugin*>(x)

	//*undocumented
	THREAD_SAFE
	CUSTOM public void Dispose ()
	{
		UNITY_DELETE(SELF, kMemVersionControl);
		SELF = NULL;
	}

	CSRAW
	~Plugin()
	{
		Dispose ();
	}


	CUSTOM_PROP static Plugin[] availablePlugins
	{
		VCPlugins plugins;
		VCPlugin::ScanAvailablePlugins(plugins);
				
		ScriptingClass* elementType = GetMonoManager ().GetMonoClass ("Plugin", "UnityEditor.VersionControl");
		ScriptingArray* array = mono_array_new(mono_domain_get(), elementType, plugins.size());
	
		int j = 0;
		for (VCPlugins::const_iterator i = plugins.begin(); i != plugins.end(); ++i, ++j)
		{
			// Create mono VCPlugin and hook up with our cpp version
			// We create the mono object but we do not call the constructor
			MonoObject* monoObj = scripting_object_new(GetScriptingTypeRegistry().GetType("UnityEditor.VersionControl","Plugin"));
			
			ExtractMonoObjectData<VCPlugin*>(monoObj) = UNITY_NEW(VCPlugin, kMemVersionControl) (i->second);
			Scripting::SetScriptingArrayElement(array, j, monoObj);
		}
		return array;
	}

	CUSTOM_PROP string name {return scripting_string_new(SELF->GetName());}

	CUSTOM_PROP ConfigField[] configFields 
	{
		VCConfigFields fields = SELF->GetConfigFields();
		ScriptingClass* elementType = GetMonoManager ().GetMonoClass ("ConfigField", "UnityEditor.VersionControl");
		ScriptingArray* array = mono_array_new(mono_domain_get(), elementType, fields.size());

		int j = 0;
		for (VCConfigFields::const_iterator i = fields.begin(); i != fields.end(); ++i, ++j)
		{
			// Create mono VCConfigField and hook up with our cpp version
			// We create the mono object but we do not call the constructor
			MonoObject* monoVCCF = scripting_object_new(GetScriptingTypeRegistry().GetType("UnityEditor.VersionControl","ConfigField"));
			
			ExtractMonoObjectData<VCConfigField*>(monoVCCF) = UNITY_NEW(VCConfigField, kMemVersionControl) (*i);
			Scripting::SetScriptingArrayElement(array, j, monoVCCF);
		}
		return array;
	}
	
	C++RAW
 
	#undef SELF
	#undef GET
END

CSRAW
}
