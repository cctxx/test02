C++RAW

#include "UnityPrefix.h"
#include "Runtime/Mono/MonoBehaviour.h"
#include "Runtime/Scripting/ScriptingExportUtility.h"
#include "Runtime/Scripting/Backend/ScriptingTypeRegistry.h"
#include "Runtime/Scripting/Backend/ScriptingBackendApi.h"
#include "Runtime/Graphics/Texture2D.h"

#include "Editor/Src/VersionControl/VCAsset.h"
#include "Editor/SRc/VersionControl/VCCache.h"
#include "Editor/Src/VersionControl/VCChangeSet.h"
#include "Editor/Src/VersionControl/VCProvider.h"
#include "Editor/Src/VersionControl/VCTask.h"
#include "Runtime/Allocator/MemoryMacros.h"

CSRAW
using System;
using UnityEngine;
using UnityEditor;
using Object=UnityEngine.Object;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Collections;
using System.Collections.Generic;

namespace UnityEditor.VersionControl
{

// Keep internal and undocumented until we expose more functionality
//*undocumented
CLASS public Provider

	CUSTOM_PROP static bool enabled 
	{
		return GetVCProvider().Enabled();
	}

	CUSTOM_PROP static bool isActive
	{
		return GetVCProvider().IsActive();
	}

	//*undocumented*
	CUSTOM_PROP static bool requiresNetwork
	{
		return GetVCProvider().GetActiveTraits().requiresNetwork;
	}

	//*undocumented*
	CUSTOM_PROP static bool hasChangelistSupport
	{
		return GetVCProvider().GetActiveTraits().enablesChangelists;
	}

	//*undocumented*
	CUSTOM_PROP static bool isVersioningFolders
	{
		return GetVCProvider().GetActiveTraits().enablesVersioningFolders;
	}

	CUSTOM_PROP static OnlineState onlineState
	{
		return GetVCProvider().GetOnlineState();
	}

	CUSTOM_PROP static string offlineReason
	{
		return scripting_string_new(GetVCProvider().OfflineReason());
	}

	CUSTOM_PROP static Task activeTask
	{
		VCTask* task = GetVCProvider().GetActiveTask();
		if (task)
			return CreateManagedTask(task);
		else
			return NULL;
	}

	//*undocumented*
	CUSTOM_PROP internal static Texture2D overlayAtlas
	{
		return Scripting::ScriptingWrapperFor(GetVCProvider().GetOverlayAtlas());
	}

	//*undocumented*
	CUSTOM internal static Rect GetAtlasRectForState(int state)
	{
		return GetVCProvider().GetAtlasRectForState(static_cast<States>(state));
	}

	CUSTOM static Plugin GetActivePlugin()
	{
		VCPlugin* plugin = GetVCProvider().GetActivePlugin();
		if (plugin == NULL)
			return NULL;
	
		MonoObject* monoObj = scripting_object_new(GetScriptingTypeRegistry().GetType("UnityEditor.VersionControl","Plugin"));
		ExtractMonoObjectData<VCPlugin*>(monoObj) = UNITY_NEW(VCPlugin, kMemVersionControl) (*plugin);

		return monoObj;
	}

	CUSTOM static ConfigField[] GetActiveConfigFields()
	{
		const VCConfigFields& fields = GetVCProvider().GetActiveConfigFields();

		ScriptingClass* elementType = GetMonoManager ().GetMonoClass ("ConfigField", "UnityEditor.VersionControl");
		ScriptingArray* array = mono_array_new(mono_domain_get(), elementType, fields.size());

		int j = 0;
		for (VCConfigFields::const_iterator i = fields.begin(); i != fields.end(); ++i, ++j)
		{
			// Create mono VCConfigField and hook up with our cpp version
			// We create the mono object but we do not call the constructor
			MonoObject* monoVCCF = scripting_object_new(GetScriptingTypeRegistry().GetType("UnityEditor.VersionControl","ConfigField"));
			
			ExtractMonoObjectData<VCConfigField*>(monoVCCF) = UNITY_NEW(VCConfigField, kMemVersionControl) (*i);
			Scripting::SetScriptingArrayElement(array, j, monoVCCF);
		}
		return array;
	}
	
	//*undocumented*
	CUSTOM internal static bool IsCustomCommandEnabled(string name)
	{
		return GetVCProvider().IsCustomCommandEnabled(name);
	}
	
	//*undocumented*
	CUSTOM_PROP internal static CustomCommand[] customCommands { return GetVCProvider().GetMonoCustomCommands(); }
	
	C++RAW

	static void MonoVCAssetArrayToCpp(ScriptingArray* assets, VCAssetList& list)
	{
		int size = GetScriptingArraySize(assets);
		for (int i=0;i<size;i++)
		{
			ScriptingObject* o = Scripting::GetScriptingArrayElement<ScriptingObject*>(assets,i);
			VCAsset* asset = ExtractMonoObjectData<VCAsset*>(o);
			list.push_back(*asset);
		}
	}

	static void MonoVCChangeSetArrayToCpp(ScriptingArray* changesets, VCChangeSets& list)
	{
		int size = GetScriptingArraySize(changesets);
		for (int i=0;i<size;i++)
		{
			ScriptingObject* o = Scripting::GetScriptingArrayElement<ScriptingObject*>(changesets,i);
			VCChangeSet cl(*ExtractMonoObjectData<VCChangeSet*>(o));
			list.push_back(cl);
		}
	}

	//*Undocumented
	CUSTOM private static Asset Internal_CacheStatus(string assetPath)
 	{
		VCAsset asset;
		
		if (GetVCCache().GetAssetByPath(assetPath, asset, false))
		{
			MonoObject* monoAsset = scripting_object_new(GetScriptingTypeRegistry().GetType("UnityEditor.VersionControl", "Asset"));
			ExtractMonoObjectData<VCAsset*>(monoAsset) = UNITY_NEW(VCAsset, kMemVersionControl) (asset);
			return monoAsset;
		}
		else
		{
			return NULL;
		}
 	}

	//*Undocumented
	CUSTOM private static Task Internal_Status(Asset[] assets, bool recursively)
 	{
 		VCAssetList list;
		MonoVCAssetArrayToCpp(assets, list);
 		return CreateManagedTask(GetVCProvider().Status(list, recursively));
 	}

	//*undocumented
	CUSTOM private static Task Internal_StatusStrings(string[] assetsProjectPaths, bool recursively)
	{
		VCAssetList list;
		int size = GetScriptingArraySize(assetsProjectPaths);
		for (int i = 0; i < size; i++)
		{
			ScriptingString* o = Scripting::GetScriptingArrayElement<ScriptingString*>(assetsProjectPaths,i);
			VCAsset asset;
			asset.SetPath(scripting_cpp_string_for(o));
			list.push_back(asset);
		}

		return CreateManagedTask(GetVCProvider().Status(list, recursively));
	}

	//*undocumented
	CUSTOM private static Task Internal_StatusAbsolutePath(string assetPath)
	{
		VCAssetList list;
		VCAsset as(assetPath);
		list.push_back(as);
		return CreateManagedTask(GetVCProvider().Status(list, false));
	}

	//*undocumented
	CUSTOM private static bool Internal_CheckoutIsValid(Asset[] assets)
	{
		VCAssetList list;
		MonoVCAssetArrayToCpp(assets, list);
		return GetVCProvider().CheckoutIsValid(list);
	}

	CUSTOM private static Task Internal_Checkout(Asset[] assets, CheckoutMode mode)
	{
		VCAssetList list;
		MonoVCAssetArrayToCpp(assets, list);
		return CreateManagedTask(GetVCProvider().Checkout(list, mode));
	}

	CUSTOM private static Task Internal_CheckoutStrings(string[] assets, CheckoutMode mode)
	{
		// FIXME: The state of the created vcassets is wrong and checkout will not be allowed in vcinterface.cpp
		VCAssetList list;
		int size = GetScriptingArraySize(assets);
		for (int i = 0; i < size; i++)
		{
			ScriptingString* o = Scripting::GetScriptingArrayElement<ScriptingString*>(assets,i);
			VCAsset asset;
			asset.SetPath(scripting_cpp_string_for(o));
			list.push_back(asset);
		}

		return CreateManagedTask(GetVCProvider().Checkout(list, mode));
	}
	
	CUSTOM private static bool Internal_PromptAndCheckoutIfNeeded(string[] assets, string promptIfCheckoutIsNeeded)
	{
		// FIXME: The state of the created vcassets is wrong and checkout will not be allowed in vcinterface.cpp
		VCAssetList list;
		int size = GetScriptingArraySize(assets);
		for (int i = 0; i < size; i++)
		{
			ScriptingString* o = Scripting::GetScriptingArrayElement<ScriptingString*>(assets,i);
			VCAsset asset;
			asset.SetPath(scripting_cpp_string_for(o));
			list.push_back(asset);
		}

		return GetVCProvider().PromptAndCheckoutIfNeeded(list, promptIfCheckoutIsNeeded);
	}

	CUSTOM private static Task Internal_Delete(Asset[] assets)
	{
		VCAssetList list;
		MonoVCAssetArrayToCpp(assets, list);
		return CreateManagedTask(GetVCProvider().Delete(list));
	}

	CUSTOM private static Task Internal_DeleteAtProjectPath(string assetProjectPath)
	{
		VCAsset a;
		a.SetPath(assetProjectPath);
		VCAssetList list;
		list.push_back(a);
		return CreateManagedTask(GetVCProvider().Delete(list));
	}

	//CUSTOM static public Task Move(Asset src, Asset dst)
	//{
	//	VCAsset* s = ExtractMonoObjectData<VCAsset*>(src);
	//	VCAsset* d = ExtractMonoObjectData<VCAsset*>(dst);
	//	return CreateManagedTask(GetVCProvider().Move(s, d));
	//}

	CUSTOM static private Task Internal_MoveAsStrings(string from, string to)
	{
		VCAsset src;
		src.SetPath(from);
		VCAsset dst;
		dst.SetPath(to);

		return CreateManagedTask(GetVCProvider().Move(src, dst));
	}

	CUSTOM static private bool Internal_AddIsValid(Asset[] assets)
	{
		VCAssetList list;
		MonoVCAssetArrayToCpp(assets, list);
		return GetVCProvider().AddIsValid(list);
	}

	CUSTOM private static Task Internal_Add(Asset[] assets, bool recursive)
	{
		VCAssetList list;
		MonoVCAssetArrayToCpp(assets, list);
		return CreateManagedTask(GetVCProvider().Add(list, recursive));
	}

	CUSTOM private static bool Internal_DeleteChangeSetsIsValid(ChangeSet[] changes)
	{
		VCChangeSets list;
		MonoVCChangeSetArrayToCpp(changes, list);
		return GetVCProvider().DeleteChangeSetsIsValid(list);
	} 

	CUSTOM private static Task Internal_DeleteChangeSets(ChangeSet[] changesets)
	{
		VCChangeSets list;
		MonoVCChangeSetArrayToCpp(changesets, list);
		return CreateManagedTask(GetVCProvider().DeleteChangeSets(list));
	}

	CUSTOM private static Task Internal_RevertChangeSets(ChangeSet[] changesets, RevertMode mode)
	{
		VCChangeSets list;
		MonoVCChangeSetArrayToCpp(changesets, list);
		return CreateManagedTask(GetVCProvider().RevertChangeSets(list, mode));
	}

	CUSTOM private static bool Internal_SubmitIsValid(ChangeSet changeset, Asset[] assets)
	{
		VCAssetList list;
		if (assets != NULL)
			MonoVCAssetArrayToCpp(assets, list);

		VCChangeSet* change = NULL;
		if (changeset != NULL)
			change = ExtractMonoObjectData<VCChangeSet*>(changeset);
		return GetVCProvider().SubmitIsValid(change, list);
	}

	CUSTOM private static Task Internal_Submit(ChangeSet changeset, Asset[] assets, string description, bool saveOnly)
	{
		VCAssetList list;
		if (assets != NULL)
			MonoVCAssetArrayToCpp(assets, list);

		VCChangeSet* change = NULL;
		if (changeset != NULL)
			change = ExtractMonoObjectData<VCChangeSet*>(changeset);
		
		string des = description;

		return CreateManagedTask(GetVCProvider().Submit(change, list, des, saveOnly));
	}
	
	CUSTOM static private bool Internal_DiffIsValid(Asset[] assets)
	{
		VCAssetList list;
		MonoVCAssetArrayToCpp(assets, list);
		return GetVCProvider().DiffIsValid(list);
	}
	
	CUSTOM static private Task Internal_DiffHead(Asset[] assets, bool includingMetaFiles)
	{
		VCAssetList list;
		MonoVCAssetArrayToCpp(assets, list);
		return CreateManagedTask(GetVCProvider().DiffHead(list, includingMetaFiles));
	}

	CUSTOM static private bool Internal_ResolveIsValid(Asset[] assets)
	{
		VCAssetList list;
		MonoVCAssetArrayToCpp(assets, list);
		return GetVCProvider().ResolveIsValid(list);
	}
	
	CUSTOM static private Task Internal_Resolve(Asset[] assets, ResolveMethod resolveMethod)
	{
		VCAssetList list;
		MonoVCAssetArrayToCpp(assets, list);
		return CreateManagedTask(GetVCProvider().Resolve(list, resolveMethod));
	}

	CUSTOM static private Task Internal_Merge(Asset[] assets, MergeMethod method)
	{
		VCAssetList list;
		MonoVCAssetArrayToCpp(assets, list);
		return CreateManagedTask(GetVCProvider().Merge(list, method));
	}

	CUSTOM static private bool Internal_LockIsValid(Asset[] assets)
	{
		VCAssetList list;
		MonoVCAssetArrayToCpp(assets, list);
		return GetVCProvider().LockIsValid(list);
	}
	
	CUSTOM static private bool Internal_UnlockIsValid(Asset[] assets)
	{
		VCAssetList list;
		MonoVCAssetArrayToCpp(assets, list);
		return GetVCProvider().UnlockIsValid(list);
	}

	CUSTOM static private Task Internal_Lock(Asset[] assets, bool locked)
	{
		VCAssetList list;
		MonoVCAssetArrayToCpp(assets, list);
		return CreateManagedTask(GetVCProvider().Lock(list, locked));
	}

	CUSTOM private static bool Internal_RevertIsValid(Asset[] assets, RevertMode mode)
	{
		VCAssetList list;
		MonoVCAssetArrayToCpp(assets, list);
		return GetVCProvider().RevertIsValid(list, mode);
	}

	CUSTOM static private Task Internal_Revert(Asset[] assets, RevertMode mode)
	{
		VCAssetList list;
		MonoVCAssetArrayToCpp(assets, list);
		return CreateManagedTask(GetVCProvider().Revert(list, mode));
	}

	CUSTOM static private bool Internal_GetLatestIsValid(Asset[] assets)
	{
		VCAssetList list;
		MonoVCAssetArrayToCpp(assets, list);
		return GetVCProvider().GetLatestIsValid(list);
	}

	CUSTOM static private Task Internal_GetLatest(Asset[] assets)
	{
		VCAssetList list;
		MonoVCAssetArrayToCpp(assets, list);
		return CreateManagedTask(GetVCProvider().GetLatest(list));
	}

	CUSTOM static private Task Internal_SetFileMode(Asset[] assets, FileMode mode)
	{
		VCAssetList list;
		MonoVCAssetArrayToCpp(assets, list);
		return CreateManagedTask(GetVCProvider().SetFileMode(list, mode));
	}

	CUSTOM static private Task Internal_SetFileModeStrings(string[] assets, FileMode mode)
	{
		VCAssetList list;
		int size = GetScriptingArraySize(assets);
		for (int i = 0; i < size; i++)
		{
			ScriptingString* o = Scripting::GetScriptingArrayElement<ScriptingString*>(assets,i);
			VCAsset asset;
			asset.SetPath(scripting_cpp_string_for(o));
			list.push_back(asset);
		}
		return CreateManagedTask(GetVCProvider().SetFileMode(list, mode));
	}

	CUSTOM private static Task Internal_ChangeSetDescription(ChangeSet changeset)
	{
		VCChangeSet* l = ExtractMonoObjectData<VCChangeSet*>(changeset);
		return CreateManagedTask(GetVCProvider().ChangeSetDescription(l->GetID()));
	}

	CUSTOM private static Task Internal_ChangeSetStatus(ChangeSet changeset)
	{
		VCChangeSet* l = ExtractMonoObjectData<VCChangeSet*>(changeset);
		return CreateManagedTask(GetVCProvider().ChangeSetStatus(l->GetID()));
	}

	CUSTOM static public Task ChangeSets()
	{
		return CreateManagedTask(GetVCProvider().ChangeSets());
	}

	CUSTOM private static Task Internal_ChangeSetMove(Asset[] assets, ChangeSet target)
	{
		VCAssetList list;
		MonoVCAssetArrayToCpp(assets, list);
		VCChangeSet* t = ExtractMonoObjectData<VCChangeSet*>(target);
		return CreateManagedTask(GetVCProvider().ChangeSetMove(list, t->GetID()));
	}

	CUSTOM static public Task Incoming ()
	{
		return CreateManagedTask(GetVCProvider().Incoming());
	}

	CUSTOM private static Task Internal_IncomingChangeSetAssets(ChangeSet changeset)
	{
		VCChangeSet* l = ExtractMonoObjectData<VCChangeSet*>(changeset);
		return CreateManagedTask(GetVCProvider().IncomingChangeSetAssets(l->GetID()));
	}

	CUSTOM static public bool IsOpenForEdit(Asset asset)
	{
		VCAsset* a = ExtractMonoObjectData<VCAsset*>(asset);
		return GetVCProvider().IsOpenForEdit(a);
	}

	CUSTOM static public Task UpdateSettings()
	{
		return CreateManagedTask(GetVCProvider().UpdateSettings());
	}


	CUSTOM static Asset GetAssetByPath(string unityPath)
	{
		VCAsset asset;
		bool ok = GetVCCache().GetAssetByPath(unityPath, asset);
		if (!ok)
			return NULL;
					
		ScriptingObject* monoAsset = scripting_object_new(GetScriptingTypeRegistry().GetType("UnityEditor.VersionControl", "Asset"));
		VCAsset* asss = UNITY_NEW(VCAsset, kMemVersionControl) (asset);
		ExtractMonoObjectData<VCAsset*>(monoAsset) = asss;
		return monoAsset;
	}

	CUSTOM static Asset GetAssetByGUID(string guid)
	{
		VCAsset asset;
		bool ok = GetVCCache().GetAssetByGUID(StringToGUID(guid), asset);
		if (!ok)
			return NULL;

		ScriptingObject* monoAsset = scripting_object_new(GetScriptingTypeRegistry().GetType("UnityEditor.VersionControl", "Asset"));
		VCAsset* asss = UNITY_NEW(VCAsset, kMemVersionControl) (asset);
		ExtractMonoObjectData<VCAsset*>(monoAsset) = asss;
		return monoAsset;
	}

	CUSTOM private static Asset[] Internal_GetAssetArrayFromSelection()
	{
		VCAssetList assetList;
		GetVCCache().GetSelection(assetList);

		MonoClass* elementType = GetMonoManager ().GetMonoClass ("Asset", "UnityEditor.VersionControl");
		MonoArray* array = mono_array_new(mono_domain_get(), elementType, assetList.size());
		for (int i = 0; i < assetList.size(); ++i)
		{

			ScriptingObject* monoAsset = scripting_object_new(GetScriptingTypeRegistry().GetType("UnityEditor.VersionControl", "Asset"));
			ExtractMonoObjectData<VCAsset*>(monoAsset) = UNITY_NEW(VCAsset, kMemVersionControl) (assetList[i]);
			Scripting::SetScriptingArrayElement(array, i, monoAsset);
		}
		return array;
	}

	CUSTOM internal static int GenerateID ()
	{
		return GetVCProvider().GenerateID();
	}

	CUSTOM static void ClearCache()
	{
		GetVCCache().Clear();
	}

END

CSRAW
}
