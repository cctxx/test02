C++RAW

#include "UnityPrefix.h"

#include <set>

#include "Configuration/UnityConfigureOther.h"
#include "Configuration/UnityConfigureVersion.h"
#include "Configuration/UnityConfigureRevision.h"

#include "Editor/Src/Utility/AssetDatabaseProperty.h"
#include "Editor/Src/AnimationCurvePreviewCache.h"
#include "Editor/Src/GradientPreviewCache.h"
#include "Editor/Src/AssetPipeline/AudioImporter.h"
#include "Editor/Src/EditorMonoConsole.h"
#include "Editor/Src/Utility/GameObjectHierarchyProperty.h"
#include "Editor/Src/AssetPipeline/AssetInterface.h"
#include "Editor/Src/CommandImplementation.h"
#include "Editor/Src/BuildPipeline/BuildTargetPlatformSpecific.h"
#include "Editor/Src/OcclusionCulling.h"
#include "Editor/Src/OcclusionCullingVisualizationState.h"
#include "Editor/Src/Gizmos/GizmoUtil.h"
#include "Editor/Src/AssetPipeline/AssetDatabase.h"
#include "Editor/Src/EditorWindowController.h"
#include "Editor/Src/DragAndDropForwarding.h"
#include "Editor/Src/HierarchyState.h"
#include "Editor/Src/Application.h"
#include "Editor/Src/Utility/ObjectImages.h"
#include "Editor/Src/AssetPipeline/MonoImporter.h"
#include "Editor/Src/AssetPipeline/MonoAssemblyImporter.h"
#include "Editor/Src/AssetPipeline/MonoCompilationPipeline.h"
#include "Editor/Src/AssetPipeline/ShaderImporter.h"
#include "Editor/Src/Utility/ObjectNames.h"
#include "Editor/Src/GUIDPersistentManager.h"
#include "Editor/Src/MenuController.h"
#include "Editor/Src/ShaderMenu.h"
#include "Editor/Src/Undo/Undo.h"
#include "Editor/Src/Utility/BuildPlayerUtility.h"
#include "Editor/Src/LicenseInfo.h"
#include "Editor/Src/EditorHelper.h"
#include "Editor/Src/Utility/SerializedProperty.h"
#include "Editor/Src/Utility/ActiveEditorTracker.h"
#include "Editor/Src/SceneInspector.h"
#include "Editor/Src/EditorBuildSettings.h"
#include "Editor/Src/EditorUserBuildSettings.h"
#include "Editor/Src/AssetPipeline/MonoCompile.h"
#include "Editor/Src/Utility/CustomLighting.h"
#include "Editor/Src/AssetPipeline/ModelImporter.h"
#include "Editor/Src/AssetPipeline/TextureImporter.h"
#include "Editor/Src/AssetPipeline/TrueTypeFontImporter.h"
#include "Editor/Src/AssetPipeline/MovieImporter.h"
#include "Editor/Src/Utility/DiffTool.h"
#include "Editor/Src/EditorSettings.h"
#include "Editor/Src/AssetPipeline/ImportMeshUtility.h"
#include "Editor/Src/Lightmapping.h"
#include "Editor/Src/LightProbeVisualization.h"
#include "Editor/Src/AssetPipeline/BumpMapSettings.h"
#include "Editor/Src/AssetPipeline/ObjectHashGenerator.h"
#include "Editor/Src/LightmapEditorSettings.h"
#include "Editor/Src/LightmapVisualization.h"
#include "Editor/Src/AssetPipeline/TextureBoundingHull.h"
#include "Editor/Src/Utility/WaveFormRender.h"
#include "Editor/Src/LightmapperLightProbes.h"
#include "Editor/Src/Utility/UnwrapImpl.h"
#include "Editor/Src/Animation/HumanTemplate.h"
#include "Editor/Src/AssetServer/ASController.h"
#include "Editor/Src/InspectorExpandedState.h"
#include "Editor/Platform/Interface/AppInfo.h"
#include "Editor/Platform/Interface/ColorPicker.h"
#include "Editor/Platform/Interface/EditorUtility.h"
#include "Editor/Platform/Interface/ExternalEditor.h"
#include "Editor/Mono/MonoEditorUtility.h"

#include "External/shaderlab/Library/intshader.h"
#include "External/shaderlab/Library/SLParserData.h"

#include "Runtime/Animation/AnimationClip.h"
#include "Runtime/Audio/AudioSource.h"
#include "Runtime/BaseClasses/GameObject.h"
#include "Runtime/IMGUI/TextUtil.h"
#include "Runtime/Graphics/Transform.h"
#include "Runtime/Filters/Renderer.h"
#include "Runtime/Graphics/Texture2D.h"
#include "Runtime/Mono/MonoScript.h"
#include "Runtime/Graphics/TextureFormat.h"
#include "Runtime/Graphics/CubemapTexture.h"
#include "Runtime/Graphics/Image.h"
#include "Runtime/Graphics/Texture.h"
#include "Runtime/Camera/SceneSettings.h"
#include "Runtime/Mono/MonoBehaviour.h"
#include "Runtime/Shaders/Shader.h"
#include "Runtime/Camera/Camera.h"
#include "Runtime/Camera/UnityScene.h"
#include "Runtime/Serialize/PersistentManager.h"
#include "Runtime/Serialize/TransferUtility.h"
#include "Runtime/Audio/AudioManager.h"
#include "Runtime/Audio/AudioListener.h"
#include "Runtime/Graphics/RenderTexture.h"
#include "Runtime/Misc/SaveAndLoadHelper.h"
#include "Runtime/GfxDevice/GfxDevice.h"
#include "Runtime/Network/NetworkManager.h"
#include "Runtime/Shaders/VBO.h"
#include "Runtime/Misc/BuildSettings.h"
#include "Runtime/Utilities/FileUtilities.h"
#include "Runtime/BaseClasses/IsPlaying.h"
#include "Runtime/Misc/SaveAndLoadHelper.h"
#include "Runtime/BaseClasses/Tags.h"
#include "Runtime/Graphics/ScreenManager.h"
#include "Runtime/Misc/PlayerSettings.h"
#include "Runtime/Graphics/TextureGenerator.h"
#include "Runtime/Shaders/GraphicsCaps.h"
#include "Runtime/Filters/Mesh/LodMesh.h"
#include "Runtime/Camera/RenderManager.h"
#include "Runtime/Input/TimeManager.h"
#include "Runtime/Terrain/TreeDatabase.h"
#include "Runtime/Terrain/TerrainData.h"
#include "Runtime/Dynamics/PhysicsManager.h"
#include "Runtime/Utilities/Argv.h"
#include "Runtime/Graphics/LightmapSettings.h"
#include "Runtime/Misc/Player.h"
#include "Runtime/Filters/Mesh/MeshRenderer.h"
#include "Runtime/Filters/Deformation/SkinnedMeshFilter.h"
#include "Runtime/Dynamics/CapsuleCollider.h"
#include "Runtime/Scripting/ScriptingExportUtility.h"
#include "Runtime/Audio/AudioCustomFilter.h"
#include "Runtime/Scripting/Scripting.h"
#include "Runtime/Scripting/ScriptingObjectWithIntPtrField.h"

extern GraphicsCaps gOriginalCaps;

using namespace std;

CSRAW
using System;
using UnityEngine;
using Object=UnityEngine.Object;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Collections;
using System.Reflection;
using System.Collections.Generic;
using System.IO;
using UnityScript.Scripting;
using UnityEditor;
using UnityEditorInternal;


namespace UnityEditor
{

// Target PS3 build platform.
ENUM PS3BuildSubtarget
	// Build package that it's hosted on the PC
	PCHosted = 0,
	// Build a package suited for DLC Submission
	HddTitle = 1,
	// Build a package suited for BluRay Submission
	BluRayTitle = 2,
END


// Target Wii build platform.
ENUM WiiBuildSubtarget
	// Precompiled ELF targeting DVD deployment
	DVD = 0,
	// Precompiled ELF targeting WiiWare deployment
	WiiWare = 1,
	// Precompiled libary with additional compile/link step targeting DVD deployment
	DVDLibrary = 2,
	// Precompiled libary with additional compile/link step targeting WiiWare deployment
	WiiWareLibrary = 3,
END

// Target Wii debugging level.
ENUM WiiBuildDebugLevel
	// Asserts enabled, memory profiling enabled, Nintendo Wii profiler linked, hio2 library linked, no optimizations.
	Full = 0,
	// Memory profiling enabled, Nintendo Wii profiler linked, hio2 library linked, optimizations enabled.
	Minimal = 1,
	// Optimizations enabled.
	None = 2
END

// Target Xbox build type.
ENUM XboxBuildSubtarget
	// Development player
	Development = 0,
	// Master player (submission-proof)
	Master = 1,
	// Debug player (for building with source code)
	Debug = 2,
END

// Xbox 360 run method.
ENUM XboxRunMethod
	// Copy to hard drive.
	HDD = 0,
	// Disc emulation (Fast)
	DiscEmuFast = 1,
	// Disc emulation (Accurate)
	DiscEmuAccurate = 2,
END

// Target Android build platform.
ENUM AndroidBuildSubtarget
	// Don't override texture compression.
	Generic = 0,
	// S3 texture compression, nonspecific to DXT variant. Supported on devices running Nvidia Tegra2 platform, including Motorala Xoom, Motorola Atrix, Droid Bionic, and others.
	DXT = 1,
	// PowerVR texture compression. Available in devices running PowerVR SGX530/540 GPU, such as Motorola DROID series; Samsung Galaxy S, Nexus S, and Galaxy Tab; and others.
	PVRTC = 2,
	// ATI texture compression. Available on devices running Adreno GPU, including HTC Nexus One, Droid Incredible, EVO, and others.
	ATC = 3,
	// ETC1 texture compression (or RGBA16 for textures with alpha), supported by all devices.
	ETC = 4,
	// ETC2/EAC texture compression, supported by GLES 3.0 devices
	ETC2 = 5,
	// Adaptive Scalable Texture Compression
	ASTC = 6,
END

// Target Flash build player.
ENUM FlashBuildSubtarget
	// FlashPlayer 11.2 SWF version 15
	Flash11dot2 = 0,
	// FlashPlayer 11.3 SWF version 16
	Flash11dot3 = 1,
	// FlashPlayer 11.4 SWF version 17
	Flash11dot4 = 2,
	// FlashPlayer 11.5 SWF version 18
	Flash11dot5 = 3,
	// FlashPlayer 11.6 SWF version 19
	Flash11dot6 = 4,
	// FlashPlayer 11.7 SWF version 20
	Flash11dot7 = 5,
	// FlashPlayer 11.8 SWF version 21
	Flash11dot8 = 6, 
END

// *undocumented*
ENUM MetroBuildType
	// *undocumented*
	AppX = 0,
	// *undocumented*
	VisualStudioCpp = 1,
	// *undocumented*
	VisualStudioCSharp = 2,
	// *undocumented*
	VisualStudioCppDX = 3,
	// *undocumented*
	VisualStudioCSharpDX = 4
END

// *undocumented*
ENUM MetroSDK
	// *undocumented*
	SDK80 = 0,
	// *undocumented*
	SDK81 = 1,
END

ENUM BlackBerryBuildSubtarget
	
	// Don't override texture compression.
	Generic = 0,
	// PowerVR texture compression. Available on devices running PowerVR GPU's.
	PVRTC = 1,
	// ATI texture compression. Available on devices running Adreno GPU.
	ATC = 2,
	// ETC1 texture compression (or RGBA16 for textures with alpha), supported by all devices.
	ETC = 3,
END

ENUM BlackBerryBuildType
	
	Debug = 0,
	
	Submission = 1,
END

//*undocumented*
CSRAW [StructLayout (LayoutKind.Sequential)]
CLASS EditorBuildSettingsScene : IComparable
	CSRAW int m_Enabled;
	CSRAW string m_Path;
	
	CSRAW public int CompareTo(object obj) {
        if(obj is EditorBuildSettingsScene) {
            EditorBuildSettingsScene temp = (EditorBuildSettingsScene) obj;

            return temp.m_Path.CompareTo(m_Path);
        }
        throw new ArgumentException("object is not a EditorBuildSettingsScene");    
    }


	CSRAW public EditorBuildSettingsScene (string path, bool enable) { m_Path = path.Replace("\\","/"); enabled = enable; }  
	CSRAW public EditorBuildSettingsScene () { }  

	CSRAW public bool enabled { get { return m_Enabled != 0;  } set { m_Enabled = value ? 1 : 0; } }  
	CSRAW public string path { get { return m_Path;  } set { m_Path = value.Replace("\\","/"); } }  
END

CLASS EditorBuildSettings

	C++RAW

	struct MonoEditorScene
	{
		int enabled;	
		MonoString *path;
	};
	
	void SceneToMono (const EditorBuildSettings::Scene &src, MonoEditorScene &dest)
	{
		dest.enabled = src.enabled;
		dest.path = scripting_string_new(src.path);
	}
	void SceneToCpp (MonoEditorScene &src, EditorBuildSettings::Scene &dest)
	{
		dest.enabled = src.enabled;
		dest.path = scripting_cpp_string_for (src.path);
	}
	
	CUSTOM_PROP static EditorBuildSettingsScene[] scenes
	{
		return VectorToMonoClassArray (GetEditorBuildSettings().GetScenes(), GetMonoManager().GetBuiltinEditorMonoClass("EditorBuildSettingsScene"), SceneToMono);
	}
	{
		vector<EditorBuildSettings::Scene> scenes;
		MonoClassArrayToVector (value, scenes, SceneToCpp);
		GetEditorBuildSettings().SetScenes(scenes);
	}
END

CLASS EditorUserBuildSettings
	// The currently selected build target group.
	CUSTOM_PROP static BuildTargetGroup selectedBuildTargetGroup
	{
		return GetEditorUserBuildSettings().GetSelectedBuildTargetGroup ();
	}
	{
		GetEditorUserBuildSettings().SetSelectedBuildTargetGroup (value);
	}

	// The currently selected target for a standalone build.
	CUSTOM_PROP static BuildTarget selectedStandaloneTarget
	{
		return GetEditorUserBuildSettings().GetSelectedStandaloneTarget ();
	}
	{
		GetEditorUserBuildSettings().SetSelectedStandaloneTarget (value);
	}

	//Flash Build Subtarget
	CUSTOM_PROP static FlashBuildSubtarget flashBuildSubtarget
	{
		return GetEditorUserBuildSettings().GetSelectedFlashBuildSubtarget ();
	}
	{
		GetEditorUserBuildSettings().SetSelectedFlashBuildSubtarget (value);
	}
	
	//PS3 Build Subtarget
	CUSTOM_PROP static PS3BuildSubtarget ps3BuildSubtarget
	{
		return GetEditorUserBuildSettings().GetSelectedPS3BuildSubtarget ();
	}
	{
		GetEditorUserBuildSettings().SetSelectedPS3BuildSubtarget (value);
	}
	
	// Are null references actively checked?
	CUSTOM_PROP static bool explicitNullChecks
	{
		return GetEditorUserBuildSettings().GetExplicitNullChecks ();
	}
	{
		GetEditorUserBuildSettings().SetExplicitNullChecks (value);
	}
	// Headless Mode for Linux Players
	CUSTOM_PROP static bool enableHeadlessMode
	{
		return GetEditorUserBuildSettings().GetEnableHeadlessMode ();
	}
	{
		GetEditorUserBuildSettings().SetEnableHeadlessMode (value);
	}

	// Wii platform options.
	CUSTOM_PROP static WiiBuildSubtarget wiiBuildSubtarget
	{
		return GetEditorUserBuildSettings().GetSelectedWiiBuildSubtarget ();
	}
	{
		GetEditorUserBuildSettings().SetSelectedWiiBuildSubtarget (value);
	}

	//Xbox Build subtarget
	CUSTOM_PROP static XboxBuildSubtarget xboxBuildSubtarget
	{
		return GetEditorUserBuildSettings().GetSelectedXboxBuildSubtarget ();
	}
	{
		GetEditorUserBuildSettings().SetSelectedXboxBuildSubtarget (value);
	}
	
	// Wii player debug level.
	CUSTOM_PROP static WiiBuildDebugLevel wiiBuildDebugLevel
	{
		return GetEditorUserBuildSettings().GetSelectedWiiBuildDebugLevel ();
	}
	{
		GetEditorUserBuildSettings().SetSelectedWiiBuildDebugLevel (value);
	}
	
	//selected Xbox Run Method
	CUSTOM_PROP static XboxRunMethod xboxRunMethod
	{
		return GetEditorUserBuildSettings().GetSelectedXboxRunMethod ();
	}
	{
		GetEditorUserBuildSettings().SetSelectedXboxRunMethod (value);
	}

	// Android platform options.
	CUSTOM_PROP static AndroidBuildSubtarget androidBuildSubtarget
	{
		return GetEditorUserBuildSettings().GetSelectedAndroidBuildSubtarget ();
	}
	{
		GetEditorUserBuildSettings().SetSelectedAndroidBuildSubtarget (value);
	}

	// *undocumented*
	CUSTOM_PROP static BuildTarget selectedMetroTarget
	{
		return GetEditorUserBuildSettings().GetSelectedMetroTarget ();
	}
	{
		GetEditorUserBuildSettings().SetSelectedMetroTarget (value);
	}

	// *undocumented*
	CUSTOM_PROP static MetroBuildType metroBuildType
	{
		return GetEditorUserBuildSettings().GetSelectedMetroBuildType ();
	}
	{
		GetEditorUserBuildSettings().SetSelectedMetroBuildType (value);
	}

	// *undocumented*
	CUSTOM_PROP static MetroSDK metroSDK
	{
		return GetEditorUserBuildSettings().GetSelectedMetroSDK ();
	}
	{
		GetEditorUserBuildSettings().SetSelectedMetroSDK (value);
	}

	// BlackBerry platform options.
	CUSTOM_PROP static BlackBerryBuildSubtarget blackberryBuildSubtarget
	{
		return GetEditorUserBuildSettings().GetSelectedBlackBerryBuildSubtarget ();
	}
	{
		GetEditorUserBuildSettings().SetSelectedBlackBerryBuildSubtarget (value);
	}
	
	// Blackberry platform options.
	CUSTOM_PROP static BlackBerryBuildType blackberryBuildType
	{
		return GetEditorUserBuildSettings().GetSelectedBlackBerryBuildType ();
	}
	{
		GetEditorUserBuildSettings().SetSelectedBlackBerryBuildType (value);
	}

	// Select the streaming option for a webplayer build.
	CUSTOM_PROP static bool webPlayerStreamed
	{
		return GetEditorUserBuildSettings().GetWebPlayerStreamed ();
	}
	{
		GetEditorUserBuildSettings().SetWebPlayerStreamed (value);
	}


	// Build the webplayer along with the UnityObject.js file (so it doesn't need to be downloaded).
	CUSTOM_PROP static bool webPlayerOfflineDeployment
	{
		return GetEditorUserBuildSettings().GetWebPlayerOfflineDeployment ();
	}
	{
		GetEditorUserBuildSettings().SetWebPlayerOfflineDeployment (value);
	}

	//*undocumented*
	CUSTOM_PROP static bool webPlayerDeployOnline
	{
		return GetEditorUserBuildSettings().GetWebPlayerDeployOnline ();
	}
	{
		GetEditorUserBuildSettings().SetWebPlayerDeployOnline (value);
	}

	// The currently active build target.
	CUSTOM_PROP static BuildTarget activeBuildTarget
	{
		return GetEditorUserBuildSettings().GetActiveBuildTarget ();
	}

	// Select a new build target to be active.
	CUSTOM static bool SwitchActiveBuildTarget (BuildTarget target)
	{
		return SwitchActiveBuildTargetForEmulation(target);
	}
	
	// Triggered in response to SwitchActiveBuildTarget. 
	CSRAW public static System.Action activeBuildTargetChanged;
	
	CSRAW internal static void Internal_ActiveBuildTargetChanged()
	{
		if (activeBuildTargetChanged != null)
			activeBuildTargetChanged();
	}
	
	// DEFINE directives for the compiler.
	CUSTOM_PROP static string[] activeScriptCompilationDefines
	{
		std::vector<string> defines;
		GetEditorUserBuildSettings().GetActiveScriptCompilationDefines(defines);
		return Scripting::StringVectorToMono(defines);
	}

	// Get the current location for the build.
	CUSTOM static string GetBuildLocation (BuildTarget target)
	{
		return scripting_string_new(GetEditorUserBuildSettings().GetBuildLocation (target));
	}

	// Set a new location for the build.
	CUSTOM static void SetBuildLocation (BuildTarget target, string location)
	{
		GetEditorUserBuildSettings().SetBuildLocation (target, location);
	}
	
	// Enables a development build.
	CUSTOM_PROP static bool development { return GetEditorUserBuildSettings().GetDevelopment(); } { GetEditorUserBuildSettings().SetDevelopment(value); }
	
	// Start the player with a connection to the profiler.
	CUSTOM_PROP static bool connectProfiler { return GetEditorUserBuildSettings().GetConnectProfiler(); } { GetEditorUserBuildSettings().SetConnectProfiler(value); }
	
	// Enable source-level debuggers to connect.
	CUSTOM_PROP static bool allowDebugging { return GetEditorUserBuildSettings().GetAllowDebugging(); } { GetEditorUserBuildSettings().SetAllowDebugging(value); }
	
	// Append (rather than replace) the build of an iOS Xcode project.
	CUSTOM_PROP static bool appendProject { return GetEditorUserBuildSettings().GetAppendProject(); } { GetEditorUserBuildSettings().SetAppendProject(value); }
	
	// Symlink runtime libraries with an iOS Xcode project.
	CUSTOM_PROP static bool symlinkLibraries { return GetEditorUserBuildSettings().GetSymlinkLibraries(); } { GetEditorUserBuildSettings().SetSymlinkLibraries(value); }

	// Place the built player in the build folder.
	CUSTOM_PROP static bool installInBuildFolder { return GetEditorUserBuildSettings().GetInstallInBuildFolder(); } { GetEditorUserBuildSettings().SetInstallInBuildFolder(value); }
END


// This is a strain for the garbage collector (Small memory for GC, big overhead for engine)
// Might want to add a manual dispose
//*undocumented*
CSRAW [System.Serializable]
CLASS ActiveEditorTracker
	CSRAW MonoReloadableIntPtrClear m_Property;
	C++RAW
 #define GET ExtractMonoObjectData<ActiveEditorTracker*>(self)
	
	C++RAW
 #define MAKE if (ExtractMonoObjectData<ActiveEditorTracker*>(self) == NULL) {GET = new ActiveEditorTracker (); }

	CUSTOM ActiveEditorTracker ()
	{
		GET = NULL;
	}
	
	CSRAW public override bool Equals(object o)
	{
		ActiveEditorTracker other = o as ActiveEditorTracker;
		return this.m_Property.m_IntPtr == other.m_Property.m_IntPtr;
	}
	
	CSRAW public override int GetHashCode()
	{
		return m_Property.m_IntPtr.GetHashCode();
	}
	
	THREAD_SAFE
	CUSTOM private void Dispose ()
	{
		if (GET != GetSharedActiveEditorTracker())
			GetSceneTracker().DelayedDeleteSceneInspector(GET);
		GET = NULL;
	}
	
	CSRAW ~ActiveEditorTracker ()
	{
		Dispose();
	}

	CUSTOM public void Destroy ()
	{
		if (GET != NULL)
		{
			delete GET;
			GET = NULL;
		}
	}
	
	CUSTOM_PROP Editor[] activeEditors
	{
		MAKE
		return CreateScriptingArrayFromUnityObjects(GET->GetEditors(), ClassID(MonoBehaviour));
	}
		
	CUSTOM int GetVisible (int index) { MAKE return GET->GetVisible(index); } 
	CUSTOM void SetVisible (int index, int visible) { MAKE GET->SetVisible(index, visible); } 

	CUSTOM_PROP bool isDirty  { MAKE return GET->IsDirty(); }
	CUSTOM void ClearDirty () { MAKE return GET->ClearDirty(); }

	CUSTOM_PROP bool isLocked  { MAKE return GET->IsLocked(); } { MAKE GET->SetIsLocked(value); }

	CUSTOM_PROP InspectorMode inspectorMode  { MAKE return GET->GetInspectorMode(); } { MAKE GET->SetInspectorMode(value); }

	CUSTOM_PROP bool hasComponentsWhichCannotBeMultiEdited  { MAKE return GET->HasComponentsWhichCannotBeMultiEdited(); }

	CUSTOM void RebuildIfNecessary () { MAKE GET->DidFlushDirty(); }

	CUSTOM void ForceRebuild () { MAKE GET->Rebuild (); }

	CUSTOM void VerifyModifiedMonoBehaviours () {MAKE GET->VerifyModifiedMonoBehaviours(); }
	

	C++RAW
 #undef GET
	
	OBSOLETE warning Use Editor.CreateEditor instead
	CSRAW public static Editor MakeCustomEditor (Object obj)
	{
		return Editor.CreateEditor (obj);
	}
	
	// Is there a custom editor for this object?
	CSRAW public static bool HasCustomEditor (Object obj)
	{
		return CustomEditorAttributes.FindCustomEditorType (obj, false) != null;
	}

	CSRAW static public ActiveEditorTracker sharedTracker  { get { ActiveEditorTracker tracker = new ActiveEditorTracker (); SetupSharedTracker(tracker); return tracker; } } 

	CUSTOM private static void SetupSharedTracker (ActiveEditorTracker sharedTracker)
	{
		ExtractMonoObjectData<ActiveEditorTracker*>(sharedTracker) = GetSharedActiveEditorTracker();
	}
	
END

ENUM InspectorMode
	Normal = 0,
	Debug = 1,
	DebugInternal = 2
END


C++RAW
 enum HierarchyType { kHierarchyAssets=1, kHierarchyGameObjects=2 };

//*undocumented*
CSRAW 
ENUM HierarchyType
	Assets = 1,
	GameObjects = 2,
END

//*undocumented*
ENUM IconDrawStyle
	NonTexture         = 0,
	Texture            = 1,
END

CSRAW interface IHierarchyProperty
{
	void Reset();
	int instanceID { get; }
	Object pptrValue { get; }
	string name { get; }
	bool hasChildren { get; }
	int depth { get; }
	int row { get; }
	int colorCode { get; }
	string guid { get; }
	Texture2D icon { get; }		
	bool isValid { get; }
	bool isMainRepresentation { get; }
	bool hasFullPreviewImage { get; }
	IconDrawStyle iconDrawStyle { get; }
	bool isFolder { get; }

	bool IsExpanded (int[] expanded);
	bool Next (int[] expanded);
	bool NextWithDepthCheck (int[] expanded, int minDepth);
	bool Previous(int[] expanded);
	bool Parent();

	int[] ancestors { get; }

	bool Find (int instanceID, int[] expanded);
	int[] FindAllAncestors (int[] instanceIDs);

	bool Skip (int count, int[] expanded);
	int CountRemaining (int[] expanded);
}

//*undocumented*
CLASS HierarchyProperty : IHierarchyProperty
	CSRAW IntPtr m_Property;

	C++RAW
 #define GET ExtractMonoObjectData<BaseHierarchyProperty*>(self)	
	
	CUSTOM HierarchyProperty (HierarchyType hierarchytType)
	{
		if (hierarchytType == kHierarchyAssets)
		{
			ExtractMonoObjectData<BaseHierarchyProperty*> (self) = new AssetDatabaseProperty();
//			LogString (Format ("Creating %p\n", ExtractMonoObjectData<BaseHierarchyProperty*> (self)));
		}
		else
		{
			ExtractMonoObjectData<BaseHierarchyProperty*> (self) = new GameObjectHierarchyProperty();
			ErrorIf(hierarchytType != kHierarchyGameObjects);
		}
	}

	CUSTOM void Reset () { return GET->Reset(); }

	THREAD_SAFE
	CUSTOM private void Dispose ()
	{
		delete GET;
		GET = NULL;
	}
	CSRAW ~HierarchyProperty () { Dispose (); }
	
	CUSTOM_PROP int instanceID { return GET->GetInstanceID(); }
	CUSTOM_PROP Object pptrValue { return Scripting::ScriptingWrapperFor (dynamic_instanceID_cast<Object*> (GET->GetInstanceID())); }
	CUSTOM_PROP string name { return scripting_string_new(GET->GetName()); }
	CUSTOM_PROP bool hasChildren { return GET->HasChildren(); }
	CUSTOM_PROP int depth { return GET->GetDepth(); }
	CUSTOM_PROP int[] ancestors { vector<int> tmp = GET->GetAncestors(); return CreateScriptingArray(&(tmp[0]), tmp.size(), MONO_COMMON.int_32);}
	CUSTOM_PROP int row { return GET->GetRow(); }
	CUSTOM_PROP int colorCode { return GET->GetColorCode(); }
	CUSTOM bool IsExpanded (int[] expanded) { return GET->IsExpanded(expanded ? &GetMonoArrayElement<int> (expanded, 0) : NULL, mono_array_length_safe(expanded)); }
	CUSTOM_PROP string guid { return scripting_string_new(GUIDToString(GET->GetGUID())); }
	
	CUSTOM_PROP bool isValid { return GET->IsValid(); }
	CUSTOM_PROP bool isMainRepresentation { return GET->IsMainAssetRepresentation(); }
	CUSTOM_PROP bool hasFullPreviewImage { return GET->HasFullPreviewImage(); }
	CUSTOM_PROP IconDrawStyle iconDrawStyle 
	{
	 return GET->GetIconDrawStyle(); 
	}

	CUSTOM_PROP bool isFolder { return GET->IsFolder(); }

	CUSTOM bool Next (int[] expanded){ return GET->Next(expanded ? &GetMonoArrayElement<int> (expanded, 0) : NULL, mono_array_length_safe(expanded)); }
	CUSTOM bool NextWithDepthCheck (int[] expanded, int minDepth) { return GET->NextWithDepthCheck (expanded ? &GetMonoArrayElement<int> (expanded, 0) : NULL, mono_array_length_safe(expanded), minDepth); }
	CUSTOM bool Previous(int[] expanded){ return GET->Previous(expanded ? &GetMonoArrayElement<int> (expanded, 0) : NULL, mono_array_length_safe(expanded)); } 
	CUSTOM bool Parent() { return GET->Parent(); }

	// Find property but only search through expanded objects
	CUSTOM bool Find (int instanceID, int[] expanded) { return GET->Find(instanceID, expanded ? &GetMonoArrayElement<int> (expanded, 0) : NULL, mono_array_length_safe(expanded)); }

	CUSTOM bool Skip (int count, int[] expanded) { return GET->Skip(count, expanded ? &GetMonoArrayElement<int> (expanded, 0) : NULL, mono_array_length_safe(expanded)); }
	CUSTOM int CountRemaining (int[] expanded) { return GET->CountRemaining(expanded ? &GetMonoArrayElement<int> (expanded, 0) : NULL, mono_array_length_safe(expanded)); }

	CUSTOM_PROP Texture2D icon { return Scripting::ScriptingWrapperFor (GET->GetCachedIcon()); }
	
 	// Pre 4.0 interface (kept for backwards compability)
 	CSRAW public void SetSearchFilter (string searchString, int mode) 
 	{
 		SearchFilter filter = SearchableEditorWindow.CreateFilter (searchString, (SearchableEditorWindow.SearchMode)mode);
 		SetSearchFilter (filter);
 	}

	// 4.0 interface (made internal for now)
	CSRAW internal void SetSearchFilter (SearchFilter filter)
	{
		SetSearchFilterINTERNAL (filter.SplitNameFilter (), filter.classNames, filter.assetLabels, filter.referencingInstanceIDs, filter.showAllHits);	
	}
	
	CUSTOM private void SetSearchFilterINTERNAL (string[] nameFilters, string[] classNames, string[] assetLabels, int[] referencingInstanceIDs, bool showAllHits) 
	{ 
		std::vector <std::string> convertedNameFilters;
		if (nameFilters != NULL)
			StringMonoArrayToVector (nameFilters, convertedNameFilters);

		std::vector <std::string> convertedClassNames;
		if (classNames != NULL)
			StringMonoArrayToVector (classNames, convertedClassNames);

		std::vector <std::string> convertedLabels;
		if (assetLabels != NULL)
			StringMonoArrayToVector (assetLabels, convertedLabels);

		std::vector<int> convertedInstanceIDs (Scripting::GetScriptingArrayStart<int>(referencingInstanceIDs), Scripting::GetScriptingArrayStart<int>(referencingInstanceIDs) + GetScriptingArraySize(referencingInstanceIDs));
		
		GET->SetSearchFilter (convertedNameFilters, convertedClassNames, convertedLabels, convertedInstanceIDs, showAllHits); 
	}

	CUSTOM int[] FindAllAncestors (int[] instanceIDs)
	{
		vector<int> tmp = GET->FindAllAncestors(instanceIDs ? &GetMonoArrayElement<int> (instanceIDs, 0) : NULL, mono_array_length_safe(instanceIDs));
		return CreateScriptingArray(&(tmp[0]), tmp.size(), MONO_COMMON.int_32); 
	}
	
	CUSTOM static void FilterSingleSceneObject (int instanceID, bool otherVisibilityState)
	{
		MarkSingleSceneObjectVisible(instanceID, otherVisibilityState);
	}
	
	C++RAW
 #undef GET

END

CSRAW [Flags]
ENUM AssetMoveResult
	// Tells the internal implementation that the asset was not moved physically on disk by the script
	DidNotMove = 0,

	// Tells the internal implementation that the script could not move the assets, and Unity should not attempt to move the asset
	FailedMove = 1,

	// Tells the internal implementation that the script moved the asset physically on disk. The internal implementation will
	DidMove = 2
END

CSRAW [Flags]
ENUM AssetDeleteResult
	// Tells the internal implementation that the callback did not delete the asset. The asset will be delete by the internal implementation.
	DidNotDelete = 0,

	// Tells Unity that the file cannot be deleted and Unity should leave it alone.	
	FailedDelete = 1,

	//	Tells Unity that the asset was deleted by the callback. Unity will not try to delete the asset, but will delete the cached version and preview file.
	DidDelete = 2
END

OBSOLETE warning Use UnityEditor.AssetModificationProcessor
NONSEALED_CLASS SaveAssetsProcessor : UnityEditor.AssetModificationProcessor

END

CLASS MonoImporter : AssetImporter
	
	CUSTOM void SetDefaultReferences (string[] name, Object[] target)
	{
		vector<string> cnames;
		StringMonoArrayToVector(name, cnames);
		vector<Object*> cobjects;
		MonoObjectArrayToVector<Object>(target, cobjects);
		self->SetDefaultReferences(cnames, cobjects);
	}
	
	CUSTOM static MonoScript[] GetAllRuntimeMonoScripts ()
	{
		return CreateScriptingArrayFromUnityObjects (GetMonoManager().GetMonoScriptManager().GetAllRuntimeScripts (), ClassID(MonoScript));
	}

	CUSTOM static void SetExecutionOrder (MonoScript script, int order)
	{
		SetMonoScriptExecutionOrder(*script, order);
	}

	// Call when icon set by SetIconForObject should be copied to monoImporter for persistance across project reloads
	// This function will reimport the asset and is therefore slow.
	CUSTOM internal static void CopyMonoScriptIconToImporters (MonoScript script)
	{
		CopyMonoScriptIconToImporters (*script);
	}

	CUSTOM static int GetExecutionOrder (MonoScript script)
	{
		return script->GetExecutionOrder();
	}

	CUSTOM MonoScript GetScript ()
	{
		MonoScript* monoScript = AssetImporter::GetFirstDerivedObjectAtPath<MonoScript> (self->GetAssetPathName());
		return Scripting::ScriptingWrapperFor(monoScript);
	}

	CUSTOM Object GetDefaultReference (string name)
	{
		return Scripting::ScriptingWrapperFor(self->GetDefaultReference(name));
	}
	
END

// Mask type for [[AnimationClip]].
ENUM ClipAnimationMaskType

	// Generate a mask from this model that does include everything
	CreateFromThisModel = 0,

	// Copy mask from an asset.
	CopyFromOther = 1
END

// Animation clips to split animation into.
CSRAW [System.Serializable]
CSRAW [StructLayout (LayoutKind.Sequential)]
CLASS ModelImporterClipAnimation
	CSRAW
	string m_TakeName;
	string m_Name;
	float m_FirstFrame;
	float m_LastFrame;
	int m_WrapMode;
	int m_Loop;

	float	m_OrientationOffsetY;
	float	m_Level;
	float	m_CycleOffset;
		
	int	m_LoopTime;
	int	m_LoopBlend;
	int	m_LoopBlendOrientation;
	int	m_LoopBlendPositionY;
	int	m_LoopBlendPositionXZ;
	int	m_KeepOriginalOrientation;
	int	m_KeepOriginalPositionY;
	int	m_KeepOriginalPositionXZ;
	int m_HeightFromFeet;
	int	m_Mirror;
	int m_MaskType;
	AvatarMask m_MaskSource;

	// Take name
	public string takeName { get { return m_TakeName; } set { m_TakeName = value; } }
	// Clip name
	public string name { get { return m_Name; } set { m_Name = value; } }
	// First frame of the clip
	public float firstFrame { get { return m_FirstFrame; } set { m_FirstFrame = value; } }
	// Last frame of the clip
	public float lastFrame { get { return m_LastFrame; } set { m_LastFrame = value; } }

	// The wrap mode of the animation
	public WrapMode wrapMode { get { return (WrapMode)m_WrapMode; } set { m_WrapMode = (int)value; } }

	// Is the clip a looping animation?
	public bool loop { get { return m_Loop != 0; } set { m_Loop = value ? 1 : 0; } } 

	// Offset in degrees to the root rotation.
	public float rotationOffset { get { return m_OrientationOffsetY; } set { m_OrientationOffsetY = value; } }

	// Offset to the vertical root position.
	public float heightOffset { get { return m_Level; } set { m_Level = value; } }

	// Offset to the cycle of a looping animation, if a different time in it is desired to be the start.
	public float cycleOffset { get { return m_CycleOffset; } set { m_CycleOffset = value; } }

	// Enable to make the motion loop time
	public bool loopTime { get { return m_LoopTime != 0; } set { m_LoopTime = value ? 1 : 0; } }

	// Enable to make the motion loop pose seamlessly.
	public bool loopPose { get { return m_LoopBlend != 0; } set { m_LoopBlend = value ? 1 : 0; } }

	// Enable to make root rotation be baked into the movement of the bones. Disable to make root rotation be stored as root motion.
	public bool lockRootRotation { get { return m_LoopBlendOrientation != 0; } set { m_LoopBlendOrientation = value ? 1 : 0; } }

	// Enable to make vertical root motion be baked into the movement of the bones. Disable to make vertical root motion be stored as root motion.
	public bool lockRootHeightY { get { return m_LoopBlendPositionY != 0; } set { m_LoopBlendPositionY = value ? 1 : 0; } }

	// Enable to make horizontal root motion be baked into the movement of the bones. Disable to make horizontal root motion be stored as root motion
	public bool lockRootPositionXZ { get { return m_LoopBlendPositionXZ != 0; } set { m_LoopBlendPositionXZ = value ? 1 : 0; } }

	// Keeps the vertical position as it is authored in the source file.
	public bool keepOriginalOrientation { get { return m_KeepOriginalOrientation != 0; } set { m_KeepOriginalOrientation = value ? 1 : 0; } }

	// Keeps the vertical position as it is authored in the source file.
	public bool keepOriginalPositionY { get { return m_KeepOriginalPositionY != 0; } set { m_KeepOriginalPositionY = value ? 1 : 0; } }

	// Keeps the vertical position as it is authored in the source file.
	public bool keepOriginalPositionXZ { get { return m_KeepOriginalPositionXZ != 0; } set { m_KeepOriginalPositionXZ = value ? 1 : 0; } }
	
	// Keeps the feet aligned with the root transform position.
	public bool heightFromFeet { get { return m_HeightFromFeet != 0; } set { m_HeightFromFeet = value ? 1 : 0; } }

	// Mirror left and right in this clip.
	public bool mirror { get { return m_Mirror != 0; } set { m_Mirror = value ? 1 : 0; } }
	
	// Animation Clip mask type.
	public ClipAnimationMaskType maskType { get { return (ClipAnimationMaskType)m_MaskType; } set { m_MaskType = (int)value; } }

	// Animation Clip mask source.
	public AvatarMask maskSource { get { return m_MaskSource; } set { m_MaskSource = value; } }


	public override bool Equals(object o)
	{
		ModelImporterClipAnimation other = o as ModelImporterClipAnimation;
		return other != null && takeName == other.takeName && name == other.name && firstFrame == other.firstFrame && lastFrame == other.lastFrame && m_WrapMode == other.m_WrapMode && m_Loop == other.m_Loop &&
			   loopPose == other.loopPose && lockRootRotation == other.lockRootRotation && lockRootHeightY == other.lockRootHeightY && lockRootPositionXZ == other.lockRootPositionXZ && 
			   mirror == other.mirror &&  maskType == other.maskType && maskSource == other.maskSource;
	}

	public override int GetHashCode()
	{
		return name.GetHashCode();
	}

END

C++RAW

struct MonoClipAnimationInfo {
	MonoString* takeName;
	MonoString* name;
	float firstFrame;
	float lastFrame;
	int wrapMode;
	int loop;

	float orientationOffsetY;
	float level;
	float cycleOffset;
		
	int	loopTime;
	int	loopBlend;
	int loopBlendOrientation;
	int	loopBlendPositionY;
	int	loopBlendPositionXZ;
	int keepOriginalOrientation;
	int	keepOriginalPositionY;
	int	keepOriginalPositionXZ;
	int	heightFromFeet;
	int	mirror;
	int maskType;
	MonoObject* maskSource;
};

void ClipAnimationInfoToMono (const ClipAnimationInfo &src, MonoClipAnimationInfo &dest) {
	dest.takeName = scripting_string_new(src.takeName);
	dest.name = scripting_string_new(src.name);
	dest.firstFrame = src.firstFrame;
	dest.lastFrame = src.lastFrame;
	dest.wrapMode = src.wrapMode;
	dest.loop = src.loop;

	dest.orientationOffsetY = src.orientationOffsetY;
	dest.level = src.level;
	dest.cycleOffset = src.cycleOffset;
		
	dest.loopTime = src.loopTime;
	dest.loopBlend = src.loopBlend;
	dest.loopBlendOrientation = src.loopBlendOrientation;
	dest.loopBlendPositionY = src.loopBlendPositionY;
	dest.loopBlendPositionXZ = src.loopBlendPositionXZ;
	dest.keepOriginalOrientation = src.keepOriginalOrientation;
	dest.keepOriginalPositionY = src.keepOriginalPositionY;
	dest.keepOriginalPositionXZ = src.keepOriginalPositionXZ;
	dest.heightFromFeet = src.heightFromFeet;
	dest.mirror = src.mirror;
	dest.maskType = (int)src.maskType;
	dest.maskSource = Scripting::ScriptingWrapperFor (src.maskSource);
}

void ClipAnimationInfoFromMono (const MonoClipAnimationInfo &src, ClipAnimationInfo &dest) {
	dest.takeName = scripting_cpp_string_for(src.takeName);
	dest.name = scripting_cpp_string_for(src.name);
	dest.firstFrame = src.firstFrame;
	dest.lastFrame = src.lastFrame;
	dest.wrapMode = src.wrapMode;
	dest.loop = src.loop;

	dest.orientationOffsetY = src.orientationOffsetY;
	dest.level = src.level;
	dest.cycleOffset = src.cycleOffset;
		
	dest.loopTime = src.loopTime;
	dest.loopBlend = src.loopBlend;
	dest.loopBlendOrientation = src.loopBlendOrientation;
	dest.loopBlendPositionY = src.loopBlendPositionY;
	dest.loopBlendPositionXZ = src.loopBlendPositionXZ;
	dest.keepOriginalOrientation = src.keepOriginalOrientation;
	dest.keepOriginalPositionY = src.keepOriginalPositionY;
	dest.keepOriginalPositionXZ = src.keepOriginalPositionXZ;
	dest.heightFromFeet = src.heightFromFeet;
	dest.mirror = src.mirror;
	dest.maskType = (ClipAnimationInfo::MaskType)src.maskType;
	dest.maskSource = ScriptingObjectToObject<AvatarMask> (src.maskSource);
}

// Material generation options for [[ModelImporter]].
OBSOLETE warning Use ModelImporterMaterialName, ModelImporter.materialName and ModelImporter.importMaterials instead
ENUM ModelImporterGenerateMaterials
	// Do not generate materials.
	OBSOLETE warning Use ModelImporter.importMaterials=false instead
	None = 0,
	// Generate a material for each texture used.
	OBSOLETE warning Use ModelImporter.importMaterials=true and ModelImporter.materialName=ModelImporterMaterialName.BasedOnTextureName instead
	PerTexture = 1,
	// Generate a material for each material in the source asset.
	OBSOLETE warning Use ModelImporter.importMaterials=true and ModelImporter.materialName=ModelImporterMaterialName.BasedOnModelNameAndMaterialName instead
	PerSourceMaterial = 2,
END

// Material naming options for [[ModelImporter]].
ENUM ModelImporterMaterialName
	// <textureName>.mat material name.
	BasedOnTextureName = 0,
	// <materialName>.mat material name.
	BasedOnMaterialName = 1,
	// <modelFileName>-<materialName>.mat material name.
	BasedOnModelNameAndMaterialName = 2,
	// <textureName>.mat or <modelFileName>-<materialName>.mat material name.
	OBSOLETE warning You should use ModelImporterMaterialName.BasedOnTextureName instead, because it it less complicated and behaves in more consistent way.
	BasedOnTextureName_Or_ModelNameAndMaterialName = 3,
END

// Material search options for [[ModelImporter]].
ENUM ModelImporterMaterialSearch
	// Searh in local Materials forlder.
	Local = 0,
	// Recursive-up search in Materials forlders.
	RecursiveUp = 1,
	// Searh in all project.
	Everywhere = 2,
END

// Animation generation options for [[ModelImporter]].
ENUM ModelImporterTangentSpaceMode
	// Import normals/tangents from file.
	Import = 0,
	// Calculate normals/tangents. 
	Calculate = 1,
	// Strip normals/tangents. 
	None = 2,
END


// Mesh compression options for [[ModelImporter]].
ENUM ModelImporterMeshCompression
	// No mesh compression (default).
	Off = 0,
	
	// Low amount of mesh compression.
	Low = 1,
	
	// Medium amount of mesh compression.
	Medium = 2,
	
	// High amount of mesh compression.
	High = 3,
END


// Animation compression options for [[ModelImporter]].
ENUM ModelImporterAnimationCompression

	// No animation compression.
	Off = 0,
	
	// Perform keyframe reduction (default).
	KeyframeReduction = 1,
	
	// Perform keyframe reduction and compression.
	KeyframeReductionAndCompression = 2,

	// Perform Optimal.
	Optimal = 3
END

// Animation generation options for [[ModelImporter]].
ENUM ModelImporterGenerateAnimations
	// Do not generate animations.
	None = 0,

	// Default animation import mode (All animations are stored in the root object)
	GenerateAnimations = 4,

	// Generate animations in the transform root objects.
	InRoot = 3,

	// Generate animations in the root objects of the animation package.
	InOriginalRoots = 1,

	// Generate animations in the objects that animate.
	InNodes = 2
END



// Animation mode for [[ModelImporter]].
ENUM ModelImporterAnimationType

	// Generate no animation data
	None = 0,

	// Generate a legacy animation type
	Legacy = 1,

	// Generate a generic animator.
	Generic = 2,

	// Generate a human animator.
	Human = 3
END

//*undocumented*
CLASS HumanTemplate : Object

	// Creates a new Human Template
	CUSTOM HumanTemplate ()
	{
		HumanTemplate* humanTemplate = NEW_OBJECT(HumanTemplate);
		humanTemplate->Reset();
		Scripting::ConnectScriptingWrapperToObject (self.GetScriptingObject(), humanTemplate);
		humanTemplate->AwakeFromLoad(kInstantiateOrCreateFromCodeAwakeFromLoad);
	}
	
	CUSTOM void Insert(string name, string templateName) { self->Insert( name, templateName); }
	CUSTOM string Find(string name) { return scripting_string_new( self->Find( name ) ); }	
	CUSTOM void	ClearTemplate() { self->ClearTemplate(); }
END

//*undocumented*
STRUCT TakeInfo
	CSRAW public string name;
	CSRAW public string defaultClipName;
	CSRAW public float  startTime;
	CSRAW public float  stopTime;
	CSRAW public float  bakeStartTime;
	CSRAW public float  bakeStopTime;
	CSRAW public float  sampleRate;
END

C++RAW

struct MonoTakeInfo {
	MonoString* name;
	MonoString* defaultClipName;
	float startTime;
	float stopTime;
	float bakeStartTime;
	float bakeStopTime;
	float sampleRate;
};

void TakeInfoToMono (const TakeInfo &src, MonoTakeInfo &dest) {
	dest.name = scripting_string_new(src.name);
	dest.defaultClipName = scripting_string_new(src.defaultClipName);
	dest.startTime = src.startTime;
	dest.stopTime = src.stopTime;
	dest.bakeStartTime = src.bakeStartTime;
	dest.bakeStopTime = src.bakeStopTime;
	dest.sampleRate = src.sampleRate;
}

C++RAW

struct MonoSkeletonBone {
	MonoString* name;
	Vector3f	position;
	Quaternionf rotation;
	Vector3f	scale;
	int			transformModified;
};

void SkeletonBoneFromMono (const MonoSkeletonBone &src, SkeletonBone &dest);


// Model importer lets you modify [[wiki:class-Mesh|model]] import settings from editor scripts.
CLASS ModelImporter : AssetImporter
	
	// Material generation options.
	OBSOLETE warning Use importMaterials, materialName and materialSearch instead
	AUTO_PROP ModelImporterGenerateMaterials generateMaterials  GetGenerateMaterials SetGenerateMaterials
	
	// Import materials from file.
	AUTO_PROP bool importMaterials GetImportMaterials SetImportMaterials
	
	// Material naming setting.
	AUTO_PROP ModelImporterMaterialName materialName GetMaterialName SetMaterialName
	
	// Existing material search setting.
	AUTO_PROP ModelImporterMaterialSearch materialSearch GetMaterialSearch SetMaterialSearch
	
	// Global scale factor for importing.
	AUTO_PROP float globalScale GetGlobalScale SetGlobalScale
	
	// Is useFileUnits supported for this asset.
	AUTO_PROP bool isUseFileUnitsSupported IsUseFileUnitsSupported
	
	// Detect file units and import as 1FileUnit=1UnityUnit, otherwise it will import as 1cm=1UnityUnit.
	AUTO_PROP bool useFileUnits GetUseFileUnits SetUseFileUnits
	
	// Controlls import of BlendShapes.
	AUTO_PROP bool importBlendShapes GetImportBlendShapes SetImportBlendShapes
	
	// Add [[wiki:class-MeshCollider|mesh colliders]] to imported meshes.
	AUTO_PROP bool addCollider GetAddColliders SetAddColliders
	
	// Smoothing angle for calculating normals.
	AUTO_PROP float normalSmoothingAngle GetNormalSmoothingAngle SetNormalSmoothingAngle
	
	// Should tangents be split across UV seams.
	AUTO_PROP bool splitTangentsAcrossSeams GetSplitTangentsAcrossUV SetSplitTangentsAcrossUV
	
	// Swap primary and secondary UV channels when importing.
	AUTO_PROP bool swapUVChannels GetSwapUVChannels SetSwapUVChannels 
	
	// Generate secondary UV set for lightmapping.
	AUTO_PROP bool generateSecondaryUV GetGenerateSecondaryUV SetGenerateSecondaryUV
	
	// Threshold for angle distortion when generating secondary UV
	AUTO_PROP float secondaryUVAngleDistortion GetSecondaryUVAngleDistortion SetSecondaryUVAngleDistortion
	
	// Threshold for area distortion when generating secondary UV
	AUTO_PROP float secondaryUVAreaDistortion GetSecondaryUVAreaDistortion SetSecondaryUVAreaDistortion
	
	// Hard angle for generating secondary UV
	AUTO_PROP float secondaryUVHardAngle GetSecondaryUVHardAngle SetSecondaryUVHardAngle
	
	// Margin to be left between charts when packing secondary UV
	AUTO_PROP float secondaryUVPackMargin GetSecondaryUVPackMargin SetSecondaryUVPackMargin

	// Animation generation options.
	AUTO_PROP ModelImporterGenerateAnimations generateAnimations GetLegacyGenerateAnimations SetLegacyGenerateAnimations

	
	CUSTOM_PROP internal TakeInfo[] importedTakeInfos
	{
		MonoClass* klass = GetMonoManager().GetBuiltinEditorMonoClass("TakeInfo");
		return VectorToMonoStructArray<TakeInfo, MonoTakeInfo>(self->GetImportedTakeInfos(), klass, TakeInfoToMono);
	}

	// Generates the list of all imported Transforms 
	CUSTOM_PROP string[] transformPaths
	{
		return Scripting::StringVectorToMono(self->GetTransformPaths());
	}
	

	// Generates the list of all imported Animations
	CUSTOM_PROP string[] referencedClips
	{
		vector<string> cstrings;
		vector<UnityGUID> const & guids = self->GetReferencedClips();
		cstrings.reserve(guids.size());
		for (vector<UnityGUID>::const_iterator i = guids.begin(); i != guids.end(); i++)
		{
			cstrings.push_back(GUIDToString(*i));
		}
		return Scripting::StringVectorToMono(cstrings);
	}
	
	// Are mesh vertices and indices accessible from script?
	AUTO_PROP bool isReadable GetIsReadable SetIsReadable

	// Vertex optimization setting
	AUTO_PROP bool optimizeMesh GetOptimizeMesh SetOptimizeMesh
	// Normals import mode.
	CUSTOM_PROP ModelImporterTangentSpaceMode normalImportMode
	{
		return self->GetNormalImportMode();
	}
	{
		self->SetNormalImportMode((TangentSpaceOptions)value);
	}
	
	// Tangents import mode.
	CUSTOM_PROP ModelImporterTangentSpaceMode tangentImportMode
	{
		return self->GetTangentImportMode();
	}
	{
		self->SetTangentImportMode((TangentSpaceOptions)value);
	}

	
	// Bake Inverse Kinematics (IK) when importing.
	AUTO_PROP bool bakeIK GetBakeIK SetBakeIK

	// Is Bake Inverse Kinematics (IK) supported by this importer.
	AUTO_PROP bool isBakeIKSupported IsBakeIKSupported
	
	// Is import of tangents supported by this importer.
	AUTO_PROP bool isTangentImportSupported IsTangentImportSupported
	
	
	OBSOLETE error Use animationCompression instead
	CSRAW private bool reduceKeyframes { get { return false; } set {}  }
	
	
	// Mesh compression setting.
	CUSTOM_PROP ModelImporterMeshCompression meshCompression { return self->GetMeshCompression();  } { self->SetMeshCompression(value);  }
	
	// Import Animation
	AUTO_PROP bool importAnimation GetImportAnimation SetImportAnimation

	// Animation compression setting.
	CUSTOM_PROP ModelImporterAnimationCompression animationCompression  { return self->GetAnimationCompression();  } { self->SetAnimationCompression(value);  }
	
	// Allowed error of animation rotation compression. 
	AUTO_PROP float animationRotationError GetAnimationRotationError SetAnimationRotationError
	
	// Allowed error of animation position compression. 
	AUTO_PROP float animationPositionError GetAnimationPositionError SetAnimationPositionError
	
	// Allowed error of animation scale compression. 
	AUTO_PROP float animationScaleError GetAnimationScaleError SetAnimationScaleError

	// The default wrap mode for the generated animation clips.
	AUTO_PROP WrapMode animationWrapMode GetAnimationWrapMode SetAnimationWrapMode

	// Animator generation mode.
	CUSTOM_PROP ModelImporterAnimationType animationType 
	{
		return  self->GetAnimationType();
	} 
	{
	    self->SetAnimationType((ModelImporter::AnimationType)value);
	}

	OBSOLETE error splitAnimations has been deprecated please use clipAnimations instead.
	CSRAW public bool splitAnimations
	{
		get { return clipAnimations.Length != 0; }
		set {  }
	}
			
	// Animation clips to split animation into.
	CUSTOM_PROP ModelImporterClipAnimation[] clipAnimations
	{
		return VectorToMonoClassArray<ClipAnimationInfo, MonoClipAnimationInfo> (self->GetClipAnimations(), GetMonoManager().GetBuiltinEditorMonoClass("ModelImporterClipAnimation"), ClipAnimationInfoToMono);
	}
	{
		ModelImporter::ClipAnimations convertedClips;
		MonoClassArrayToVector (value, convertedClips, ClipAnimationInfoFromMono);
		self->SetClipAnimations(convertedClips);
	}
	
			
	C++RAW
 void UpdateSkeletonPose_Internal(SkeletonBoneList& skeletonBones, MonoObject* object)
	{
		if (object == NULL)
			return;
		SerializedProperty& serializedProperty = *ExtractMonoObjectData<SerializedProperty*>(object);
		ModelImporter::UpdateSkeletonPose(skeletonBones, serializedProperty);		
	}

	CUSTOM internal static void UpdateSkeletonPose(SkeletonBone[] skeletonBones, SerializedProperty serializedProperty) 
	{ 
		SkeletonBoneList convertedSkeletonBones;
		MonoStructArrayToVector(skeletonBones, convertedSkeletonBones, SkeletonBoneFromMono);

		UpdateSkeletonPose_Internal(convertedSkeletonBones, serializedProperty); 
	}	


	C++RAW
 void UpdateTransformMask_Internal(AvatarMask& mask, MonoObject* object)
	{
		if (object == NULL)
			return;
		SerializedProperty& serializedProperty = *ExtractMonoObjectData<SerializedProperty*>(object);		
		ModelImporter::UpdateTransformMask(mask, serializedProperty);		
	}

	CUSTOM internal static void UpdateTransformMask(AvatarMask mask, SerializedProperty serializedProperty) 
	{ 	
		UpdateTransformMask_Internal(*mask, serializedProperty); 
	}	

	CUSTOM internal AnimationClip GetPreviewAnimationClipForTake (string takeName) { return Scripting::ScriptingWrapperFor(self->GetPreviewAnimationClipForTake (takeName)); }
		
	CUSTOM internal string CalculateBestFittingPreviewGameObject() { return scripting_string_new(self->CalculateBestFittingPreviewGameObject()); }
		
END

// Imported texture format for [[TextureImporter]].
ENUM TextureImporterFormat
	// Choose a compressed format automatically.
	AutomaticCompressed = -1,
	// Choose a 16 bit format automatically.
	Automatic16bit = -2,
	// Choose a Truecolor format automatically.
	AutomaticTruecolor = -3,

	// DXT1 compresed texture format.
	DXT1 = 10,
	// DXT5 compresed texture format.
	DXT5 = 12,
	// RGB 16 bit texture format.
	RGB16 = 7,
	// RGB 24 bit texture format.
	RGB24 = 3,
	// Alpha 8 bit texture format.
	Alpha8 = 1,
	// RGBA 16 bit texture format.
	ARGB16 = 2,
	// RGBA 32 bit texture format.
	RGBA32 = 4,
	// ARGB 32 bit texture format.
	ARGB32 = 5,
	// RGBA 16 bit (4444) texture format.
	RGBA16 = 13,
	
	//*undocumented*
	WiiI4 = 20,
	//*undocumented*
	WiiI8 = 21,
	//*undocumented*
	WiiIA4 = 22,
	//*undocumented*
	WiiIA8 = 23,
	//*undocumented*
	WiiRGB565 = 24,
	//*undocumented*
	WiiRGB5A3 = 25,
	//*undocumented*
	WiiRGBA8 = 26,
	//*undocumented*
	WiiCMPR = 27,
	
	// PowerVR (iPhone) 2 bits/pixel compressed color texture format.
	PVRTC_RGB2 = 30,
	// PowerVR (iPhone) 2 bits/pixel compressed with alpha channel texture format.
	PVRTC_RGBA2 = 31,
	// PowerVR (iPhone) 4 bits/pixel compressed color texture format.
	PVRTC_RGB4 = 32,
	// PowerVR (iPhone) 4 bits/pixel compressed with alpha channel texture format.
	PVRTC_RGBA4 = 33,
	// ETC (GLES2.0) 4 bits/pixel compressed RGB texture format.
	ETC_RGB4 = 34,
	// ATC (Android) 4 bits/pixel compressed RGB texture format.
	ATC_RGB4 = 35,
	// ATC (Android) 8 bits/pixel compressed RGBA texture format.
	ATC_RGBA8 = 36,
	// BGRA32 = 37, // Needed by iPhone camera but not needed for importer.
	// Flash-specific RGB DXT1 compressed color texture format.
	ATF_RGB_DXT1 = 38,
	// Flash-specific RGBA JPG-compressed color texture format.
	ATF_RGBA_JPG = 39,
	// Flash-specific RGB JPG-compressed color texture format.
	ATF_RGB_JPG = 40,

	// EAC 4 bits/pixel compressed 16-bit R texture format
	EAC_R = 41,
	// EAC 4 bits/pixel compressed 16-bit signed R texture format
	EAC_R_SIGNED = 42,
	// EAC 8 bits/pixel compressed 16-bit RG texture format
	EAC_RG = 43,
	// EAC 8 bits/pixel compressed 16-bit signed RG texture format
	EAC_RG_SIGNED = 44,

	// ETC2 (GLES3.0) 4 bits/pixel compressed RGB texture format.
	ETC2_RGB4 = 45,
	// ETC2 (GLES3.0) 4 bits/pixel compressed RGB + 1-bit alpha texture format.
	ETC2_RGB4_PUNCHTHROUGH_ALPHA = 46,
	// ETC2 (GLES3.0) 8 bits/pixel compressed RGBA texture format.
	ETC2_RGBA8 = 47,
	// ASTC (block size 4x4) compressed RGB texture format.
	ASTC_RGB_4x4 = 48,
	// ASTC (block size 5x5) compressed RGB texture format.
	ASTC_RGB_5x5 = 49,
	// ASTC (block size 6x6) compressed RGB texture format.
	ASTC_RGB_6x6 = 50,
	// ASTC (block size 8x8) compressed RGB texture format.
	ASTC_RGB_8x8 = 51,
	// ASTC (block size 10x10) compressed RGB texture format.
	ASTC_RGB_10x10 = 52,
	// ASTC (block size 12x12) compressed RGB texture format.
	ASTC_RGB_12x12 = 53,
	// ASTC (block size 4x4) compressed RGBA texture format.
	ASTC_RGBA_4x4 = 54,
	// ASTC (block size 5x5) compressed RGBA texture format.
	ASTC_RGBA_5x5 = 55,
	// ASTC (block size 6x6) compressed RGBA texture format.
	ASTC_RGBA_6x6 = 56,
	// ASTC (block size 8x8) compressed RGBA texture format.
	ASTC_RGBA_8x8 = 57,
	// ASTC (block size 10x10) compressed RGBA texture format.
	ASTC_RGBA_10x10 = 58,
	// ASTC (block size 12x12) compressed RGBA texture format.
	ASTC_RGBA_12x12 = 59,
END


// Mip map filter for [[TextureImporter]].
ENUM TextureImporterMipFilter
	// Box mipmap filter.
	BoxFilter = 0,
	// Kaiser mipmap filter.
	KaiserFilter = 1,
END

// Cubemap generation mode for [[TextureImporter]].
ENUM TextureImporterGenerateCubemap
	// Do not generate cubemap (default).
	None = 0,
	// Generate cubemap from spheremap texture.
	Spheremap = 1,
	// Generate cubemap from cylindrical texture.
	Cylindrical = 2,
	// Generate cubemap from spheremap texture.
	SimpleSpheremap = 3,
	// Generate cubemap from spheremap texture.
	NiceSpheremap = 4,
	// Generate cubemap from vertical or horizontal cross texture.
	FullCubemap = 5,
END

// Scaling mode for non power of two textures in [[TextureImporter]].
ENUM TextureImporterNPOTScale
	// Keep non power of two textures as is.
	None = 0,
	// Scale to nearest power of two.
	ToNearest = 1,
	// Scale to larger power of two.
	ToLarger = 2,
	// Scale to smaller power of two.
	ToSmaller = 3,
END

// Normal map filtering mode for [[TextureImporter]].
ENUM TextureImporterNormalFilter
	// Standard normal map filter.
	Standard = 0,
	// Sobel normal map filter.
	Sobel = 1,
END



ENUM TextureImporterType
	Image = 0,
	Bump = 1,
	GUI = 2,
	Sprite = 8,
	Cursor = 7,
	Reflection = 3,
	Cookie = 4,
	Lightmap = 6,
	Advanced = 5
END

CONDITIONAL ENABLE_SPRITES
ENUM SpriteImportMode
	None = 0,
	Single = 1,
	Multiple
END

CONDITIONAL ENABLE_SPRITES
/// Used in TextureImporter
STRUCT SpriteMetaData
	CSRAW public string name;
	CSRAW public Rect rect;
	CSRAW public int alignment;
	CSRAW public Vector2 pivot;
END

C++RAW
#if ENABLE_SPRITES
struct SpriteMetaDataToMono
{
	ScriptingStringPtr name;
	Rectf rect;
	int alignment;
	Vector2f pivot;
};
#endif

// Texture importer lets you modify [[Texture2D]] import settings from editor scripts.
CLASS TextureImporter : AssetImporter
	// Format of imported texture.
	AUTO_PROP TextureImporterFormat textureFormat GetTextureFormat SetTextureFormat
	// Maximum texture size.
	AUTO_PROP int maxTextureSize GetMaxTextureSize SetMaxTextureSize
	// Quality of Texture Compression in the range [0..100]
	AUTO_PROP int compressionQuality GetCompressionQuality SetCompressionQuality
	// Generate alpha channel from intensity?
	AUTO_PROP bool grayscaleToAlpha GetGrayscaleToAlpha SetGrayscaleToAlpha
	
	// TODO: make this use struct for possible future expansion

	// Get platform specific texture settings
	CUSTOM bool GetPlatformTextureSettings (string platform, out int maxTextureSize, out TextureImporterFormat textureFormat, out int compressionQuality)
	{
		TextureImporter::BuildTargetSettings settings;
		bool found = self->GetPlatformTextureSettings(platform, &settings);

		*maxTextureSize		= settings.m_MaxTextureSize;
		*textureFormat		= settings.m_TextureFormat;
		*compressionQuality	= settings.m_CompressionQuality;

		return found;
	}
	
	// Get platform specific texture settings
	CSRAW public bool GetPlatformTextureSettings (string platform, out int maxTextureSize, out TextureImporterFormat textureFormat)
	{
		int compressionQuality = 0;
		return GetPlatformTextureSettings(platform, out maxTextureSize, out textureFormat, out compressionQuality);
	}

	// Set specific target platform settings
	CUSTOM void SetPlatformTextureSettings(string platform, int maxTextureSize, TextureImporterFormat textureFormat, int compressionQuality)
	{
		TextureImporter::BuildTargetSettings settings;
		settings.m_BuildTarget = platform.AsUTF8();
		settings.m_MaxTextureSize = maxTextureSize;
		settings.m_TextureFormat = textureFormat;
		settings.m_CompressionQuality = clamp(compressionQuality, 0, 100);

		self->SetPlatformTextureSettings(settings);
	}

	// Set specific target platform settings
	CSRAW public void SetPlatformTextureSettings(string platform, int maxTextureSize, TextureImporterFormat textureFormat)
	{
		SetPlatformTextureSettings(platform, maxTextureSize, textureFormat, (int)TextureCompressionQuality.Normal);
	}

	// Clear specific target platform settings
	CUSTOM void ClearPlatformTextureSettings(string platform)
	{
		self->ClearPlatformTextureSettings(platform);
	}
	
	CUSTOM internal static TextureImporterFormat FullToSimpleTextureFormat (TextureImporterFormat format) 
	{
		if (format < 0)
			return format;
		return TextureImporter::FullToSimpleTextureFormat (format);
	}
	
	CUSTOM internal static TextureImporterFormat SimpleToFullTextureFormat2 (TextureImporterFormat simpleFormat, TextureImporterType tType, TextureImporterSettings settings, bool doesTextureContainAlpha, bool doesTextureContainColor, BuildTarget destinationPlatform)
	{
		Scripting::RaiseIfNull(settings);
		return TextureImporter::SimpleToFullTextureFormat (simpleFormat, (TextureImporter::TextureType)tType, ExtractMonoObjectData<TextureImporter::Settings>(settings), doesTextureContainAlpha, doesTextureContainColor, BuildTargetSelection(destinationPlatform, 0));
	}
		
	// Cubemap generation mode.
	AUTO_PROP TextureImporterGenerateCubemap generateCubemap GetGenerateCubemap SetGenerateCubemap
	// Scaling mode for non power of two textures.
	AUTO_PROP TextureImporterNPOTScale npotScale GetNPOTScale SetNPOTScale
	
	// Is texture data readable from scripts.
	AUTO_PROP bool isReadable GetIsReadable SetIsReadable 
	// Generate mip maps for the texture?
	AUTO_PROP bool mipmapEnabled GetMipmapEnabled SetMipmapEnabled 
	// Keep texture borders the same when generating mipmaps?
	AUTO_PROP bool borderMipmap GetBorderMipmap SetBorderMipmap
	// When in linear rendering should this texture be sampled with hardware gamma correction (sRGB) or without (linear)?
	AUTO_PROP bool linearTexture GetLinearTexture SetLinearTexture
	
	// Mipmap filtering mode.
	AUTO_PROP TextureImporterMipFilter mipmapFilter GetMipmapMode SetMipmapMode
	// Fade out mip levels to gray color?
	AUTO_PROP bool fadeout GetFadeout SetFadeout
	// Mip level where texture begins to fade out.
	AUTO_PROP int mipmapFadeDistanceStart GetMipmapFadeDistanceStart SetMipmapFadeDistanceStart
	// Mip level where texture is faded out completely.
	AUTO_PROP int mipmapFadeDistanceEnd GetMipmapFadeDistanceEnd SetMipmapFadeDistanceEnd
	// Should mip maps be generated with gamma correction?
	AUTO_PROP bool generateMipsInLinearSpace GetGenerateMipsInLinearSpace SetGenerateMipsInLinearSpace
	OBSOLETE warning correctGamma Property deprecated. Use generateMipsInLinearSpace instead.
	AUTO_PROP bool correctGamma GetGenerateMipsInLinearSpace SetGenerateMipsInLinearSpace

	// Convert heightmap to normal map?
	AUTO_PROP bool convertToNormalmap GetConvertToNormalmap SetConvertToNormalmap	
	// Is this texture a normal map?
	AUTO_PROP bool normalmap GetNormalmap SetNormalmap	
	// Normal map filtering mode.
	AUTO_PROP TextureImporterNormalFilter normalmapFilter GetNormalmapFilter SetNormalmapFilter	
	// Amount of bumpyness in the heightmap.
	AUTO_PROP float heightmapScale GetNormalmapHeightScale SetNormalmapHeightScale
	// Is this texture a lightmap?
	AUTO_PROP bool lightmap GetLightmap SetLightmap

	// Anisotropic filtering level of the texture.
	AUTO_PROP int anisoLevel GetAnisoLevel SetAnisoLevel

	// Filtering mode of the texture.
	AUTO_PROP FilterMode filterMode GetFilterMode SetFilterMode

	// Wrap mode (Repeat or Clamp) of the texture.
	AUTO_PROP TextureWrapMode wrapMode GetWrapMode SetWrapMode

	// Mip map bias of the texture.
	AUTO_PROP float mipMapBias GetMipMapBias SetMipMapBias

	// Use alpha channel as transparency. Removes white borders from transparent textures
	AUTO_PROP bool alphaIsTransparency GetAlphaIsTransparency SetAlphaIsTransparency

	CONDITIONAL ENABLE_SPRITES
	AUTO_PROP bool qualifiesForSpritePacking GetQualifiesForSpritePacking

    CONDITIONAL ENABLE_SPRITES
	CUSTOM_PROP SpriteImportMode spriteImportMode
	{
		return self->GetSpriteMode ();
	}
	{
		self->SetSpriteMode (value);
	}

	CONDITIONAL ENABLE_SPRITES
	CUSTOM_PROP SpriteMetaData[] spritesheet
	{
		size_t size = self->GetSpriteSheet()->m_Sprites.size();
		MonoArray *arr = mono_array_new (mono_domain_get (), GetMonoManager().GetBuiltinEditorMonoClass("SpriteMetaData"), size );
		for (int i = 0; i < size ;i++) 
		{
			SpriteMetaDataToMono& a = GetMonoArrayElement<SpriteMetaDataToMono> (arr,i);
			a.rect = self->GetSpriteSheet()->m_Sprites[i].m_Rect;
			a.name = scripting_string_new(self->GetSpriteSheet()->m_Sprites[i].m_Name);
			a.alignment = self->GetSpriteSheet()->m_Sprites[i].m_Alignment;
			a.pivot = self->GetSpriteSheet()->m_Sprites[i].m_Pivot;
		}
		return arr;
	}
	{
		self->GetSpriteSheet()->m_Sprites.clear();
		for (int i=0;i<mono_array_length_safe(value);i++)
		{
			SpriteMetaData dest;
			SpriteMetaDataToMono& src = Scripting::GetScriptingArrayElement<SpriteMetaDataToMono>(value,i);
			dest.m_Rect = src.rect;
			dest.m_Name = scripting_cpp_string_for(src.name);
			dest.m_Alignment = (SpriteAlignment)src.alignment;
			dest.m_Pivot = src.pivot;
			self->GetSpriteSheet()->m_Sprites.push_back(dest);
		}
	}

	CONDITIONAL ENABLE_SPRITES
	CUSTOM_PROP string spritePackingTag
	{
		return scripting_string_new(self->GetSpritePackingTag());
	}
	{
		self->SetSpritePackingTag(value);
	}

	CONDITIONAL ENABLE_SPRITES
	AUTO_PROP float spritePixelsToUnits GetSpritePixelsToUnits SetSpritePixelsToUnits

	CONDITIONAL ENABLE_SPRITES
	AUTO_PROP Vector2 spritePivot GetSpritePivot SetSpritePivot

	CONDITIONAL (ENABLE_SPRITES && ENABLE_SPRITECOLLIDER)
	AUTO_PROP int spriteColliderAlphaCutoff GetSpriteColliderAlphaCutoff SetSpriteColliderAlphaCutoff

	CONDITIONAL (ENABLE_SPRITES && ENABLE_SPRITECOLLIDER)
	AUTO_PROP float spriteColliderDetail GetSpriteColliderDetail SetSpriteColliderDetail

	CUSTOM internal void GetWidthAndHeight(ref int width, ref int height)
	{
		TextureImporter::SourceTextureInformation info = self->GetSourceTextureInformation();
		width = info.width;
		height = info.height;
	}

	// Does textures source image have alpha channel.
	CUSTOM bool DoesSourceTextureHaveAlpha ()
	{
		if (self->GetSourceTextureInformation().width == -1)
			Scripting::RaiseArgumentException("May only be called in OnPostProcessTexture");
		
		return self->GetSourceTextureInformation().doesTextureContainAlpha;
	}
	
	// Does textures source image have RGB channels.
	CUSTOM bool DoesSourceTextureHaveColor ()
	{
		if (self->GetSourceTextureInformation().width == -1)
			Scripting::RaiseArgumentException("May only be called in OnPostProcessTexture");

		return self->GetSourceTextureInformation().doesTextureContainColor;
	}

	// Which type of texture are we dealing with here
	CUSTOM_PROP TextureImporterType textureType { return self->GetTextureType(); } { self->SetTextureType (value, false); }
	
	// Read texture settings into [[TextureImporterSettings]] class.
	CUSTOM void ReadTextureSettings (TextureImporterSettings dest)
	{
		Scripting::RaiseIfNull(dest);
		ExtractMonoObjectData<TextureImporter::Settings>(dest) = self->GetSettings ();
	}
	
	// Set texture importers settings from [[TextureImporterSettings]] class.
	CUSTOM void SetTextureSettings (TextureImporterSettings src)
	{
		Scripting::RaiseIfNull(src);
		self->SetSettings (ExtractMonoObjectData<TextureImporter::Settings>(src));
	}
	
	CUSTOM internal string GetImportWarnings()
	{
		const std::string& str = self->GetImportInspectorWarning();
		return str.length() ? scripting_string_new(str.c_str()) : SCRIPTING_NULL;
	}

	// Read texture import instructions into [[TextureImportInstructions]] class.
	CUSTOM void ReadTextureImportInstructions (TextureImportInstructions dest, BuildTarget target)
	{
		Scripting::RaiseIfNull(dest);
		ExtractMonoObjectData<TextureImporter::TextureImportInstructions>(dest) = self->GetTextureImportInstructions (target);
	}

END

CSRAW 

// MUST match memory layout of TextureSettings in TextureImporter.h
// Stores settings of a [[TextureImporter]]
[System.Serializable]
CLASS TextureImporterSettings
CSRAW
	[SerializeField]
	int   m_MipMapMode;
	[SerializeField]
	int  m_EnableMipMap;
	[SerializeField]
	int  m_GenerateMipsInLinearSpace;
	[SerializeField]
	int  m_FadeOut;
	[SerializeField]
	int  m_BorderMipMap;
	[SerializeField]
	int    m_MipMapFadeDistanceStart;
	[SerializeField]
	int    m_MipMapFadeDistanceEnd;
		
	[SerializeField]
	int  m_ConvertToNormalMap;
	[SerializeField]
	int  m_NormalMap;
	[SerializeField]
	float  m_HeightScale;
	[SerializeField]
	int     m_NormalMapFilter;
	[SerializeField]
	int   m_GrayScaleToAlpha;
	[SerializeField]
	int  m_IsReadable;
	[SerializeField]
	int    m_TextureFormat;
	[SerializeField]
	int    m_RecommendedTextureFormat;
	[SerializeField]
	int    m_MaxTextureSize;
	[SerializeField]
	int    m_NPOTScale;
	[SerializeField]
	int    m_Lightmap;
	[SerializeField]
	int  m_LinearTexture;
	[SerializeField]
	int  m_CompressionQuality;

	CONDITIONAL ENABLE_SPRITES
	[SerializeField]
	int    m_SpriteMode;
	CONDITIONAL ENABLE_SPRITES
	[SerializeField]
	uint   m_SpriteExtrude;
	CONDITIONAL ENABLE_SPRITES
	[SerializeField]
	int   m_SpriteMeshType;
	CONDITIONAL ENABLE_SPRITES
	[SerializeField]
	int    m_Alignment;
	CONDITIONAL ENABLE_SPRITES
	[SerializeField]
	Vector2    m_SpritePivot;
	CONDITIONAL ENABLE_SPRITES
	[SerializeField]
	float  m_SpritePixelsToUnits;
	CONDITIONAL (ENABLE_SPRITES && ENABLE_SPRITECOLLIDER)
	[SerializeField]
	int   m_SpriteColliderAlphaCutoff;
	CONDITIONAL (ENABLE_SPRITES && ENABLE_SPRITECOLLIDER)
	[SerializeField]
	float  m_SpriteColliderDetail;

	[SerializeField]
	int    m_GenerateCubemap;
	[SerializeField]
	int    m_SeamlessCubemap;

	[SerializeField]
	int m_AlphaIsTransparency;

	// memory layout of these is in TextureSettings.h
	[SerializeField]
	int 	m_FilterMode;
	[SerializeField]
	int 	m_Aniso;
	[SerializeField]
	float	m_MipBias;
	[SerializeField]
	int	m_WrapMode;
	
	public TextureImporterMipFilter mipmapFilter  { 
		get {return (TextureImporterMipFilter)m_MipMapMode;} 
		set { m_MipMapMode = (int)value; } 
	}
	public bool mipmapEnabled  { 
		get {return m_EnableMipMap != 0;} 
		set { m_EnableMipMap = value ? 1 : 0; } 
	}
	public bool generateMipsInLinearSpace  { 
		get {return m_GenerateMipsInLinearSpace != 0;} 
		set { m_GenerateMipsInLinearSpace = value ? 1 : 0; } 
	}
	public bool linearTexture { 
		get {return m_LinearTexture != 0;} 
		set { m_LinearTexture = value ? 1 : 0; } 
	}
	public bool fadeOut {
		get {return m_FadeOut != 0;} 
		set { m_FadeOut = value ? 1 : 0; } 
	}
	public bool borderMipmap {
		get {return m_BorderMipMap != 0;} 
		set { m_BorderMipMap = value ? 1 : 0; } 
	}
	public int mipmapFadeDistanceStart  { 
		get {return m_MipMapFadeDistanceStart;} 
		set { m_MipMapFadeDistanceStart = value; } 
	}
	public int mipmapFadeDistanceEnd  { 
		get {return m_MipMapFadeDistanceEnd;} 
		set { m_MipMapFadeDistanceEnd = value; } 
	}
	public bool convertToNormalMap {
		get {return m_ConvertToNormalMap != 0;} 
		set { m_ConvertToNormalMap = value ? 1 : 0; } 
	}
	public bool normalMap {
		get {return m_NormalMap != 0;} 
		set { m_NormalMap = value ? 1 : 0; } 
	}
	public float heightmapScale {
		get {return m_HeightScale;} 
		set { m_HeightScale = value; } 
	}
	public TextureImporterNormalFilter normalMapFilter  { 
		get {return (TextureImporterNormalFilter)m_NormalMapFilter;} 
		set { m_NormalMapFilter = (int)value; } 
	}
	public bool grayscaleToAlpha {
		get {return m_GrayScaleToAlpha != 0;} 
		set { m_GrayScaleToAlpha = value ? 1 : 0; }
	}
	public bool readable {
		get {return m_IsReadable != 0;} 
		set { m_IsReadable = value ? 1 : 0; } 
	}
	public TextureImporterFormat textureFormat {
		get {return (TextureImporterFormat)m_TextureFormat;} 
		set { m_TextureFormat = (int)value; } 
	}
	public int maxTextureSize {
		get {return m_MaxTextureSize;} 
		set { m_MaxTextureSize = value; } 
	}
	public TextureImporterNPOTScale npotScale {
		get {return (TextureImporterNPOTScale)m_NPOTScale;} 
		set { m_NPOTScale = (int)value; } 
	}
	public bool lightmap {
		get {return m_Lightmap != 0;} 
		set { m_Lightmap = value ? 1 : 0; } 
	}
	public TextureImporterGenerateCubemap generateCubemap {
		get {return (TextureImporterGenerateCubemap)m_GenerateCubemap;} 
		set { m_GenerateCubemap = (int)value; } 
	}
	public bool seamlessCubemap {
		get {return m_SeamlessCubemap != 0;} 
		set { m_SeamlessCubemap = value ? 1 : 0; } 
	}
	public FilterMode filterMode {
		get {return (FilterMode)m_FilterMode;} 
		set { m_FilterMode = (int)value; } 
	}
	public int aniso {
		get {return m_Aniso;} 
		set { m_Aniso = value; } 
	}
	public float mipmapBias {
		get {return m_MipBias;} 
		set { m_MipBias = value; } 
	}
	public TextureWrapMode wrapMode {
		get { return (TextureWrapMode)m_WrapMode; }
		set { m_WrapMode = (int)value; }
	}
	public int compressionQuality {
		get { return m_CompressionQuality; }
		set { m_CompressionQuality = (int)value; }
	}

	public bool alphaIsTransparency {
		get {return m_AlphaIsTransparency != 0;}
		set { m_AlphaIsTransparency = value ? 1 : 0; }
	}
	
	CONDITIONAL ENABLE_SPRITES
    public int spriteMode {
		get {return m_SpriteMode;}
		set { m_SpriteMode = value; }
	}	

	CONDITIONAL ENABLE_SPRITES
	public float spritePixelsToUnits{
		get {return m_SpritePixelsToUnits; }
		set { m_SpritePixelsToUnits = value; }
	}

	CONDITIONAL ENABLE_SPRITES
	public uint spriteExtrude {
		get { return m_SpriteExtrude; }
		set { m_SpriteExtrude = value; }
	}

	CONDITIONAL ENABLE_SPRITES
	public SpriteMeshType spriteMeshType {
		get { return (SpriteMeshType)m_SpriteMeshType; }
		set { m_SpriteMeshType = (int)value; }
	}

    CONDITIONAL ENABLE_SPRITES
	public int spriteAlignment {
		get {return m_Alignment;}
		set { m_Alignment = value; }
	}

	CONDITIONAL ENABLE_SPRITES
	public Vector2 spritePivot {
		get { return m_SpritePivot; }
		set { m_SpritePivot = value; }
	}

	CONDITIONAL (ENABLE_SPRITES && ENABLE_SPRITECOLLIDER)
	public int spriteColliderAlphaCutoff {
		get { return m_SpriteColliderAlphaCutoff; }
		set { m_SpriteColliderAlphaCutoff = Mathf.Clamp(value, 0, 254); }
	}

	CONDITIONAL (ENABLE_SPRITES && ENABLE_SPRITECOLLIDER)
	public float spriteColliderDetail {
		get { return m_SpriteColliderDetail; }
		set { m_SpriteColliderDetail = value; }
	}

	// Test texture importer settings for equality.
	CUSTOM static bool Equal (TextureImporterSettings a, TextureImporterSettings b)
	{
		return a==b || ExtractMonoObjectData<TextureImporter::Settings>(a) == ExtractMonoObjectData<TextureImporter::Settings>(b);
	}

	// Copy parameters into another TextureImporterSettings object.
	CUSTOM void CopyTo (TextureImporterSettings target)
	{
		Scripting::RaiseIfNull(target);
		ExtractMonoObjectData<TextureImporter::Settings>(target) = ExtractMonoObjectData<TextureImporter::Settings>(self);
	}
	
	// Configure parameters to import a texture for a purpose of ''type'', as described [[TextureImporterType|here]].
	CSRAW public void ApplyTextureType (TextureImporterType type, bool applyAll)
	{
		Internal_ApplyTextureType (this, type, applyAll);
	}
	CUSTOM static private void Internal_ApplyTextureType (TextureImporterSettings s, TextureImporterType type, bool applyAll)
	{
		Scripting::RaiseIfNull(s);
		ExtractMonoObjectData<TextureImporter::Settings>(s).ApplyTextureType ((TextureImporter::TextureType)type, applyAll); 
	}
END

CONDITIONAL ENABLE_SPRITES
// MUST match memory layout of TextureImportInstructions in TextureImporter.h
// Stores active output settings of a [[TextureImporter]]
[System.Serializable]
CLASS TextureImportInstructions
CSRAW
	[SerializeField]
	public TextureFormat     compressedFormat;
	[SerializeField]
	public TextureFormat     uncompressedFormat;
	[SerializeField]
	public TextureFormat     recommendedFormat;
	[SerializeField]
	public TextureFormat     desiredFormat;
	[SerializeField]
	public TextureUsageMode  usageMode;
	[SerializeField]
	public ColorSpace        colorSpace;
	[SerializeField]
	public int               width;
	[SerializeField]
	public int               height;
	[SerializeField]
	public int               compressionQuality;

END

// Imported audio format for [[AudioImporter]].
ENUM AudioImporterFormat
	// Native format
	Native = -1,
	// Ogg compressed audio.
	Compressed = 0
END

// The way we load audio assets [[AudioImporter]].
ENUM AudioImporterLoadType
	// Decompress audio data on load
	DecompressOnLoad = 0,
	// Keep audio compressed in memory
	CompressedInMemory = 1,
	// Stream audio from disc
	StreamFromDisc = 2	
END

CLASS ShaderImporter : AssetImporter
	CUSTOM Shader GetShader ()
	{
		Shader* shader = AssetImporter::GetFirstDerivedObjectAtPath<Shader> (self->GetAssetPathName());
		return Scripting::ScriptingWrapperFor(shader);
	}
	CUSTOM void SetDefaultTextures (string[] name, Texture[] textures)
	{
		vector<string> cnames;
		StringMonoArrayToVector(name, cnames);
		vector<Texture*> cobjects;
		MonoObjectArrayToVector<Texture>(textures, cobjects);
		self->SetDefaultTextures(cnames, cobjects);
	}
	CUSTOM Texture GetDefaultTexture (string name)
	{
		return Scripting::ScriptingWrapperFor(self->GetDefaultTexture(name));
	}
END


OBSOLETE error Setting and getting import channels is not used anymore (use forceToMono instead)
ENUM AudioImporterChannels
	Automatic = 0,
	Mono = 1,
	Stereo = 2,
END



// Audio importer lets you modify [[AudioClip]] import settings from editor scripts.
CLASS AudioImporter : AssetImporter
	
	// Format of imported audio.
	AUTO_PROP AudioImporterFormat format GetFormat SetFormat
	
	OBSOLETE error Setting and getting import channels is not used anymore (use forceToMono instead)
	CSRAW public AudioImporterChannels channels  { get { return 0; } set {}	}
	
	// Compression bitrate.
	AUTO_PROP int compressionBitrate GetBitrate SetBitrate

	// Should audio data be decompressed on load?
        	
	OBSOLETE error Setting/Getting decompressOnLoad is deprecated. Use AudioImporter.loadType instead.
	CSRAW bool decompressOnLoad
	{
		get 
		{
			return (loadType == AudioImporterLoadType.DecompressOnLoad);
		}
		set
		{
			loadType = value ? AudioImporterLoadType.DecompressOnLoad : AudioImporterLoadType.CompressedInMemory;
		}
	}
	
	CUSTOM private void Internal_SetLoadType(int flag)
	{
		self->SetLoadFlag(flag);
	}
	
	CUSTOM private int Internal_GetLoadType()
	{
		return self->GetLoadFlag();
	}
	
	// Is this clip a 2D or 3D sound?
	AUTO_PROP bool threeD Get3D Set3D
	
	// Force this clip to mono?
	AUTO_PROP bool forceToMono GetForceToMono SetForceToMono
	
	// Use hardware voice/decoder if available
	AUTO_PROP bool hardware GetHardware SetHardware
	
	//Set/get the way Unity is loading the Audio data.	
	CSRAW public AudioImporterLoadType loadType	{ get
		{
			return (AudioImporterLoadType)Internal_GetLoadType();
		}
		set
		{
			Internal_SetLoadType((int)value);
		}
	}
	
	//Is this clip loopable?
	AUTO_PROP bool loopable GetLoopable SetLoopable
	
	//*undocumented* Update/cache audio info. important to call this before any of the next. you only need to call it once per audiofile
	CUSTOM internal void updateOrigData() { self->UpdateOrigData(); }
	
	//*undocumented* Duration of imported audio. call updateOrigData before
	CUSTOM_PROP internal int durationMS { return self->GetOrigDuration(); }
	
	// Frequency (sample rate) of imported audio.  call updateOrigData before
	CUSTOM_PROP internal int frequency { return self->GetOrigFrequency(); }
	
	// Original channel count.  call updateOrigData before
	CUSTOM_PROP internal int origChannelCount { return self->GetOrigChannels(); }
	
	// Is original source compressible to Ogg/MP3 (depending on platform)?  call updateOrigData before
	CUSTOM_PROP internal bool origIsCompressible { return self->GetOrigIsCompressible(); }
	
	// Is original source forcable(?) to mono?  call updateOrigData before
	CUSTOM_PROP internal bool origIsMonoForcable { return self->GetOrigIsMonoForcable(); }
	
	//*undocumented* Min bitrate for ogg/mp3 compression.  call updateOrigData before
	CUSTOM private int Internal_GetMinBitrate(int type) { return self->GetMinBitrate((FMOD_SOUND_TYPE)type, self->GetOrigChannels(), self->GetOrigFrequency() );	}
	CSRAW internal int minBitrate(AudioType type) { return Internal_GetMinBitrate((int)type); }
	
	//*undocumented* Max bitrate for ogg/mp3 compression. call updateOrigData before
	CUSTOM private int Internal_GetMaxBitrate(int type) { return self->GetMaxBitrate((FMOD_SOUND_TYPE)type, self->GetOrigChannels(), self->GetOrigFrequency() );	}
	CSRAW internal int maxBitrate(AudioType type) { return Internal_GetMaxBitrate((int)type); }
	
	CUSTOM_PROP internal int defaultBitrate { return self->GetDefaultBitrate() ; }
	
	//*undocumented* Get the format for automatic format
	CUSTOM private int Internal_GetType() { return self->GetOrigType(); }
	CSRAW internal AudioType origType { get { return (AudioType)Internal_GetType(); } }
	
	//*undocumented* Return the size of the original file. Note this is slow
	CUSTOM_PROP internal int origFileSize { return self->GetOrigFileSize(); }
END

// AssetImporter for importing MovieTextures 
CLASS MovieImporter : AssetImporter

	// Quality setting to use when importing the movie. This is a float value from 0 to 1.
	AUTO_PROP float quality GetQuality SetQuality
	
	// Is this a linear texture or an sRGB texture (Only used when performing linear rendering)
	AUTO_PROP bool linearTexture GetLinearSampled SetLinearSampled

	// Duration of the Movie to be imported in seconds
	AUTO_PROP float duration GetDuration

END

// Texture case constants for TrueTypeFontImporter
ENUM FontTextureCase
	// Render characters into font texture at runtime as needed.
	Dynamic = -2,

	// Import a set of Unicode characters common for latin scripts
	Unicode = -1,
	
	// Import basic ASCII character set
	ASCII = 0,

	// Only import upper case ASCII character set
	ASCIIUpperCase = 1,

	// Only import lower case ASCII character set
	ASCIILowerCase = 2,
	
	// Custom set of characters
	CustomSet = 3
END

// Font rendering mode constants for TrueTypeFontImporter
ENUM FontRenderingMode
	// Use Anti-Aliased Font rendering. When using dynamic fonts, this is the mode which is fastest in rendering font textures.
	Smooth = 0,
	// Use Anti-Aliased Font rendering with hinting. This forces character lines to run along pixel boundaries, and generally produces
	HintedSmooth = 1,
	// Use hinted font rendering without anti-aliasing. This is the crispest font rendering option, and may be most readable for small
	HintedRaster = 2,
	// Use the OS default font rendering mode. This selects either [[FontRenderingMode.HintedSmooth]] or
	OSDefault = 3,
END

// AssetImporter for importing Fonts 
CLASS TrueTypeFontImporter : AssetImporter
	
	// Font size to use for importing the characters.
	AUTO_PROP int fontSize GetFontSize SetFontSize
	
	// Use this to adjust which characters should be imported.
	AUTO_PROP FontTextureCase fontTextureCase GetForceTextureCase SetForceTextureCase
	
	OBSOLETE error FontRenderModes are no longer supported.	
	CSRAW private int fontRenderMode { get {return 0; } set {} }

	// If this is enabled, the actual font will be embedded into the asset for Dynamic fonts.
	AUTO_PROP bool includeFontData GetIncludeFontData SetIncludeFontData

	OBSOLETE warning use2xBehaviour is deprecated and will be removed in a future release.
	AUTO_PROP bool use2xBehaviour GetUse2xBehaviour SetUse2xBehaviour
	
	// An array of font names, to be used when includeFontData is set to false.
	CUSTOM_PROP string[] fontNames 
	{
		MonoArray *arr = mono_array_new (mono_domain_get (), mono_get_string_class(), self->GetFontNames().size());
		int idx = 0;
		for (UNITY_VECTOR(kMemFont,UnityStr)::iterator i=self->GetFontNames().begin ();i != self->GetFontNames().end ();i++)
		{
			GetMonoArrayElement<MonoString*> (arr,idx) = scripting_string_new(*i);
			idx++;
		}
		return arr;
	}
	{
		self->GetFontNames().clear();
		for (int i=0;i<mono_array_length_safe(value);i++)
			self->GetFontNames().push_back (scripting_cpp_string_for(GetMonoArrayElement<MonoString*>(value, i)));
	}
	
	// A custom set of characters to be included in the Font Texture. 
	CUSTOM_PROP string customCharacters { return scripting_string_new(self->GetCustomCharacters ()); } { self->SetCustomCharacters (value); }

	// The internal font name of the TTF file.
	CUSTOM_PROP string fontTTFName { return scripting_string_new(self->GetFontNameFromTTFData()); }

	OBSOLETE error Per-Font styles are no longer supported. Set the style in the rendering component, or import a styled version of the font.
	CSRAW private FontStyle style { get {return FontStyle.Normal; } set {} }
	
	// Spacing between character images in the generated texture in pixels. This is useful if you want to render text using a shader which samples pixels outside of the character area (like an outline shader).
	AUTO_PROP int characterSpacing GetCharacterSpacing SetCharacterSpacing
	
	// Border pixels added to character images for padding. This is useful if you want to render text using a shader which needs to render outside of the character area (like an outline shader).
	AUTO_PROP int characterPadding GetCharacterPadding SetCharacterPadding

	// Font rendering mode to use for this font.
	AUTO_PROP FontRenderingMode fontRenderingMode GetFontRenderingMode SetFontRenderingMode

	CUSTOM internal bool IsFormatSupported()
	{
		return self->IsFormatSupported();
	}
	
	// Create an editable copy of the font asset at /path/.
	CUSTOM public Font GenerateEditableFont (string path)
	{
		return Scripting::ScriptingWrapperFor(self->GenerateEditableFont(path));
	}
	
END

CLASS internal InternalMeshUtil
	
	CUSTOM static int GetPrimitiveCount (Mesh mesh) {
		Mesh* m = mesh;
		if( !m )
			return 0;
		return m->GetPrimitiveCount();
	}
	
	CUSTOM static int CalcTriangleCount (Mesh mesh) {
		Mesh* m = mesh;
		if( !m )
			return 0;
		return m->CalculateTriangleCount();
	}
	
	CUSTOM static bool HasNormals (Mesh mesh) {
		Mesh* m = mesh;
		if( !m )
			return false;
		return mesh->IsAvailable(kShaderChannelNormal);
	}

	CUSTOM static string GetVertexFormat (Mesh mesh)
	{
		const Mesh* m = mesh;
		
		std::string ch;
		if( m->IsAvailable(kShaderChannelTexCoord0) ) {
			if( !ch.empty() ) ch += ',';
			ch += "uv";
		}
		if( m->IsAvailable(kShaderChannelTexCoord1) ) {
			if( !ch.empty() ) ch += ',';
			ch += "uv2";
		}
		if( m->IsAvailable(kShaderChannelColor) ) {
			if( !ch.empty() ) ch += ',';
			ch += "colors";
		}
		if( m->GetBoneWeights() ) {
			if( !ch.empty() ) ch += ',';
			ch += "skin";
		}
		return scripting_string_new(ch);
	}
	
	CUSTOM static float GetCachedMeshSurfaceArea (MeshRenderer meshRenderer)
	{
		return meshRenderer->GetCachedSurfaceArea();
	}
	
	CUSTOM static float GetCachedSkinnedMeshSurfaceArea (SkinnedMeshRenderer skinnedMeshRenderer)
	{
		return skinnedMeshRenderer->GetCachedSurfaceArea();
	}
END

CLASS internal AudioUtil
	CUSTOM static void PlayClip(AudioClip clip, int startSample=0, bool loop=false)
	{
		GetAudioManager().PlayClip( clip.GetReference() , startSample, loop);
	}
	
	CUSTOM static void StopClip(AudioClip clip)
	{
		GetAudioManager().StopClip( clip.GetReference() );
	}
	
	CUSTOM static void PauseClip(AudioClip clip)
	{
		GetAudioManager().PauseClip( clip.GetReference() );
	}
	
	CUSTOM static void ResumeClip(AudioClip clip)
	{
		GetAudioManager().ResumeClip( clip.GetReference() );
	}
	
	CUSTOM static void LoopClip(AudioClip clip, bool on)
	{
		GetAudioManager().LoopClip( clip.GetReference(), on );
	}
	
	CUSTOM static bool IsClipPlaying(AudioClip clip)
	{
		return GetAudioManager().IsClipPlaying( clip.GetReference() );
	}
	
	CUSTOM static void StopAllClips()
	{
		GetAudioManager().StopAllClips();
	}
	
	CUSTOM static float GetClipPosition(AudioClip clip)
	{
		return GetAudioManager().GetClipPosition( clip.GetReference() );
	}
	
	CUSTOM static int GetClipSamplePosition(AudioClip clip)
	{
		return GetAudioManager().GetClipSamplePosition( clip.GetReference() );
	}
	
	CUSTOM static void SetClipSamplePosition(AudioClip clip, int iSamplePosition)
	{
		return GetAudioManager().SetClipSamplePosition( clip.GetReference(), iSamplePosition );
	}
		
	CUSTOM static int GetSampleCount(AudioClip clip)
	{
		return clip->GetSampleCount();
	}
	
	CUSTOM static int GetChannelCount(AudioClip clip)
	{
		return clip->GetChannelCount();
	}
	
	CUSTOM static int GetBitRate(AudioClip clip)
	{
		return clip->GetBitRate();
	}
	
	CUSTOM static int GetBitsPerSample(AudioClip clip)
	{
		return clip->GetBitsPerSample();
	}
	
	CUSTOM static int GetFrequency(AudioClip clip)
	{
		return clip->GetFrequency();
	}
	
	CUSTOM static int GetSize(AudioClip clip)
	{
		return clip->GetSize();
	}
	
				
	C++RAW
 inline void DrawSample(Texture2D *tex, int x, int width, int height, float min, float max)
	{
		unsigned char* data = (unsigned char*)tex->GetRawImageData();
		int bpp = GetBytesFromTextureFormat (tex->GetTextureFormat()) / sizeof(unsigned char);	
		
		data += (x * bpp);
		
		float mi = (min / 2.0f) + .5f;
		float ma = (max / 2.0f) + .5f;
		int miny = mi * (float)height;
		int maxy = (ma * (float)height)+1.0f;
		
		for (int y=0;y<height;++y)
		{			
			if ((y > miny) && (y <= maxy))
				data[0] = 255;	//A
			else
				data[0] = 0;	//A
				
			data[1] = 255;		//R
			data[2] = 144;		//G
			data[3] = 0;		//B
			data += (bpp * width);	
		}
	}
	
	CUSTOM static Texture2D GetWaveForm(AudioClip clip, AudioImporter importer, int channel, float width, float height)
	{
		Texture2D *tex = CreateObjectFromCode<Texture2D>();
		tex->SetHideFlags(Object::kHideAndDontSave);
		tex->InitTexture (width, height, kTexFormatARGB32, Texture2D::kNoMipmap, 1);
		
		
		unsigned channels = clip->GetChannelCount();
		AudioImporter& castedImporter = *importer;
		
		for (int x=0;x<width;x++)
		{
			float max; float min;
			float normalizedTime = x / (float) width;
			if (castedImporter.GetPreviewMinMaxSample (normalizedTime, channel, channels, min, max))
			{
				// draw sample
				DrawSample(tex, x, width, height, min, max);
			}				
		}
		
		tex->UpdateImageDataDontTouchMipmap();
		
		return Scripting::ScriptingWrapperFor(tex);
	}
	
	CUSTOM static Texture2D GetWaveFormFast(AudioClip clip, int channel, int fromSample, int toSample, float width, float height)
	{
		Texture2D* tex = GetWaveFormRender().RenderWaveFormAsync(clip, fromSample, toSample, 1024, 1024);
		
		if (tex)
		{
			return Scripting::ScriptingWrapperFor(tex);
		}
		else
			return NULL;
	}
	
	CUSTOM static void ClearWaveForm(AudioClip clip)
	{		
		GetWaveFormRender().ClearWaveForm ( clip );		
	}
	
	CUSTOM static bool HasPreview(AudioClip clip)
	{
		AudioImporter* ai = dynamic_pptr_cast<AudioImporter*> (FindAssetImporterForObject(clip->GetInstanceID()));
		return ai != NULL && ai->HasPreview();
	}
	
	CUSTOM static bool IsCompressed(AudioClip clip)
	{
		return (clip->GetType() != FMOD_SOUND_TYPE_RAW);
	}
	
	CUSTOM static bool IsStreamed(AudioClip clip)
	{
		AudioImporter* ai = dynamic_pptr_cast<AudioImporter*> (FindAssetImporterForObject(clip->GetInstanceID()));
		return ai && (ai->GetLoadFlag() != 0);
	}
	
	CUSTOM static double GetDuration(AudioClip clip)
	{
		return clip->GetLength();
	}
	
	CUSTOM static int GetFMODMemoryAllocated()
	{
		return GetAudioManager().GetMemoryAllocated();	
	}
	
	CUSTOM static float GetFMODCPUUsage()
	{
		return GetAudioManager().GetCPUUsage();	
	}
	
	CUSTOM static bool Is3D(AudioClip clip)
	{
		return clip->Is3D();
	}
	
	CUSTOM static bool IsMovieAudio(AudioClip clip)
	{
		return clip->IsMovieAudio();
	}
	
	CUSTOM static bool IsMOD(AudioClip clip)
	{
		FMOD_SOUND_TYPE type = clip->GetType();
		return 
		((type == FMOD_SOUND_TYPE_XM) ||
		(type == FMOD_SOUND_TYPE_S3M) ||
		(type == FMOD_SOUND_TYPE_MOD) ||
		(type == FMOD_SOUND_TYPE_IT));
	}
	
	CUSTOM static int GetMODChannelCount(AudioClip clip)
	{
		int c=0;
		FMOD::Sound* sound = clip->GetSound();
		if (sound) sound->getMusicNumChannels(&c);
		return c;
	}
	
	CUSTOM static AnimationCurve GetLowpassCurve(AudioLowPassFilter lowPassFilter)
	{
		AnimationCurve* curve = new AnimationCurve(lowPassFilter->GetCustomLowpassLevelCurve());
	
		MonoObject* obj = mono_object_new (mono_domain_get (), MONO_COMMON.animationCurve);
		ExtractMonoObjectData<AnimationCurve*> (obj) = curve;
		return obj;
	}
	
	CUSTOM static Vector3 GetListenerPos()
	{
		AudioListener* listener = GetAudioManager().GetAudioListener();
		if (listener)
			return listener->GetPosition();
		else
			return Vector3f (0, 0, 0);
	}
	
	CUSTOM static void UpdateAudio()
	{
		AudioManager* audioManager = GetAudioManagerPtr();
		if (audioManager)
		{
			audioManager->Update();
		}			
	}
	
	CUSTOM static void SetListenerTransform(Transform t)
	{
		if(t.IsNull())
			return;
		AudioManager* audioManager = GetAudioManagerPtr();
		if (audioManager && audioManager->GetAudioListener())
			audioManager->GetAudioListener()->SetAlternativeTransform(t);
		else
			audioManager->UpdateListener(t->GetPosition(), Vector3f(0.0f, 0.0f, 0.0f),
				NormalizeSafe(t->TransformDirection( Vector3f (0.0f, 1.0f, 0.0f) )),
				NormalizeSafe(t->TransformDirection( Vector3f (0.0f, 0.0f, 1.0f) )));
	}
	
	
	
	CUSTOM static AudioType GetClipType(AudioClip clip)
	{
		return clip->GetType();
	}
	
	CUSTOM static AudioType GetPlatformConversionType(AudioType inType, BuildTargetGroup targetGroup, AudioImporterFormat format)
	{
		return AudioImporter::GetPlatformConversionType((FMOD_SOUND_TYPE)inType, targetGroup, format);
	}
	
	CUSTOM static bool HaveAudioCallback(MonoBehaviour behaviour)
	{
		return behaviour->HaveAudioCallback();		
	}
	
	CUSTOM static int GetCustomFilterChannelCount(MonoBehaviour behaviour)
	{
		return behaviour->GetAudioCustomFilter() ? behaviour->GetAudioCustomFilter()->channelCount : 0;
	}
	
	CUSTOM static int GetCustomFilterProcessTime(MonoBehaviour behaviour)
	{
		return behaviour->GetAudioCustomFilter() ? behaviour->GetAudioCustomFilter()->processTime : 0;
	}
	
	CUSTOM static float GetCustomFilterMaxIn(MonoBehaviour behaviour, int channel)
	{
		return behaviour->GetAudioCustomFilter() ? behaviour->GetAudioCustomFilter()->GetMaxIn(channel) : 0;
	}
	
	CUSTOM static float GetCustomFilterMaxOut(MonoBehaviour behaviour, int channel)
	{
		return behaviour->GetAudioCustomFilter() ? behaviour->GetAudioCustomFilter()->GetMaxOut(channel) : 0;
	}	

	
	
END

// Lightmap format of a [[Texture2D|texture]].
ENUM TextureUsageMode
	// Not a lightmap.
	Default = 0,
	
	// Range [0;2] packed to [0;1] with loss of precision.
	LightmapDoubleLDR = 1,

	// Range [0;8] packed to [0;1] with multiplier stored in the alpha channel.
	LightmapRGBM = 2,

	// Compressed DXT5 normal map
	NormalmapDXT5nm = 3,

	// Plain RGB normal map
	NormalmapPlain = 4
	
END

CLASS internal TextureUtil
	CUSTOM static int GetStorageMemorySize(Texture t)
	{
		#if ENABLE_PROFILER
		return t->GetStorageMemorySize();
		#else
		return 0;
		#endif
	}
	
	CUSTOM static int GetRuntimeMemorySize(Texture t)
	{
		return t->GetRuntimeMemorySize();
	}
	
	CUSTOM static bool IsNonPowerOfTwo(Texture2D t)
	{
		return t->IsNonPowerOfTwo();
	}
	
	CUSTOM static TextureUsageMode GetUsageMode(Texture t)
	{
		return t->GetUsageMode();
	}
	
	CUSTOM static int GetBytesFromTextureFormat( TextureFormat inFormat )
	
	{
		return GetBytesFromTextureFormat( inFormat );
	}
	
	CUSTOM static int GetRowBytesFromWidthAndFormat( int width, TextureFormat format )
	{
		return GetRowBytesFromWidthAndFormat( width, format );
	}
	
	CUSTOM static bool IsValidTextureFormat (TextureFormat format)
	{
		return IsValidTextureFormat( format );
	}

	CUSTOM static bool IsCompressedTextureFormat( TextureFormat format )
	{
		return IsAnyCompressedTextureFormat(format);
	}
	
	CUSTOM static TextureFormat GetTextureFormat( Texture texture )
	{
		return texture->GetEditorUITextureFormat();
	}

	CUSTOM static bool IsAlphaOnlyTextureFormat( TextureFormat format )
	{
		return IsAlphaOnlyTextureFormat(format);
	}

	CUSTOM static bool HasAlphaTextureFormat( TextureFormat format )
	{
		return HasAlphaTextureFormat(format);
	}
	
	CUSTOM static string GetTextureFormatString (TextureFormat format)
	{
		return scripting_string_new(GetTextureFormatString( format ));
	}

	CUSTOM static string GetTextureColorSpaceString( Texture texture )
	{
		return scripting_string_new(GetTextureColorSpaceString (texture->GetActiveTextureColorSpace ()));
	}

	CUSTOM static TextureFormat ConvertToAlphaTextureFormat (TextureFormat format)
	{
		return ConvertToAlphaTextureFormat(format);
	}

	CUSTOM static bool IsDepthRTFormat( RenderTextureFormat format )
	{
		return IsDepthRTFormat(static_cast<RenderTextureFormat>(format));
	}
	
	CUSTOM static bool HasMipMap( Texture t )
	{
		return t->HasMipMap();
	}
	
	CUSTOM static int GetGLWidth( Texture t )
	{
		return t->GetGLWidth();
	}
	
	CUSTOM static int GetGLHeight( Texture t )
	{
		return t->GetGLHeight();
	}
	
	CUSTOM static int CountMipmaps (Texture t)
	{
		return t->CountMipmaps();
	}
	
	CUSTOM static bool GetLinearSampled( Texture t )
	{
		return t->GetStoredColorSpace() == kTexColorSpaceLinear;
	}

	CUSTOM static int GetDefaultCompressionQuality()
	{
		return kTexCompressionNormal;
	}

	CUSTOM static Vector4 GetTexelSizeVector( Texture t )
	{
		return Vector4f(t->GetTexelSizeX(), t->GetTexelSizeY(), t->GetGLWidth(), t->GetGLHeight());
	}

	C++RAW
 static bool ReformatTexture(Texture2D& texture, int width, int height, TextureFormat textureFormat, bool useMipmap, bool linear)
	{
		if( IsAnyCompressedTextureFormat(textureFormat) )
		{
			AssertString ("Compressed textures are not supported for cubemaps");
			return false;
		}
		vector<Image> backup;
		backup.resize (texture.GetImageCount ());
		int framecount = texture.GetImageCount ();
		
		// Save images to backup vector
		for (int image=0;image<framecount;image++)
		{
			backup[image] = Image (width, height, textureFormat);
			if (!texture.ExtractImage (&backup[image], image))
				return false;
		}
		
		// initialize texture with new format
		texture.InitTexture (width, height, textureFormat, useMipmap ? Texture2D::kMipmapMask : Texture2D::kNoMipmap, 6);
		texture.SetStoredColorSpace (linear ? kTexColorSpaceLinear : kTexColorSpaceSRGB);
		
		// Copy back image data
		for (int image=0;image<framecount;image++)
		{
			ImageReference ref;
			if (!texture.GetWriteImageReference (&ref, image, 0))
				return false;
			ref.BlitImage (backup[image], ImageReference::BLIT_BILINEAR_SCALE);
		}
		// update image data and rebuild mipmap
		texture.UpdateImageData ();
		return true;
	}

	// Returns source texture asset assigned to the face of a cubemap
	CUSTOM static Texture2D GetSourceTexture (Cubemap cubemapRef, CubemapFace face)
	{
		Cubemap& cubemap = *cubemapRef;
		return Scripting::ScriptingWrapperFor (cubemap.GetSourceTexture ((CubemapFace)face));
	}

	// Assigns texture asset as a image source for the face of a cubemap
	CUSTOM static void SetSourceTexture (Cubemap cubemapRef, CubemapFace face, Texture2D tex)
	{
		Cubemap& cubemap = *cubemapRef;
		return cubemap.SetSourceTexture ((CubemapFace)face, tex);
	}

	CUSTOM static void CopyTextureIntoCubemapFace( Texture2D textureRef, Cubemap cubemapRef, CubemapFace face )
	{
		Texture2D* srcTexture = textureRef;
		if (!srcTexture)
			return;
			
		Cubemap& cubemap = *cubemapRef;
		
		if (cubemap.GetImageCount () != 6)
		{
			int width = max (1, srcTexture->GetGLWidth ());
			int options = srcTexture->CountMipmaps () == 1 ? Texture2D::kNoMipmap : Texture2D::kMipmapMask;
			int format = srcTexture->GetTextureFormat ();
			if (IsAnyCompressedTextureFormat(format))
			{

				if (HasAlphaTextureFormat(format))
					format = kTexFormatARGB32;
				else
					format = kTexFormatRGB24;
			}
			cubemap.InitTexture (width, width, format, options, 6);
		}
		
		for (int mip=0;mip<cubemap.CountMipmaps ();mip++)
		{
			ImageReference dstImage;

			if (!cubemap.GetWriteImageReference (&dstImage, face, mip))
			{
				ErrorStringObject ("Can't draw into cubemap", &cubemap);
				break;
			}
			
			Image srcImage (dstImage.GetWidth (), dstImage.GetHeight (), dstImage.GetFormat ());
			if (!srcTexture->ExtractImage (&srcImage, 0))
			{
				ErrorStringObject ("Can't read from texture", srcTexture);
				break;
			}
			dstImage.BlitImage (srcImage, ImageReference::BLIT_BILINEAR_SCALE);
			dstImage.FlipImageX();
			dstImage.FlipImageY();
		}
		cubemap.UpdateImageDataDontTouchMipmap ();
	}
	
	CUSTOM static void CopyCubemapFaceIntoTexture( Cubemap cubemapRef, CubemapFace face, Texture2D textureRef )
	{
		Cubemap* cubemap = cubemapRef;
		if (!cubemap)
			return;
		Texture2D* texture = textureRef;
		if (!texture)
			return;
			
		ImageReference dstImage;
		if (!texture->GetWriteImageReference (&dstImage, 0, 0))
		{
			ErrorStringObject ("Can't draw into texture", texture);
			return;
		}
		
		Image srcImage (dstImage.GetWidth(), dstImage.GetHeight(), dstImage.GetFormat());
		if (!cubemap->ExtractImage (&srcImage, face))
		{
			ErrorStringObject ("Can't read from cubemap", cubemap);
			return;
		}
		dstImage.BlitImage (srcImage, ImageReference::BLIT_BILINEAR_SCALE);
		dstImage.FlipImageX();
		dstImage.FlipImageY();
		texture->UpdateImageData ();
	}

	CUSTOM static bool ReformatCubemap (ref Cubemap cubemap, int width, int height, TextureFormat textureFormat, bool useMipmap, bool linear)
	{
		return ReformatTexture ( cubemap.GetReference(), width, height, textureFormat, useMipmap, linear);
	}
	
	CUSTOM static bool ReformatTexture(ref Texture2D texture, int width, int height, TextureFormat textureFormat, bool useMipmap, bool linear)
	{
		return ReformatTexture( texture.GetReference(), width, height, textureFormat, useMipmap, linear);
	}
	
	CUSTOM static void SetAnisoLevelNoDirty (Texture tex, int level) {
		tex->SetAnisoLevelNoDirty (level);
	}
	CUSTOM static void SetWrapModeNoDirty (Texture tex, TextureWrapMode mode) {
		tex->SetWrapModeNoDirty ((int)mode);
	}
	CUSTOM static void SetMipMapBiasNoDirty (Texture tex, float bias) {
		tex->SetMipMapBiasNoDirty (bias);
	}
	CUSTOM static void SetFilterModeNoDirty (Texture tex, FilterMode mode) {
		tex->SetFilterModeNoDirty (mode);
	}
	
	CUSTOM static bool DoesTextureStillNeedToBeCompressed (string assetPath)
	{
		return DoesTextureStillNeedToBeCompressed(assetPath);
	}

	CUSTOM static bool IsCubemapReadable (Cubemap cubemapRef)
	{
		Cubemap* cubemap = cubemapRef;
		return cubemap->GetIsReadable();
	}

	CUSTOM static void MarkCubemapReadable (Cubemap cubemapRef, bool readable)
	{
		Cubemap* cubemap = cubemapRef;
		cubemap->SetIsReadable(readable);
	}

END


// Various utilities for mesh manipulation.
CLASS MeshUtility

    // Will insert per-triangle uv2 in mesh and handle vertex splitting etc
    CSRAW public static void SetPerTriangleUV2( Mesh src, Vector2[] triUV )
    {
        int triCount = InternalMeshUtil.CalcTriangleCount(src);
        int uvCount  = triUV.Length;

        if( uvCount != 3*triCount )
        {
            Debug.LogError( "mesh contains " + triCount + " triangles but " + uvCount + " uvs are provided" );
            return;
        }

        SetPerTriangleUV2NoCheck( src, triUV );
    }

    CUSTOM internal static void SetPerTriangleUV2NoCheck( Mesh src, Vector2[] triUV )
    {
        InsertVertexAttr(*src, 0, &GetMonoArrayElement<Vector2f>(triUV, 0), 0, 0);
    }
    
	CUSTOM internal static Vector2[] ComputeTextureBoundingHull (Texture texture, int vertexCount)
	{
		MonoArray* verts = mono_array_new (mono_domain_get(), GetMonoManager().GetCommonClasses().vector2, vertexCount);
		ComputeTextureBoundingHull (texture, vertexCount, &GetMonoArrayElement<Vector2f>(verts, 0));
		return verts;
	}    

END


// Helpers for builtin arrays ... 
// These are O(n) operations (where List<T>() is used) - the arrays are actually copied (http://msdn.microsoft.com/en-us/library/fkbw11z0.aspx)
// but its pretty helpful for now
CLASS public ArrayUtility
	CSRAW
	
	//appends ''item'' to the end of ''array''
	public static void Add<T>(ref T[] array, T item)
	{
		System.Array.Resize(ref array, array.Length + 1);
		array[array.Length - 1] = item;
	}

	//compares two arrays
	public static bool ArrayEquals<T>(T[] lhs, T[] rhs)
	{
		if (lhs.Length != rhs.Length)
			return false;
		
		for (int i=0;i<lhs.Length;i++)
		{
			if (!lhs[i].Equals(rhs[i]))
				return false;
			
		}
		return true;
	}

	//appends items to the end of array
	public static void AddRange<T>(ref T[] array, T[] items)
	{
		int size = array.Length;
		System.Array.Resize(ref array, array.Length + items.Length);
		for (int i=0;i<items.Length;i++)
			array[size+i] = items[i];
	}

	//inserts item ''item'' at position ''index''
	public static void Insert<T>(ref T[] array, int index, T item)
	{
		ArrayList a = new ArrayList ();
		a.AddRange(array);
		a.Insert(index, item);
		array = a.ToArray(typeof(T)) as T[];
	}
	
	//removes ''item'' from ''array''
	public static void Remove<T>(ref T[] array, T item)
		 
	{			
		List<T> newList = new List<T>(array);			
		newList.Remove(item);			
		array = newList.ToArray();			
	}

	public static List<T> FindAll<T>(T[] array, Predicate<T> match)
    {
        List<T> list = new List<T>(array);
        return list.FindAll(match);
    }
	
	public static T Find<T>(T[] array, Predicate<T> match)
	{
		List<T> list = new List<T>(array);
		return list.Find(match);
	}
	
	//Find the index of the first element that satisfies the predicate
	public static int FindIndex<T>(T[] array, Predicate<T> match)
	{
		List<T> list = new List<T>(array);
		return list.FindIndex(match);
	}
	
	//index of first element with value ''value''
	public static int IndexOf<T>(T[] array, T value)
	{
		List<T> list = new List<T>(array);
		return list.IndexOf(value);
	}
	
	//index of the last element with value ''value''
	public static int LastIndexOf<T>(T[] array, T value)
	{
		List<T> list = new List<T>(array);
		return list.LastIndexOf(value);
	}
	
	//remove element at position ''index''
	public static void RemoveAt<T>(ref T[] array, int index)
	{
		List<T> list = new List<T>(array);
		list.RemoveAt(index);
		array = list.ToArray();
	}
	
	//determines if the array contains the item
	public static bool Contains<T>(T[] array, T item)
	{
		List<T> list = new List<T>(array);
		return list.Contains(item);
	}
	
	//Clears the array
	public static void Clear<T>(ref T[] array)
	{
		System.Array.Clear ( array, 0, array.Length );
		System.Array.Resize(ref array, 0);
	}	
END



CLASS internal OSUtil

	CUSTOM static string[] GetDefaultApps( string fileType )
	{
		std::vector<std::string> paths = AppInfo::GetDefaultApps( fileType );
		return Scripting::StringVectorToMono( paths  );		
	}
	
	CUSTOM static string GetAppFriendlyName( string app )
	{
		return scripting_string_new( AppInfo::GetAppFriendlyName ( app ) );
	}
	
	CUSTOM static string GetDefaultAppPath( string fileType )
	{ 
		return scripting_string_new( AppInfo::GetDefaultAppPath ( fileType ) );
	}
END

CLASS internal TerrainInspectorUtil
	// Calculate the size of the brush with which we are painting trees
	CUSTOM static float GetTreePlacementSize (TerrainData terrainData, int prototypeIndex, float spacing, float treeCount)
	{
        TreeDatabase& db = terrainData->GetTreeDatabase();

        float worldTreeDistance = db.GetPrototypes()[prototypeIndex].treeWidth * spacing;
		float worldTreeSize = worldTreeDistance * sqrt(float(treeCount));
		return worldTreeSize; 
	}
	
	CUSTOM static bool CheckTreeDistance (TerrainData terrainData, Vector3 position, int treeIndex, float distanceBias)
	{
		TreeDatabase& db = terrainData->GetTreeDatabase();
	
        const Vector3f& terrainSize = terrainData->GetHeightmap().GetSize();

		const std::vector<TreeInstance>& treeInstances = db.GetInstances();
		const std::vector<TreeDatabase::Prototype>& treePrototypes = db.GetPrototypes();
		for (std::vector<TreeInstance>::const_iterator it = treeInstances.begin(), end = treeInstances.end(); it != end; ++it)
		{
			Vector3f offset = Scale((position - it->position), terrainSize);
			offset.y  = 0;
			const float sqrDistance = SqrMagnitude(offset);
			const float treeWidthSum =  (treePrototypes[it->index].treeWidth + treePrototypes[treeIndex].treeWidth) * distanceBias * 0.5F;
			if (sqrDistance < treeWidthSum * treeWidthSum)
				return false;
		}
		return true;
	}
	
	CUSTOM static public Vector3 GetPrototypeExtent(TerrainData terrainData, int prototypeIndex)
	{
		TreeDatabase& db = terrainData->GetTreeDatabase();
		return db.GetPrototypes()[prototypeIndex].mesh->GetBounds().GetExtent();
	}
	
	CUSTOM static public int GetPrototypeCount(TerrainData terrainData)
	{
		TreeDatabase& db = terrainData->GetTreeDatabase();
		return db.GetPrototypes().size();
	}
	
	CUSTOM static public bool PrototypeHasMaterials(TerrainData terrainData, int prototypeIndex)
	{
		TreeDatabase& db = terrainData->GetTreeDatabase();
		return !db.GetPrototypes()[prototypeIndex].materials.empty();
	}

	CUSTOM static public void RefreshPhysicsInEditMode ()
	{
		IPhysicsEditor* physicsEditor = GetIPhysicsEditor();
		Assert(physicsEditor != NULL);
		physicsEditor->RefreshWhenPaused();
	}
END

// Exposed as internal, editor-only, because we only need it do make a custom inspector
CLASS internal PhysicsManager : Object
END

// Exposed as internal, editor-only, because we only need it do make a custom inspector
CONDITIONAL ENABLE_2D_PHYSICS
CLASS internal Physics2DSettings : Object
END

// Exposed as internal, editor-only, because we only need it do make a custom inspector
CLASS internal MonoManager : Object
END

// Exposed as internal, editor-only, because we only need it do make a custom inspector
CLASS internal TagManager : Object
	public string m_DefaultExpandedFoldout; 
END


// Unwrapping settings. 
STRUCT UnwrapParam
	// maximum allowed angle distortion (0..1)
	CSRAW public   float angleError;
	// maximum allowed area distortion (0..1)
	CSRAW public   float areaError;
	// this angle (or greater) between triangles will cause seam to be created
	CSRAW public   float hardAngle;
	// how much uv-islands will be padded
	CSRAW public   float packMargin;
        
	CSRAW internal int   recollectVertices;
        
	// Will set default values for params
	CUSTOM static void SetDefaults( out UnwrapParam param )
	{
		param->Reset();
	}
END

// This class holds everything you may need in regard to uv-unwrapping.
CLASS public Unwrapping
    // Will generate per-triangle uv (3 uv pairs for each triangle) with default settings
    CSRAW public static Vector2[] GeneratePerTriangleUV( Mesh src )
    {
        UnwrapParam settings = new UnwrapParam();
        UnwrapParam.SetDefaults(out settings);
        
        return GeneratePerTriangleUV( src, settings );
    }
    
    
    // Will generate per-triangle uv (3 uv pairs for each triangle) with provided settings
    CSRAW public static Vector2[] GeneratePerTriangleUV( Mesh src, UnwrapParam settings )
    {
        return GeneratePerTriangleUVImpl( src, settings );
    }
    

    CUSTOM internal static Vector2[] GeneratePerTriangleUVImpl( Mesh src, UnwrapParam settings )
    {
        int vCount    = src->GetVertexCount();
		if(vCount == 0)
		{
			Scripting::RaiseMonoException("You can generate UVs only for meshes with vertices inited.");
			return 0;
		}
        
        Mesh::TemporaryIndexContainer triangles;
		src->GetTriangles(triangles);

        int triCount  = triangles.size() / 3;
		if(triCount == 0)
		{
			Scripting::RaiseMonoException("You can generate UVs only for meshes with triangles inited.");
			return 0;
		}
        
        MonoArray* genUV = mono_array_new(mono_domain_get(), GetMonoManager().GetCommonClasses().vector2, 3*triCount);
		
		std::vector<Vector3f> srcVertex(vCount);
		if (vCount)
			src->ExtractVertexArray(&srcVertex[0]);
	
		std::vector<Vector2f> srcUV;
		if( src->IsAvailable(kShaderChannelTexCoord0) )
		{
			StrideIterator<Vector2f> uvs = src->GetUvBegin (0);
		    srcUV.resize(3*triCount);
		    for( unsigned indexI = 0 ; indexI < 3*triCount ; ++indexI )
		        srcUV[indexI] = uvs[triangles[indexI]];
		}
		
		std::vector<Vector3f> srcNormal;
		if( src->IsAvailable(kShaderChannelNormal) )
		{
			StrideIterator<Vector3f> normals = src->GetNormalBegin ();
		    srcNormal.resize(3*triCount);
		    for( unsigned indexI = 0 ; indexI < 3*triCount ; ++indexI )
		        srcNormal[indexI] = normals[triangles[indexI]];
		}
		
		settings.recollectVertices = 1;

        UnwrapImpl::GenerateSecondaryUVSet( srcVertex.empty () ? 0 : &srcVertex[0].x, vCount,
                                srcNormal.size() ? &srcNormal[0].x : 0,
                                srcUV.size() ? &srcUV[0].x : 0,
                                &triangles[0], triCount,
                                &GetMonoArrayElement<float>(genUV, 0),
                                settings
                              );

        return genUV;
    }


    // Will auto generate uv2 with default settings for provided mesh, and fill them in
    CSRAW   public static void GenerateSecondaryUVSet( Mesh src )
    {
        MeshUtility.SetPerTriangleUV2(src, GeneratePerTriangleUV(src));
    }

    // Will auto generate uv2 with provided settings for provided mesh, and fill them in    
    CSRAW   public static void GenerateSecondaryUVSet( Mesh src, UnwrapParam settings )
    {
        MeshUtility.SetPerTriangleUV2(src, GeneratePerTriangleUV(src, settings));
    }


END

// Allows to control the lightmapping job.
CLASS public Lightmapping

	// Starts an asynchronous bake job.
	CUSTOM static bool BakeAsync()
	{
		return ComputeLightmaps(true, false);
	}

	// Stars a synchronous bake job.
	CUSTOM static bool Bake()
	{
		return ComputeLightmaps(false, false);
	}
	
	// Starts an asynchronous bake job for the selected objects.
	CUSTOM static bool BakeSelectedAsync()
	{
		return ComputeLightmaps(true, true);
	}

	// Stars a synchronous bake job for the selected objects.
	CUSTOM static bool BakeSelected()
	{
		return ComputeLightmaps(false, true);
	}

	// Starts an asynchronous bake job, but only bakes light probes.
	CUSTOM static bool BakeLightProbesOnlyAsync()
	{
		return ComputeLightmaps(true, false, true);
	}

	// Starts a synchronous bake job, but only bakes light probes.
	CUSTOM static bool BakeLightProbesOnly()
	{
		return ComputeLightmaps(false, false, true);
	}

	// Cancels the currently running asynchronous bake job.
	CUSTOM static void Cancel()
	{
		CancelLightmapping();
	}

	// Returns true when the bake job is running, false otherwise (RO).
	CUSTOM_PROP static bool isRunning
	{
		return IsRunningLightmapping();
	}
	
	// Deletes all lightmap assets and makes all lights behave as if they weren't baked yet.
	CUSTOM static void Clear()
	{
		ClearLightmaps(!GetLightmapEditorSettings().GetLockAtlas());
		DeleteLightmapAssets();
		LightProbeUtils::Clear();
	}
	
	// Calculates a Delaunay Tetrahedralization of the 'positions' point set - the same way the lightmapper
	CUSTOM static void Tetrahedralize(Vector3[] positions, out int[] outIndices, out Vector3[] outPositions)
	{
		int* tetrahedra;
		int tetrahedraCount;
		Vector3f* newPositions;
		int newPositionCount;
		LightProbeUtils::Tetrahedralize(&GetMonoArrayElement<Vector3f> (positions, 0), mono_array_length_safe(positions), &tetrahedra, &tetrahedraCount, &newPositions, &newPositionCount);
		*outIndices = CreateScriptingArray(tetrahedra, tetrahedraCount, MONO_COMMON.int_32);
		*outPositions = CreateScriptingArray(newPositions, newPositionCount, MONO_COMMON.vector3);
	}
END

// Bake quality setting for [[LightmapEditorSettings]].
ENUM LightmapBakeQuality
	// High quality bake for final renderings.
	High = 0,
	
	// Low quality bake for preview renderings.
	Low = 1,
END

// Various settings for the bake.
CLASS public LightmapEditorSettings
	
	// Boosts indirect light (Beast's diffuseBoost property, pow(colorComponent, (1.0 / diffuseBoost))). 
	CUSTOM_PROP static float bounceBoost
	{ return  GetLightmapEditorSettings().GetBounceBoost (); }
	{ GetLightmapEditorSettings().SetBounceBoost (value); }
		
	// Indirect light intensity multiplier.
	CUSTOM_PROP static float bounceIntensity
	{ return  GetLightmapEditorSettings().GetBounceIntensity (); }
	{ GetLightmapEditorSettings().SetBounceIntensity (value); }
	
	// The maximum width of an individual lightmap texture.
	CUSTOM_PROP static int maxAtlasWidth
	{ return  GetLightmapEditorSettings().GetTextureWidth (); }
	{ GetLightmapEditorSettings().SetTextureWidth (value); } 
	
	// The maximum height of an individual lightmap texture.
	CUSTOM_PROP static int maxAtlasHeight
	{ return  GetLightmapEditorSettings().GetTextureHeight (); }
	{ GetLightmapEditorSettings().SetTextureHeight (value); }
	
	// Lightmap resolution in texels per world unit.
	CUSTOM_PROP static float resolution
	{ return  GetLightmapEditorSettings().GetResolution (); }
	{ GetLightmapEditorSettings().SetResolution (value); }
	
	// Last used lightmap resolution (i.e. resolution of the lightmaps currently in the scene) in texels per world unit.
	CUSTOM_PROP static float lastUsedResolution
	{ return  GetLightmapEditorSettings().GetLastUsedResolution (); }
	{ GetLightmapEditorSettings().SetLastUsedResolution (value); }
	
	// Sky light color.
	CUSTOM_PROP static Color skyLightColor
	{ return  GetLightmapEditorSettings().GetSkyLightColor (); }
	{ GetLightmapEditorSettings().SetSkyLightColor (value); }
	
	// Sky light intensity.
	CUSTOM_PROP static float skyLightIntensity
	{ return  GetLightmapEditorSettings().GetSkyLightIntensity (); }
	{ GetLightmapEditorSettings().SetSkyLightIntensity (value); }
	
	// Quality of the bake.
	CUSTOM_PROP static LightmapBakeQuality quality
	{ return  GetLightmapEditorSettings().GetQuality (); }
	{ GetLightmapEditorSettings().SetQuality (value); }
	
	// Whether to use DXT1 compression on the generated lightmaps.
	CUSTOM_PROP static bool textureCompression
	{ return  GetLightmapEditorSettings().GetTextureCompression (); }
	{ GetLightmapEditorSettings().SetTextureCompression (value); }
	
	// Number of light bounces in the global illumination computation (with 0 meaning direct light only).
	CUSTOM_PROP static int bounces
	{ return  GetLightmapEditorSettings().GetBounces (); }
	{ GetLightmapEditorSettings().SetBounces (value); }
	
	// Number of rays used in the final gather integrator.
	CUSTOM_PROP static int finalGatherRays
	{ return  GetLightmapEditorSettings().GetFinalGatherRays (); }
	{ GetLightmapEditorSettings().SetFinalGatherRays (value); }
	
	// Contrast threshold between neighbouring surface points.
	CUSTOM_PROP static float finalGatherContrastThreshold
	{ return  GetLightmapEditorSettings().GetFinalGatherContrastThreshold (); }
	{ GetLightmapEditorSettings().SetFinalGatherContrastThreshold (value); }
	
	// Controls how the irradiance gradient is used in the interpolation.
	CUSTOM_PROP static float finalGatherGradientThreshold
	{ return  GetLightmapEditorSettings().GetFinalGatherGradientThreshold (); }
	{ GetLightmapEditorSettings().SetFinalGatherGradientThreshold (value); }
	
	// The number of final gather points to interpolate between.
	CUSTOM_PROP static int finalGatherInterpolationPoints
	{ return  GetLightmapEditorSettings().GetFinalGatherInterpolationPoints (); }
	{ GetLightmapEditorSettings().SetFinalGatherInterpolationPoints (value); }
	
	// Controls how much Ambient Occlusion to blend into the Final Gather solution.
	CUSTOM_PROP static float aoAmount
	{ return  GetLightmapEditorSettings().GetAOAmount (); }
	{ GetLightmapEditorSettings().SetAOAmount (value); }
	
	// Beyond this distance a ray is considered to be unoccluded.
	CUSTOM_PROP static float aoMaxDistance
	{ return  GetLightmapEditorSettings().GetAOMaxDistance (); }
	{ GetLightmapEditorSettings().SetAOMaxDistance (value); }
	
	// Controls the look of the transition from black to white.
	CUSTOM_PROP static float aoContrast
	{ return  GetLightmapEditorSettings().GetAOContrast (); }
	{ GetLightmapEditorSettings().SetAOContrast (value); }
	
	// If enabled, Beast atlasing won't be run and lightmap indices, tiling and offset won't be modified on Mesh Renderers.
	CUSTOM_PROP static bool lockAtlas
	{ return  GetLightmapEditorSettings().GetLockAtlas (); }
	{ GetLightmapEditorSettings().SetLockAtlas (value); }
	
	// Texel separation between shapes.
	CUSTOM_PROP static int padding
	{ return  GetLightmapEditorSettings().GetPadding (); }
	{ GetLightmapEditorSettings().SetPadding (value); }
	
	CUSTOM internal static Object GetLightmapSettings()
	{
		return Scripting::ScriptingWrapperFor(&GetLightmapSettings());
	} 

END

CLASS internal LightmapVisualization
	
	CUSTOM_PROP static bool enabled
	{ return GetLightmapVisualization().GetEnabled(); }
	{ GetLightmapVisualization().SetEnabled(value); }
	
	CUSTOM_PROP static float shadowDistance
	{ return GetLightmapVisualization().GetShadowDistance(); }
	{ GetLightmapVisualization().SetShadowDistance(value); }
	
	CUSTOM_PROP static bool useLightmaps
	{ return GetLightmapVisualization().GetUseLightmaps(); }
	{ GetLightmapVisualization().SetUseLightmaps(value); }
	
	CUSTOM_PROP static bool showResolution
	{ return GetLightmapVisualization().GetShowResolution(); }
	{ GetLightmapVisualization().SetShowResolution(value); }

	CUSTOM static internal float GetLightmapLODLevelScale (Renderer renderer)
	{
		return GetLightmapLODLevelScale(*renderer);
	}
	
	CUSTOM_PROP static bool showLightProbes
	{ return GetLightProbeVisualizationSettings().GetShowLightProbes(); }
	{ GetLightProbeVisualizationSettings().SetShowLightProbes(value); }
	
	CUSTOM_PROP static bool showLightProbeLocations
	{ return GetLightProbeVisualizationSettings().GetShowLightProbeLocations(); }
	{ GetLightProbeVisualizationSettings().SetShowLightProbeLocations(value); }
	
	CUSTOM_PROP static bool showLightProbeCells
	{ return GetLightProbeVisualizationSettings().GetShowLightProbeCells(); }
	{ GetLightProbeVisualizationSettings().SetShowLightProbeCells(value); }
	
	CUSTOM_PROP static bool dynamicUpdateLightProbes
	{ return GetLightProbeVisualizationSettings().GetDynamicUpdateLightProbes(); }
	{ GetLightProbeVisualizationSettings().SetDynamicUpdateLightProbes(value); }
	
	CUSTOM static internal void DrawPointCloud (Vector3[] unselectedPositions, Vector3[] selectedPositions, Color baseColor, Color selectedColor, float scale, Transform cloudTransform)
	{
		GetLightProbeVisualizationSettings().DrawPointCloud(
					&GetMonoArrayElement<Vector3f> (unselectedPositions, 0),
					mono_array_length_safe (unselectedPositions),
					&GetMonoArrayElement<Vector3f> (selectedPositions, 0),
					mono_array_length_safe (selectedPositions),
					baseColor,
					selectedColor,
					scale,
					cloudTransform);
	}
	
	CUSTOM static internal void DrawTetrahedra (bool shouldRecalculateTetrahedra, Vector3 cameraPosition)
	{
		GetLightProbeVisualizationSettings().DrawTetrahedra(shouldRecalculateTetrahedra, cameraPosition);
	}
	

END

// StaticOcclusionCulling lets you perform static occlusion culling operations
CLASS StaticOcclusionCulling

	// Used to generate static occlusion culling data. This function will not return until occlusion data is generated.
	CUSTOM static bool Compute ()
	{
		return OcclusionCullingTask::GenerateTome();
	}
	
	// Used to compute static occlusion culling data asynchronously.
	CUSTOM static bool GenerateInBackground ()
	{
		return OcclusionCullingTask::GenerateTomeInBackground();
	}

	// Used to cancel asynchronous generation of static occlusion culling data.
	CUSTOM static void Cancel ()
	{
		OcclusionCullingTask::Cancel();
	}

	// Used to check if asynchronous generation of static occlusion culling data is still running.
	CUSTOM_PROP static bool isRunning
	{
		return OcclusionCullingTask::IsRunning();
	}
	
	// Clears the Tome of the opened scene
	CUSTOM static void Clear()
	{
		OcclusionCullingTask::ClearUmbraTome();
	}
	
	/// Getter for the default smallest occluder computation parameter value
	CUSTOM_PROP static float smallestOccluder
	{
		return GetSceneSettings().GetOcclusionBakeSettings().smallestOccluder;
	}
	{
		GetSceneSettings().GetOcclusionBakeSettingsSetDirty().smallestOccluder = value;
	}
	
	CUSTOM_PROP static float smallestHole
	{
		return GetSceneSettings().GetOcclusionBakeSettings().smallestHole;
	}
	{
		GetSceneSettings().GetOcclusionBakeSettingsSetDirty().smallestHole = value;
	}

	CUSTOM_PROP static float backfaceThreshold
	{
		return GetSceneSettings().GetOcclusionBakeSettings().backfaceThreshold;
	}
	{
		GetSceneSettings().GetOcclusionBakeSettingsSetDirty().backfaceThreshold = value;
	}

	CUSTOM_PROP static bool doesSceneHaveManualPortals
	{
		return OcclusionCullingTask::DoesSceneHaveManualPortals();
	}

	// Returns the size in bytes that the Tome data is currently taking up in this scene on disk
	CUSTOM_PROP static int umbraDataSize
	{
		return GetScene().GetUmbraDataSize();
	}

	CUSTOM static void SetDefaultOcclusionBakeSettings ()
	{
		GetSceneSettings().SetDefaultOcclusionBakeSettings();
	}

END

// Used to visualize static occlusion culling at development time in scene view.
CLASS StaticOcclusionCullingVisualization
	// If set to true, visualization of target volumes is enabled.
	CUSTOM_PROP static bool showOcclusionCulling
	{
		return GetOcclusionCullingVisualization()->GetShowOcclusionCulling();
	}
	{
		GetOcclusionCullingVisualization()->SetShowOcclusionCulling(value);
	}
	
	// If set to true, the visualization lines of the PVS volumes will show all cells rather than cells after culling.
	CUSTOM_PROP static bool showPreVisualization
	{
		return GetOcclusionCullingVisualization()->GetShowPreVis();
	}
	{
		GetOcclusionCullingVisualization()->SetShowPreVis(value);
	}
	
	// If set to true, visualization of view volumes is enabled.
	CUSTOM_PROP static bool showViewVolumes
	{
		return GetOcclusionCullingVisualization()->GetShowViewVolumes();
	}
	{
		GetOcclusionCullingVisualization()->SetShowViewVolumes(value);
	}
	
	CUSTOM_PROP static bool showDynamicObjectBounds
	{
		return GetOcclusionCullingVisualization()->GetShowDynamicObjectBounds();
	}
	{
		GetOcclusionCullingVisualization()->SetShowDynamicObjectBounds(value);
	}

	// If set to true, visualization of portals is enabled.
	CUSTOM_PROP static bool showPortals
	{
		return GetOcclusionCullingVisualization()->GetShowPortals();
	}
	{
		GetOcclusionCullingVisualization()->SetShowPortals(value);
	}
	
	// If set to true, visualization of portals is enabled.
	CUSTOM_PROP static bool showVisibilityLines
	{
		return GetOcclusionCullingVisualization()->GetShowVisibilityLines();
	}
	{
		GetOcclusionCullingVisualization()->SetShowVisibilityLines(value);
	}
	
	// If set to true, culling of geometry is enabled.
	CUSTOM_PROP static bool showGeometryCulling
	{
		return GetOcclusionCullingVisualization()->GetShowGeometryCulling();
	}
	{
		GetOcclusionCullingVisualization()->SetShowGeometryCulling(value);
	}

	CUSTOM_PROP static bool isPreviewOcclusionCullingCameraInPVS
	{
		Camera* camera = FindPreviewOcclusionCamera();
		if (camera)
			return GetScene().IsPositionInPVSVolume(camera->GetPosition());
		else
			return false;
	}
	
	
	CUSTOM_PROP static Camera previewOcclusionCamera
	{
		return Scripting::ScriptingWrapperFor(FindPreviewOcclusionCamera());
	}

	//*undoc*
	// This is here because it was released on 3.0 (this is a typo)
	CUSTOM_PROP static Camera previewOcclucionCamera
	{
		return Scripting::ScriptingWrapperFor(FindPreviewOcclusionCamera());
	}

END	



CSRAW
}

namespace UnityEditorInternal
{


CSRAW [StructLayout (LayoutKind.Sequential)]
CLASS internal LogEntry
	CSRAW
	public string condition;
	public int errorNum;
	public string file;
	public int line;
	public int mode;
	public int instanceID;
	public int identifier;
	public int isWorldPlaying;
END

C++RAW

struct MonoLogEntry
{
	MonoString* condition;
	int errorNum;
	MonoString* file;
	int line;
	int mode;
	int instanceID;
	int identifier;
	int isWorldPlaying;
};

// used to pull log messages from Cpp side to mono window
// All functions marked internal may not be called unless you call StartGettingEntries and EndGettingEntries
CLASS internal LogEntries

	CUSTOM static void OpenEntryFile(int index)
	{
		GetEditorMonoConsole().OpenEntryFile(index);
	}

	CUSTOM static string GetStatusText()
	{
		const std::string& text = GetEditorMonoConsole().GetStatusText();
		if (text.empty())
			return NULL;
		else
			return scripting_string_new(text);
	}

	CUSTOM static int GetStatusMask()
	{
		return GetEditorMonoConsole().GetStatusMask();
	}

	// returns total line count
	CUSTOM static int StartGettingEntries()
	{
		return GetEditorMonoConsole().StartGettingEntries();
	}

	CUSTOM_PROP static int consoleFlags { return GetEditorMonoConsole().GetConsoleFlags (); } { GetEditorMonoConsole().SetConsoleFlags (value); }
	CUSTOM static void SetConsoleFlag (int bit, bool value)  { GetEditorMonoConsole().SetConsoleFlag (bit, value); }

	CUSTOM static void EndGettingEntries()
	{
		return GetEditorMonoConsole().EndGettingEntries();
	}
	
	CUSTOM static int GetCount()
	{
		return GetEditorMonoConsole().GetCount();
	}
	
	CUSTOM static void GetCountsByType (ref int errorCount, ref int warningCount, ref int logCount)
	{
		GetEditorMonoConsole().GetCountsByType (errorCount, warningCount, logCount);
	}
	
	CUSTOM static void GetFirstTwoLinesEntryTextAndModeInternal (int row, ref int mask, ref string outString)
	{
		string output;
		GetEditorMonoConsole().GetFirstTwoLinesTextAndModeInternal(row, mask, output);
		outString.str = scripting_string_new(output);
	}
	
	CUSTOM static bool GetEntryInternal(int row, LogEntry outputEntry)
	{
		CppLogEntry* src = GetEditorMonoConsole().GetEntryInternal(row);
		if (src)
		{
			MonoLogEntry& entry = ExtractMonoObjectData<MonoLogEntry>(outputEntry);
			
			entry.condition = scripting_string_new(src->condition);
			entry.errorNum = src->errorNum;
			entry.file = scripting_string_new(src->file);
			entry.line = src->line;
			entry.mode = src->mode;
			entry.instanceID = src->instanceID;
			entry.identifier = src->identifier;
			
			return true;
		}
		else
		{
			return false;
		}
		
	}

	CUSTOM static int GetEntryCount (int row)
	{
		EditorMonoConsole& console = GetEditorMonoConsole ();

		if (row >= console.GetCount ())
		{
			Scripting::RaiseOutOfRangeException ("Log Entry %d does not exist.", row);
			return 0;
		}

		return console.GetEntryCount (row);
	}
	
	CUSTOM static void Clear()
	{
		GetEditorMonoConsole().Clear();
	}

	CUSTOM static int GetStatusViewErrorIndex()
	{
		return GetEditorMonoConsole().GetStatusViewErrorIndex();
	}

	CUSTOM static void ClickStatusBar(int count)
	{
		GetEditorMonoConsole().ClickStatusBar(count);
	}
END

CLASS internal AnimationCurvePreviewCache

	CUSTOM static void ClearCache () { AnimationCurvePreviewCache::Get().ClearCache(); }
	
	C++RAW

	template <class T>
	MonoObject* AnimationCurvePreviewCache_GetPreview_Internal(int previewWidth, int previewHeight, bool useCurveRanges, const Rectf& curveRanges, MonoObject* object, MonoObject* object2, const ColorRGBAf& color)
	{
		if (object == NULL)
			return NULL;
		AnimationCurvePreviewCache& cache = AnimationCurvePreviewCache::Get();
		T& actualObject = *ExtractMonoObjectData<T*>(object);
		AnimationCurvePreviewCache::PreviewSize previewSize(previewWidth, previewHeight);
		if (object2 == NULL)
		{
		return Scripting::ScriptingWrapperFor(useCurveRanges ? 
			cache.GetPreview(previewSize, actualObject, color, curveRanges) : 
			cache.GetPreview(previewSize, actualObject, color)
		);
	}
		else
		{
			T& actualObject2 = *ExtractMonoObjectData<T*>(object2);
			return Scripting::ScriptingWrapperFor(useCurveRanges ? 
				cache.GetPreview(previewSize, actualObject, actualObject2, color, curveRanges) : 
				cache.GetPreview(previewSize, actualObject, actualObject2, color)
			);
		}
	}
	
	CUSTOM static Texture2D GetPropertyPreview (int previewWidth, int previewHeight, bool useCurveRanges, Rect curveRanges, SerializedProperty property, Color color) { 
		return AnimationCurvePreviewCache_GetPreview_Internal<SerializedProperty>(previewWidth, previewHeight, useCurveRanges, curveRanges, property, NULL, color);
	}
	CUSTOM static Texture2D GetPropertyPreviewRegion (int previewWidth, int previewHeight, bool useCurveRanges, Rect curveRanges, SerializedProperty property, SerializedProperty property2, Color color) { 
		return AnimationCurvePreviewCache_GetPreview_Internal<SerializedProperty>(previewWidth, previewHeight, useCurveRanges, curveRanges, property, property2, color);
	}
	
	CUSTOM static Texture2D GetCurvePreview (int previewWidth, int previewHeight, bool useCurveRanges, Rect curveRanges, AnimationCurve curve, Color color) { 
		return AnimationCurvePreviewCache_GetPreview_Internal<AnimationCurve>(previewWidth, previewHeight, useCurveRanges, curveRanges, curve.object, NULL, color);
	}
	CUSTOM static Texture2D GetCurvePreviewRegion (int previewWidth, int previewHeight, bool useCurveRanges, Rect curveRanges, AnimationCurve curve, AnimationCurve curve2, Color color) { 
		return AnimationCurvePreviewCache_GetPreview_Internal<AnimationCurve>(previewWidth, previewHeight, useCurveRanges, curveRanges, curve.object, curve2.object, color);
	}


	// Regions as SerializedProperty
	CSRAW public static Texture2D GetPreview (int previewWidth, int previewHeight, SerializedProperty property, SerializedProperty property2, Color color, Rect curveRanges) { 
		if (property2 == null)
			return GetPropertyPreview (previewWidth, previewHeight, true, curveRanges, property, color);
		else
			return GetPropertyPreviewRegion (previewWidth, previewHeight, true, curveRanges, property, property2, color);
	}
	CSRAW public static Texture2D GetPreview (int previewWidth, int previewHeight, SerializedProperty property, SerializedProperty property2, Color color) { 
		if (property2 == null)
			return GetPropertyPreview (previewWidth, previewHeight, false, new Rect(), property, color);
		else
			return GetPropertyPreviewRegion (previewWidth, previewHeight, false, new Rect(), property, property2, color);		
	}

	// Regions as AnimationCurves
	CSRAW public static Texture2D GetPreview (int previewWidth, int previewHeight, AnimationCurve curve, AnimationCurve curve2, Color color, Rect curveRanges) { 
		return GetCurvePreviewRegion (previewWidth, previewHeight, true, curveRanges, curve, curve2, color);
	}
	CSRAW public static Texture2D GetPreview (int previewWidth, int previewHeight, AnimationCurve curve, AnimationCurve curve2, Color color) { 
		return GetCurvePreviewRegion (previewWidth, previewHeight, false, new Rect(), curve, curve2, color);
	}

	CSRAW public static Texture2D GetPreview (int previewWidth, int previewHeight, SerializedProperty property, Color color, Rect curveRanges) { 
		return GetPropertyPreview(previewWidth, previewHeight, true, curveRanges, property, color);
	}
	CSRAW public static Texture2D GetPreview (int previewWidth, int previewHeight, SerializedProperty property, Color color) { 
		return GetPropertyPreview(previewWidth, previewHeight, false, new Rect(), property, color);
	}
	CSRAW public static Texture2D GetPreview (int previewWidth, int previewHeight, AnimationCurve curve, Color color, Rect curveRanges) { 
		return GetCurvePreview(previewWidth, previewHeight, true, curveRanges, curve, color);
	}	
	CSRAW public static Texture2D GetPreview (int previewWidth, int previewHeight, AnimationCurve curve, Color color) { 
		return GetCurvePreview(previewWidth, previewHeight, false, new Rect(), curve, color);
	}

	C++RAW
 #define GET 	
	
END

CLASS internal CameraUtility
	
	CSRAW public static bool DoesAnyCameraUseDeferred ()
	{ 
		bool deferred = false;
		Camera[] cameras = Camera.allCameras;
		for (int i=0; i<cameras.Length; i++)
		{
			if (cameras[i].actualRenderingPath == RenderingPath.DeferredLighting)
				deferred = true;
		}
		return deferred;
	}
	
END

// Class ID / Class name magic 
CLASS internal BaseObjectTools
        
        // Converts class ID to class name
        CUSTOM static string ClassIDToString (int ID) 
        {
                return scripting_string_new(Object::ClassIDToString (ID));  
        }
        
        // Converts name to class ID 
        CUSTOM static int StringToClassID (string classString) 
        {
               return Object::StringToClassID (classString); 
        }
		
    // Converts name to class ID ignoring case
    CUSTOM static int StringToClassIDCaseInsensitive (string classString) 
    {
		return Object::StringToClassIDCaseInsensitive (classString); 
    }
		
	CUSTOM static bool IsBaseObject(int ID)
	{
		return ClassID(Object) == ID;
	}
	
	CUSTOM static bool IsDerivedFromClassID (int classID, int derivedFromClassID)
	{
		return Object::IsDerivedFromClassID (classID, derivedFromClassID);
	}	

END     


// GradientPreviewCache
CLASS internal GradientPreviewCache

	CUSTOM static void ClearCache () 
	{ 
		GradientPreviewCache::Get().ClearCache(); 
	}
	
	C++RAW

	template <class T>
	MonoObject* GradientPreviewCache_GetPreview_Internal(MonoObject* object)
	{
		if (object == NULL)
			return NULL;
		GradientPreviewCache& cache = GradientPreviewCache::Get();
		T& actualObject = *ExtractMonoObjectData<T*>(object);
		return Scripting::ScriptingWrapperFor(cache.GetPreview(actualObject));
	}
	
	CUSTOM public static Texture2D GetPropertyPreview (SerializedProperty property) 
	{
		return GradientPreviewCache_GetPreview_Internal<SerializedProperty>(property);
	}
	
	CUSTOM public static Texture2D GetGradientPreview (Gradient curve) 
	{ 
		return GradientPreviewCache_GetPreview_Internal<GradientNEW>(curve.object);
	}

	C++RAW
 #undef GET
END



CSRAW }
