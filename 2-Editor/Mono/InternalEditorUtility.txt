C++RAW

#include "UnityPrefix.h"
#include "Configuration/UnityConfigureOther.h"
#include "Editor/Platform/Interface/EditorUtility.h"
#include "Editor/Platform/Interface/EditorWindows.h"
#include "Runtime/Utilities/Argv.h"
#include "Editor/Src/AssetPipeline/BumpMapSettings.h"
#include "Runtime/Shaders/Material.h"
#include "Runtime/Filters/Renderer.h"
#include "Editor/Src/InspectorExpandedState.h"
#include "Editor/Src/AssetPipeline/MdFourGenerator.h"
#include "Editor/Src/AssetPipeline/ObjectHashGenerator.h"
#include "Editor/Src/AssetPipeline/CacheServer/CacheServerCommunicationNodeJS.h"
#include "Editor/Src/HierarchyState.h"
#include "Editor/Src/AssetPipeline/AssetInterface.h"
#include "Editor/Mono/MonoEditorUtility.h"
#include "Editor/Src/Application.h"
#include "Editor/Src/AssetPipeline/MonoCompilationPipeline.h"
#include "Editor/Src/BuildPipeline/BuildTargetPlatformSpecific.h"
#include "Editor/Src/BuildPipeline/BuildSerialization.h"
#include "Editor/Src/Utility/AssetDatabaseProperty.h"
#include "Editor/Src/EditorWindowController.h"
#include "Editor/Src/EditorUserBuildSettings.h"
#include "Editor/Src/DragAndDropForwarding.h"
#include "Runtime/Misc/GameObjectUtility.h"
#include "Editor/Src/Utility/GameObjectHierarchyProperty.h"
#include "Editor/Src/LicenseInfo.h"
#include "Runtime/Graphics/ScreenManager.h"
#include "Runtime/Graphics/Texture2D.h"
#include "Runtime/BaseClasses/Tags.h"
#include "Editor/Src/EditorHelper.h"
#include "Editor/Src/ShaderMenu.h"
#include "Runtime/Misc/PlayerSettings.h"
#include "Editor/Src/Utility/CustomLighting.h"
#include "Runtime/Mono/MonoBehaviour.h"
#include "Editor/Platform/Interface/ColorPicker.h"
#include "Configuration/UnityConfigureRevision.h"
#include "Runtime/Misc/Player.h"
#include "Editor/Platform/Interface/ExternalEditor.h"
#include "Runtime/Camera/RenderManager.h"
#include "Editor/Src/Utility/DiffTool.h"
#include "Editor/Src/Gizmos/GizmoUtil.h"
#include "Configuration/UnityConfigureVersion.h"
#include "Runtime/Mono/MonoScript.h"
#include "Runtime/Scripting/ScriptingExportUtility.h"
#include "Runtime/Misc/QualitySettings.h"
#include "Editor/Src/EditorAssetGarbageCollectManager.h"
#include "Runtime/BaseClasses/Cursor.h"
#include "Editor/Src/RemoteInput/RemoteInput.h"
#include "Runtime/Scripting/Scripting.h"


#if UNITY_WIN
#include "Tools/BugReporterWin/lib/CrashHandler.h"
extern CrashHandler* gUnityCrashHandler;
#endif

using namespace std;

CSRAW
using System;
using UnityEngine;
using Object=UnityEngine.Object;

using UnityEditor;



namespace UnityEditorInternal
{
//*undocumented*
// Keep in sync with CanAppendBuild in EditorUtility.h
ENUM CanAppendBuild
	Unsupported = 0,
	Yes = 1,
	No = 2,
END

//*undocumented*
CLASS InternalEditorUtility
	CUSTOM_PROP static bool inBatchMode
	{
		return IsBatchmode();
	}

	CUSTOM_PROP static bool isHumanControllingUs
	{
		return IsHumanControllingUs();
	}

	CUSTOM static void BumpMapSettingsFixingWindowReportResult(int result)
	{
		BumpMapSettings::Get().PerformUnmarkedBumpMapTexturesFixingAfterDialog(result);
	}

	CUSTOM static bool BumpMapTextureNeedsFixing(Material material)
	{
		return BumpMapSettings::BumpMapTextureNeedsFixing(material.GetReference());
	}

	CUSTOM static void FixNormalmapTexture(Material material)
	{
		BumpMapSettings::FixBumpMapTexture(material.GetReference());
	}

	CUSTOM static string GetEditorAssemblyPath()
	{
		return scripting_string_new(GetMonoManager().GetAssemblyPath(MonoManager::kEditorAssembly));
	}
	CUSTOM static string GetEngineAssemblyPath()
	{
		return scripting_string_new(GetMonoManager().GetAssemblyPath(MonoManager::kEngineAssembly));
	}

	CUSTOM static string CalculateHashForObjectsAndDependencies(Object[] objects)
	{
		vector<Object*> cobjects;
		MonoObjectArrayToVector(objects, cobjects);
		MdFourGenerator generator;
		FeedHashWithObjectAndAllDependencies(generator, cobjects, kSerializeGameRelease | kBuildPlayerOnlySerializeBuildProperties);
		return scripting_string_new(MdFourToString(generator.Finish()));
	}

	CUSTOM static void ExecuteCommandOnKeyWindow (string commandName)
	{
		ExecuteCommandOnKeyWindow (commandName);
	}

	CUSTOM static Material[] InstantiateMaterialsInEditMode (Renderer renderer)
	{
		vector<Material*> materials;
		Renderer* r = renderer;
		int length = r->GetMaterialCount();
		for (int i=0;i<length;i++)
		{
			Material* material = r->GetMaterial(i);
			Material* instantiated = &Material::GetInstantiatedMaterial (material, *r, true);
			if (material != instantiated)
			{
				r->SetMaterial (instantiated, i);
				materials.push_back (instantiated);
			}
		}
		return CreateScriptingArrayFromUnityObjects(materials, ClassID(Material));
	}

	CUSTOM static CanAppendBuild BuildCanBeAppended (BuildTarget target, string location)
	{
#if UNITY_OSX
		if (target == kBuild_iPhone)
		return iOSBuildCanBeAppended(location);
#endif
		if (target == kBuild_Android)
		{
			bool targetIsDirectory = IsDirectoryCreated(location);
			bool exportProject     = GetEditorUserBuildSettings().GetAppendProject();
			if (exportProject)
				return targetIsDirectory ? kCanAppendBuildYes : kCanAppendBuildNo;
			else if (targetIsDirectory) // don't overwrite project directory with .apk file
				return IsDirectoryCreated(location) ? kCanAppendBuildNo : kCanAppendBuildUnsupported;
		}

		return kCanAppendBuildUnsupported;
	}

	CUSTOM static void SetupCustomDll (string dllName, string dllLocation)
	{
		SetupCustomDll(dllName, dllLocation);
	}

	CUSTOM internal static void SetPlatformPath (string path)
	{
		MonoPathContainer::AppendMonoPath (path);
	}

	// This lets you add a MonoScript to a game object directly without any type checks or requiring the .NET representation to be loaded already.
	CUSTOM static int AddScriptComponentUnchecked (GameObject gameObject, MonoScript script)
	{
		string error;
		Unity::Component* component = AddComponentUnchecked(*gameObject, ClassID(MonoBehaviour), script, &error);
		if (!error.empty())
		{
			ErrorStringObject(error, gameObject);
		}
		return component->GetInstanceID();
	}

	CUSTOM static void RequestScriptReload () { GetApplication().RequestScriptReload(); }

	// Repaint all views on next tick. Used when the user changes skins in the prefs.
	CUSTOM static void SwitchSkinAndRepaintAllViews () { GetApplication().SwitchSkinAndRepaintAllViews(); }
	CUSTOM static void RepaintAllViews () { GetApplication().RequestRepaintAllViews(); }

	CUSTOM static bool GetIsInspectorExpanded (Object obj)
	{
		return GetInspectorExpandedState().IsInspectorExpanded(obj);
	}

	CUSTOM static void SetIsInspectorExpanded (Object obj, bool isExpanded)
	{
		GetInspectorExpandedState().SetInspectorExpanded(obj, isExpanded);
	}

	CUSTOM_PROP static int[] expandedProjectWindowItems
	{
		vector<int> expanded = GetProjectWindowHierarchyState ().GetExpandedArray();
		return CreateScriptingArray (&expanded[0], expanded.size(), MONO_COMMON.int_32);
	}
	{
		GetProjectWindowHierarchyState ().SetExpandedArray(&GetMonoArrayElement<int>(value, 0), mono_array_length_safe(value));
	}

	CUSTOM static void SaveToSerializedFileAndForget (Object[] obj, string path, bool allowTextSerialization)
	{
		vector<Object*> objs;
		MonoObjectArrayToVector(obj, objs);
		SaveToSerializedFileAndForget(path, objs, allowTextSerialization);
	}

	CUSTOM static Object[] LoadSerializedFileAndForget (string path)
	{
		vector<Object*> objs;
		LoadSerializedFileAndForget(path, objs);
		return CreateScriptingArrayFromUnityObjects(objs, ClassID(Object));
	}

	CUSTOM static DragAndDropVisualMode ProjectWindowDrag (HierarchyProperty property, bool perform)
	{
		if (property)
		{
			AssetDatabaseProperty* p = ExtractMonoObjectData<AssetDatabaseProperty*>(property);
			return ProjectWindowDrag (p->GetGUID(), p->GetChildLibraryRepresentation(), perform);
		}
		else
		{
			return ProjectWindowDrag (kAssetFolderGUID, NULL, perform);
		}
	}

	CONDITIONAL ENABLE_EDITOR_HIERARCHY_ORDERING
	CUSTOM static bool DragTransformHierarchy (HierarchyProperty property, bool dropUpon)
	{
		if (property)
		{
			GameObjectHierarchyProperty* p = ExtractMonoObjectData<GameObjectHierarchyProperty*>(property);
			return p->DragTransformHierarchy(dropUpon);
		}
		return false;
	}

	CUSTOM static DragAndDropVisualMode HierarchyWindowDrag (HierarchyProperty property, bool perform)
	{
		Object* dropUpon = NULL;
		if (property)
		{
			GameObjectHierarchyProperty* p = ExtractMonoObjectData<GameObjectHierarchyProperty*>(property);
			dropUpon = PPtr<Object> (p->GetInstanceID());
		}

		//@TODO: Support Visual mode (prefab should have copy visualization instead)
		DragAndDropForwarding dragForward (DragAndDropForwarding::kDragIntoTransformHierarchy);
		if (perform)
		{
			if (dragForward.ForwardDragAndDrop (dropUpon))
				return DragAndDrop::kDragOperationLink;
		}
		else
		{
			if (dragForward.CanHandleDragAndDrop (dropUpon))
				return DragAndDrop::kDragOperationLink;
		}
		return DragAndDrop::kDragOperationNone;
	}
	
	CUSTOM internal static DragAndDropVisualMode InspectorWindowDrag (Object[] targets, bool perform)
	{
		vector<Object*> objs;
		MonoObjectArrayToVector(targets, objs);
		
		DragAndDropForwarding dragForward(DragAndDropForwarding::kDragIntoInspectorWindow);
		int res = kRejectedDrop;
		if (perform)
		{
			for (int i=0; i<objs.size(); i++)
			{
				res = dragForward.ForwardDragAndDrop (objs[i]);
				if (res == kRejectedDrop)
					break;
			}
		}
		else
		{
			for (int i=0; i<objs.size(); i++)
			{
				res = dragForward.CanHandleDragAndDrop (objs[i]);
				if (res == kRejectedDrop)
					break;
			}
		}

		return res;
	}

	CUSTOM static DragAndDropVisualMode SceneViewDrag (Object dropUpon, Vector3 worldPosition, Vector2 viewportPosition, bool perform)
	{
		DragAndDropForwarding dragForward (DragAndDropForwarding::kDragIntoSceneWindow);
		DragAndDropForwarding::DragInfo info;
		info.position = worldPosition;
		info.viewportPos = viewportPosition;

		if (perform)
		{
			return dragForward.ForwardDragAndDrop (dropUpon, &info);
		}
		else
		{
			return dragForward.CanHandleDragAndDrop (dropUpon);
		}
	}

	THREAD_SAFE
	CUSTOM static bool HasMaint ()
	{
		return LicenseInfo::Flag (lf_maint_client);
	}

	THREAD_SAFE
	CUSTOM static bool HasPro ()
	{
		return LicenseInfo::Flag (lf_pro_version);
	}

	CUSTOM static bool HasAdvancedLicenseOnBuildTarget (BuildTarget target)
	{
		return HasAdvancedLicenseOnBuildTarget(target);
	}

	CUSTOM static Rect GetBoundsOfDesktopAtPoint(Vector2 pos)
	{
		#if UNITY_WIN
		return GetScreenManager().GetBoundsOfDesktopAtPoint(pos);
		#else
		// not used on OSX anywhere. Need to do: CGGetDisplaysWithPoint, CGDisplayBounds
		Scripting::RaiseMonoException("Not implemented on OSX.");
		return Rectf();
		#endif
	}

	CUSTOM_PROP static string[] tags
	{
		UnsignedToString tags = GetTags ();
		MonoArray *arr = mono_array_new (mono_domain_get (), mono_get_string_class(), tags.size());
		int idx = 0;
		for (UnsignedToString::iterator i=tags.begin ();i != tags.end ();i++)
		{
			GetMonoArrayElement<MonoString*> (arr,idx) = scripting_string_new(i->second);
			idx++;
		}
		return arr;
	}

	CUSTOM_PROP static string[] layers
	{
		const string *layernames[32];
		int stringCount = 0;
		for (int i=0;i<32;i++)
		{
			if (!LayerToString (i).empty ())
			{
				layernames[stringCount++] = &LayerToString (i);
			}
		}
		MonoArray *arr = mono_array_new (mono_domain_get (), mono_get_string_class(), stringCount);
		for (int i=0;i<stringCount;i++)
		{
			GetMonoArrayElement<MonoString*> (arr,i) = scripting_string_new(*layernames[i]);
		}

		return arr;
	}

	CUSTOM internal static string GetSortingLayerName(int index)
	{
		return scripting_string_new (GetSortingLayerName(index));
	}
	CUSTOM internal static string GetSortingLayerNameFromUniqueID(int id)
	{
		return scripting_string_new (GetSortingLayerNameFromUniqueID(id));
	}
	CUSTOM internal static int GetSortingLayerUserID(int index)
	{
		return GetSortingLayerUserID(index);
	}
	CUSTOM internal static int GetSortingLayerCount()
	{
		return GetSortingLayerCount();
	}
	CUSTOM internal static void SetSortingLayerName(int index, string name)
	{
		::SetSortingLayerName(index, name);
	}
	CUSTOM internal static void SetSortingLayerLocked(int index, bool locked)
	{
		::SetSortingLayerLocked(index, locked);
	}
	CUSTOM internal static bool GetSortingLayerLocked(int index)
	{
		return ::GetSortingLayerLocked(index);
	}
	CUSTOM internal static bool IsSortingLayerDefault(int index)
	{
		return ::IsSortingLayerDefault(index);
	}
	CUSTOM internal static void AddSortingLayer()
	{
		::AddSortingLayer();
	}
	CUSTOM internal static void UpdateSortingLayersOrder()
	{
		::UpdateSortingLayersOrder();
	}
	CUSTOM_PROP internal static string[] sortingLayerNames
	{
		const int n = GetSortingLayerCount();
		MonoArray *arr = mono_array_new (mono_domain_get (), mono_get_string_class(), n);
		for (int i = 0; i < n; ++i)
			GetMonoArrayElement<MonoString*> (arr,i) = scripting_string_new(GetSortingLayerName(i));
		return arr;
	}
	CUSTOM_PROP internal static int[] sortingLayerUniqueIDs
	{
		const int n = GetSortingLayerCount();
		MonoArray *arr = mono_array_new (mono_domain_get (), MONO_COMMON.int_32, n);
		for (int i = 0; i < n; ++i)
			Scripting::SetScriptingArrayElement(arr, i, GetSortingLayerUniqueID(i));
		return arr;
	}


	CUSTOM static Object GetObjectFromInstanceID (int instanceID)
	{
		return Scripting::ScriptingWrapperFor(PPtr<Object>(instanceID));
	}

	CUSTOM static int GetClassIDWithoutLoadingObject (int instanceID)
	{
		return GetClassIDWithoutLoadingObject(instanceID);
	}

	CUSTOM static Object GetLoadedObjectFromInstanceID (int instanceID)
	{
		return Scripting::ScriptingWrapperFor(Object::IDToPointer(instanceID));
	}

	CUSTOM static string GetLayerName (int layer)
	{
		return scripting_string_new(LayerToString (layer));
	}

	CUSTOM_PROP static  string unityPreferencesFolder
	{
		return scripting_string_new(GetUnityPreferencesFolder());
	}

	CUSTOM static string GetExternalScriptEditor()
	{
		return scripting_string_new(GetExternalScriptEditor());
	}

	CUSTOM static string GetExternalScriptEditorArgs()
	{
		return scripting_string_new(GetExternalScriptEditorArgs());
	}

	CUSTOM static void ReloadWindowLayoutMenu ()
	{
		ReloadWindowLayoutMenu();
	}

	CUSTOM static void RevertFactoryLayoutSettings (bool quitOnCancel)
	{
		RevertFactorySettings (quitOnCancel);
	}

	CUSTOM static void LoadDefaultLayout ()
	{
		LoadDefaultLayout ();
	}

	CUSTOM static void SetupShaderMenu (Material material)
	{
		SetupShaderPopupMenu(*material);
	}

	CUSTOM static string GetFullUnityVersion ()
	{
		return scripting_string_new(UNITY_VERSION_FULL_NICE);
	}

	CUSTOM static string GetUnityBuildBranchUrl ()
	{
		return scripting_string_new(UNITY_VERSION_BRANCH_URL);
	}

	CUSTOM static int GetUnityVersionDate ()
	{
		return UNITY_VERSION_DATE;
	}

	CUSTOM static int GetUnityRevision ()
	{
		return UNITY_VERSION_BLD;
	}

	CUSTOM static bool IsUnityBeta ()
	{
		return UNITY_IS_BETA;
	}

	CUSTOM static string GetUnityCopyright ()
	{
		return scripting_string_new(UNITY_COPYRIGHT);
	}
	CUSTOM static string GetLicenseInfo ()
	{
		return scripting_string_new(GetApplication().GetLicenseInfoText());
	}

	CUSTOM static int[] GetLicenseFlags()
	{
		vector<int> flags;
		GetApplication().GetLicenseFlags(flags);
		MonoArray* arr = mono_array_new(mono_domain_get(), MONO_COMMON.int_32, flags.size());
		for ( int i = 0; i < flags.size(); ++i)
			Scripting::SetScriptingArrayElement(arr,i,flags[i]);
		return arr;
	}

	CUSTOM static string GetAuthToken ()
	{
		return scripting_string_new(LicenseInfo::Get()->GetAuthToken());
	}

	CUSTOM static void OpenEditorConsole () {
		OpenWithDefaultApp (GetEditorConsoleLogPath());
	}


	CUSTOM static int GetGameObjectInstanceIDFromComponent(int instanceID)
	{
		Unity::Component* com = dynamic_instanceID_cast<Unity::Component*> (instanceID);
		if (com && com->GetGameObjectPtr())
			return com->GetGameObjectPtr()->GetInstanceID();
		else
			return 0;
	}


	CUSTOM static Color[] ReadScreenPixel (Vector2 pixelPos, int sizex, int sizey) {
		int bpp;
		unsigned char* srcData = ReadScreenPixels(pixelPos.x, pixelPos.y,sizex,sizey,&bpp);

		MonoArray* array = mono_array_new (mono_domain_get (), GetMonoManager().GetCommonClasses().color, sizex * sizey);
		if( srcData )
		{
			int count = 0;
			for (int ay = 0; ay < sizex; ay++)
			{
				for (int ax = 0; ax < sizey; ax++)
				{
					unsigned char *sample = srcData + bpp * ( ay * sizey + ax);
					ColorRGBAf col(((float)*sample)/255,((float)*(sample + 1))/255,((float)*(sample + 2))/255,1);
					Scripting::SetScriptingArrayElement(array, count, (ColorRGBAf) col);
					count++;
				}
			}
		}
		else
		{
			for (int i=0;i<sizex*sizey;i++)
				Scripting::SetScriptingArrayElement(array, i, ColorRGBAf(1,1,1,1));
		}
		return array;
	}

	CUSTOM static void OpenPlayerConsole () {
		#if !UNITY_WIN
			OpenWithDefaultApp (GetPlayerConsoleLogPath());
		#else
			DisplayDialog("not yet!", "TODO: this is not implemented on windows yet", "ok");
		#endif
	}

	CUSTOM static Resolution GetDesktopResolution () {
		ScreenManager::Resolution res;
		res.width = 640;
		res.height = 480;
		res.refreshRate = 60;

		#if UNITY_OSX

		CFDictionaryRef currentMode = CGDisplayCurrentMode( CGMainDisplayID() );
		CFNumberRef value;
		value = (CFNumberRef)CFDictionaryGetValue(currentMode, kCGDisplayWidth);
		if( value != NULL )
			CFNumberGetValue( value, kCFNumberIntType, &res.width );
		value = (CFNumberRef)CFDictionaryGetValue(currentMode, kCGDisplayHeight);
		if( value != NULL )
			CFNumberGetValue( value, kCFNumberIntType, &res.height );
		value = (CFNumberRef)CFDictionaryGetValue(currentMode, kCGDisplayRefreshRate);
		if( value != NULL )
			CFNumberGetValue( value, kCFNumberIntType, &res.refreshRate );

		#elif UNITY_WIN

		const ScreenManagerWin& screen = GetScreenManager();
		res.width = screen.GetDesktopWidth();
		res.height = screen.GetDesktopHeight();

		#elif UNITY_LINUX
		const ScreenManagerLinux& screen = GetScreenManager ();
		res.width = screen.GetDesktopWidth ();
		res.height = screen.GetDesktopHeight ();

		#else
		#error "Unknown platform"
		#endif

		return res;
	}

	CSRAW public static string TextifyEvent(Event evt)
	{
		if (evt == null)
			return "none";

		string text = null;

		switch (evt.keyCode)
		{
			case KeyCode.Keypad0: text = "[0]"; break;
			case KeyCode.Keypad1: text = "[1]"; break;
			case KeyCode.Keypad2: text = "[2]"; break;
			case KeyCode.Keypad3: text = "[3]"; break;
			case KeyCode.Keypad4: text = "[4]"; break;
			case KeyCode.Keypad5: text = "[5]"; break;
			case KeyCode.Keypad6: text = "[6]"; break;
			case KeyCode.Keypad7: text = "[7]"; break;
			case KeyCode.Keypad8: text = "[8]"; break;
			case KeyCode.Keypad9: text = "[9]"; break;
			case KeyCode.KeypadPeriod: text = "[.]"  ;break;
			case KeyCode.KeypadDivide: text = "[/]"  ;break;
			case KeyCode.KeypadMinus: text = "[-]"  ;break;
			case KeyCode.KeypadPlus: text = "[+]"  ;break;
			case KeyCode.KeypadEquals: text = "[=]"  ;break;

			case KeyCode.KeypadEnter: text = "enter"  ;break;
			case KeyCode.UpArrow: text = "up"  ;break;
			case KeyCode.DownArrow: text = "down"  ;break;
			case KeyCode.LeftArrow: text = "left"  ;break;
			case KeyCode.RightArrow: text = "right"  ;break;

			case KeyCode.Insert: text = "insert"  ;break;
			case KeyCode.Home: text = "home"  ;break;
			case KeyCode.End: text = "end"  ;break;
			case KeyCode.PageUp: text = "page up"  ;break;
			case KeyCode.PageDown: text = "page down"  ;break;

			case KeyCode.Backspace: text = "backspace" ; break;
			case KeyCode.Delete: text = "delete" ; break;

			case KeyCode.F1: text = "F1"; break;
			case KeyCode.F2: text = "F2"; break;
			case KeyCode.F3: text = "F3"; break;
			case KeyCode.F4: text = "F4"; break;
			case KeyCode.F5: text = "F5"; break;
			case KeyCode.F6: text = "F6"; break;
			case KeyCode.F7: text = "F7"; break;
			case KeyCode.F8: text = "F8"; break;
			case KeyCode.F9: text = "F9"; break;
			case KeyCode.F10: text = "F10"; break;
			case KeyCode.F11: text = "F11"; break;
			case KeyCode.F12: text = "F12"; break;
			case KeyCode.F13: text = "F13"; break;
			case KeyCode.F14: text = "F14"; break;
			case KeyCode.F15: text = "F15"; break;


			case KeyCode.Escape: text = "[esc]"; break;
			case KeyCode.Return: text = "return"; break;

			default: text = "" + evt.keyCode; break;

		}

		string modifiers = string.Empty;
		if (evt.alt)		modifiers += "Alt+";
		if (evt.command)	modifiers += Application.platform==RuntimePlatform.OSXEditor ? "Cmd+" : "Ctrl+";
		if (evt.control)	modifiers += "Ctrl+";
		if (evt.shift)		modifiers += "Shift+";

		return modifiers + text;
	}

	CUSTOM_PROP static float defaultScreenWidth { return GetPlayerSettings().defaultScreenWidth; }
	CUSTOM_PROP static float defaultScreenHeight { return GetPlayerSettings().defaultScreenHeight; }
	CUSTOM_PROP static float defaultWebScreenWidth { return GetPlayerSettings().defaultWebScreenWidth; }
	CUSTOM_PROP static float defaultWebScreenHeight { return GetPlayerSettings().defaultWebScreenHeight; }
	CUSTOM_PROP static float remoteScreenWidth { return RemoteScreenWidth(); }
	CUSTOM_PROP static float remoteScreenHeight { return RemoteScreenHeight(); }

	CUSTOM static string[] GetAvailableDiffTools ()
	{
		return Scripting::StringVectorToMono(GetAvailableDiffTools());
	}

	CUSTOM static string GetNoDiffToolsDetectedMessage()
	{
		return scripting_string_new(GetNoDiffToolsDetectedMessage());
	}

	CUSTOM static Bounds TransformBounds (Bounds b, Transform t)
	{
		AABB result;
		TransformAABB (b, t->GetLocalToWorldMatrix(), result);
		return result;
	}

	CUSTOM static void SetCustomLighting (Light[] lights, Color ambient)
	{
		CustomLighting::Get().SetCustomLighting (lights, ambient);
	}

	CUSTOM static void RemoveCustomLighting ()
	{
		CustomLighting::Get().RemoveCustomLighting ();
	}

	CUSTOM static bool CalculateShouldEnableLights ()
	{
		return CustomLighting::Get().CalculateShouldEnableLights ();
	}

	CUSTOM static bool HasFullscreenCamera ()
	{
		return GetRenderManager().HasFullscreenCamera();
	}

	CUSTOM static void ResetCursor ()
	{
		#if UNITY_WIN
		Cursors::ResetCursor ();
		#endif
	}

	CUSTOM static Bounds CalculateSelectionBounds (bool usePivotOnlyForParticles)
	{
		return CalculateSelectionBounds(usePivotOnlyForParticles);
	}

	CUSTOM_PROP static bool ignoreInspectorChanges { return GetApplication().GetIgnoreInspectorChanges(); }


	CUSTOM public static void OnGameViewFocus(bool focus)
	{
		SetPlayerFocus(focus);
	}

	CUSTOM public static bool OpenFileAtLineExternal (string filename, int line)
	{
		return OpenFileAtLine (filename, line, GetExternalScriptEditor (), GetExternalScriptEditorArgs (), kOpenFileExternalEditor);
	}

	CUSTOM internal static UnityEditor.Scripting.MonoIsland[] GetMonoIslands ()
	{
		return GetAllManagedMonoIslands ();
	}

	CUSTOM public static bool Xbox360GenerateSPAConfig(string spaPath)
	{
		return GenerateSPAConfig(spaPath);
	}

	CUSTOM public static bool Xbox360SaveSplashScreenToFile(Texture2D image, string spaPath)
	{
		return Xbox360SaveSplashScreenToFile(image, spaPath);
	}
	
	CUSTOM public static bool CanConnectToCacheServer ()
	{
		return CanConnectToCacheServer();
	}

	CUSTOM public static string GetCrashReportFolder ()
	{ 
		#if UNITY_WIN
		return scripting_string_new(gUnityCrashHandler->GetCrashReportFolder()); 
		#else
		return scripting_string_new("");
		#endif
	}

	CSRAW internal static bool RunningUnderWindows8(bool orHigher = true)
	{
		if (Application.platform == RuntimePlatform.WindowsEditor)
        {
            OperatingSystem sys = System.Environment.OSVersion;
			int major = sys.Version.Major;
			int minor = sys.Version.Minor;
			// Window 8 is technically version 6.2
			if (orHigher)
				return major > 6 || (major == 6 && minor >= 2);
			else
				return major == 6 && minor == 2;
        }
        return false;
	}
END

CSRAW }
