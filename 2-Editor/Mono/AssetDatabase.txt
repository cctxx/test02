C++RAW

#include "UnityPrefix.h"
#include "Editor/Src/Utility/AssetDatabaseProperty.h"
#include "Editor/Src/GUIDPersistentManager.h"
#include "Runtime/Utilities/FileUtilities.h"
#include "Editor/Src/AssetPipeline/AssetInterface.h"
#include "Editor/Src/AssetPipeline/AssetDatabase.h"
#include "Editor/Src/AssetPipeline/AssetLabelsDatabase.h"
#include "Editor/Src/AssetPipeline/AssetImporter.h"
#include "Editor/Src/AssetPipeline/AssetPathUtilities.h"
#include "Editor/Src/EditorHelper.h"
#include "Editor/Mono/MonoEditorUtility.h"
#include "Runtime/Graphics/Texture2D.h"
#include "Editor/Src/BuildPipeline/BuildSerialization.h"
#include "Editor/Src/PackageUtility.h"
#include "Runtime/Mono/MonoBehaviour.h"
#include "Editor/Src/Gizmos/GizmoUtil.h"
#include "Runtime/Scripting/ScriptingExportUtility.h"
#include "Editor/Src/Utility/MiniAssetIconCache.h"
#include "Runtime/Scripting/Scripting.h"

using namespace std;

std::string ConvertPathSeperators (const string& value)
{
	string copy = value;
	ConvertSeparatorsToUnity(copy);
	return copy;
}

CSRAW
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngineInternal;
using Object=UnityEngine.Object;

namespace UnityEditor
{

ENUM RemoveAssetOptions
	// The asset should be moved to trash.
	MoveAssetToTrash = 0,
	// Delete the asset without moving it to the trash.
	DeleteAssets = 2 
END

// Asset importing options.
CSRAW
[Flags]
ENUM ImportAssetOptions
	// Default import options.
	Default = 0,

	// User initiated asset import.
	ForceUpdate = 1,

	// Import all assets synchronously.
	ForceSynchronousImport = 8,

	// When a folder is imported, import all its contents as well.
	ImportRecursive = 256,

	// Force a full reimport but don't download the assets from the cache server.
	DontDownloadFromCacheServer = 8192,
	
	// Forces asset import as uncompressed for edition facilities.
	ForceUncompressedImport = 16384
END


// An Interface for accessing assets and performing operations on assets.
CLASS AssetDatabase

	///*listonly*
	CSRAW public static bool Contains (Object obj)
	{		
		return Contains (obj.GetInstanceID());
	}

	// Is object an asset?
	CUSTOM static bool Contains (int instanceID)
	{
		GUIDPersistentManager& pm = GetGUIDPersistentManager ();
		string path = pm.GetPathName ( instanceID );
		return (!path.empty());	
	}
	
	// Create a new folder.
	CUSTOM static string CreateFolder (string parentFolder, string newFolderName)
	{
		UnityGUID guid;
		if (GetGUIDPersistentManager().PathNameToGUID(ConvertPathSeperators(parentFolder), &guid))
		{
			return scripting_string_new (GUIDToString (AssetInterface::Get ().CreateFolder (guid, newFolderName)));
		}
		
		return scripting_string_new("");
	}
	
	///*listonly*
	CSRAW public static bool IsMainAsset (Object obj)
	{
		return IsMainAsset(obj.GetInstanceID());
	}

	// Is asset a main asset in the project window?
	CUSTOM public static bool IsMainAsset (int instanceID)
	{
		return IsMainAsset(instanceID);
	}

	
	///*listonly*
	CSRAW public static bool IsSubAsset(Object obj)
	{
		return IsSubAsset(obj.GetInstanceID());
	}
	// Is asset a sub asset?
	CUSTOM public static bool IsSubAsset (int instanceID)
	{
		return IsSubAsset(instanceID);
	}

	// Creates a new unique path for an asset.
	CUSTOM static string GenerateUniqueAssetPath (string path)
	{
		return scripting_string_new(GetGUIDPersistentManager().GenerateUniqueAssetPathName(ConvertPathSeperators(path)));
	}
	
	
	// Begin Asset importing. This lets you group several asset imports together into one larger import.
	CUSTOM static void StartAssetEditing ()
	{
		AssetInterface::Get().StartAssetEditing();
	}
	
	// Stop Asset importing. This lets you group several asset imports together into one larger import.
	CUSTOM static void StopAssetEditing ()
	{
		AssetInterface::Get().StopAssetEditing ();
	}

	// Checks if an asset file can be moved from one folder to another. (Without actually moving the file)
	CUSTOM static string ValidateMoveAsset (string oldPath, string newPath)
	{
		UnityGUID guid = GetGUIDPersistentManager ().CreateAsset (ConvertPathSeperators(oldPath));
		return scripting_string_new(AssetDatabase::Get().ValidateMoveAsset (guid, ConvertPathSeperators(newPath)));
	}
	
	// Move an asset file from one folder to another.
	CUSTOM static string MoveAsset (string oldPath, string newPath)
	{
		UnityGUID guid = GetGUIDPersistentManager ().CreateAsset (ConvertPathSeperators(oldPath));
		return scripting_string_new (AssetInterface::Get().MoveAsset (guid, ConvertPathSeperators(newPath)));
	}

	// Rename an asset file.
	CUSTOM static string RenameAsset (string pathName, string newName)
	{
		UnityGUID guid = GetGUIDPersistentManager ().CreateAsset (ConvertPathSeperators(pathName));
		return scripting_string_new(AssetInterface::Get().RenameAsset(guid, ConvertPathSeperators(newName)));
	}

	// Moves the asset at path to the trash.
	CUSTOM static bool MoveAssetToTrash (string path)
	{
		return AssetInterface::Get().MoveToTrash (ConvertPathSeperators(path));
	}

	// Deletes the asset file at path.
	CUSTOM static bool DeleteAsset (string path)
	{
		return AssetInterface::Get().DeleteAsset (ConvertPathSeperators(path));
	}

	// Import asset at path.
	CUSTOM static void ImportAsset (string path, ImportAssetOptions options = ImportAssetOptions.Default)
	{
		AssetInterface::Get().ImportAtPath (ConvertPathSeperators(path), options);
	}

	// Duplicates the asset at /path/ and stores it at /newPath/
	CUSTOM static bool CopyAsset (string path, string newPath)
	{
		UnityGUID guid = GetGUIDPersistentManager ().CreateAsset (ConvertPathSeperators(path));
		return AssetInterface::Get().CopyAsset (guid, ConvertPathSeperators(newPath));
	}

	// Writes the import settings to disk.
	CUSTOM static bool WriteImportSettingsIfDirty (string path)
	{
		UnityGUID guid = GetGUIDPersistentManager ().CreateAsset (ConvertPathSeperators(path));
		return AssetDatabase::Get().WriteImportSettingsIfDirty (guid);
	}
	
	// Creates a new asset at path.
	CUSTOM static void CreateAsset (Object asset, string path)
	{
		std::string pathName = GetGoodPathNameForGUID (path);
		if (TrimSlash(pathName) == "assets")
		{
			ErrorString ("CreateAsset: Cannot create Assets Folder!");
			return;
		}

		if (!AssetInterface::Get ().CreateSerializedAsset (*asset, ConvertPathSeperators(path), AssetInterface::kDeleteExistingAssets | AssetInterface::kWriteAndImport | AssetInterface::kForceImportImmediate))
		{
			Scripting::RaiseMonoException("Creating asset at path %s failed.", path.AsUTF8().c_str());
		}
	}

	// Adds /objectToAdd/ to an existing asset at /path/.
	CUSTOM static void AddObjectToAsset (Object objectToAdd, string assetPath)
	{
		//@TODO: This can add assets to anything, do asset database checks if the operaiton is sensible
		MakeAssetPersistent((EditorExtension&)*objectToAdd, ConvertPathSeperators(assetPath));
	}
	
	// Adds /objectToAdd/ to an existing asset identified by /assetObject/.
	CSRAW static public void AddObjectToAsset (Object objectToAdd, Object assetObject)
	{
		AddObjectToAsset_OBJ_Internal(objectToAdd, assetObject);
	}
	
	CUSTOM private static void AddObjectToAsset_OBJ_Internal (Object newAsset, Object sameAssetFile)
	{
		//@TODO: This can add assets to anything, do asset database checks if the operaiton is sensible
		AddAssetToSameFile((EditorExtension&)*newAsset, (EditorExtension&)*sameAssetFile);
	}

	// Returns the path name relative to the project folder where the asset is stored
	CUSTOM public static string GetAssetPath (Object assetObject)
	{
		return scripting_string_new(GetAssetPathFromObject(assetObject));
	}

	CSRAW public static string GetAssetPath(int instanceID)
	{
		return GetAssetPathFromInstanceID(instanceID);
	}

	CUSTOM private static string GetAssetPathFromInstanceID (int instanceID)
	{
		return scripting_string_new(GetAssetPathFromInstanceID(instanceID));
	}
	
	CUSTOM internal static int GetMainAssetInstanceID (string assetPath)
	{
		return GetMainAssetInstanceID (assetPath);
	}
	

	// Returns the path name relative to the project folder where the asset is stored
	CUSTOM public static string GetAssetOrScenePath (Object assetObject)
	{
		return scripting_string_new(GetAssetOrScenePath(assetObject));
	}
	
	// Gets the path to the text .meta file associasted with an asset
	THREAD_SAFE CUSTOM static string GetTextMetaDataPathFromAssetPath(string path)
	{
		string metaPath = GetTextMetaDataPathFromAssetPath(path);
		return scripting_string_new(metaPath);
	}
	
	// Returns the first asset object of type __type__ at given path __assetPath__.
	CSRAW [TypeInferenceRule(TypeInferenceRules.TypeReferencedBySecondArgument)]
	CUSTOM static Object LoadAssetAtPath (string assetPath, Type type)
	{
		return LoadAssetAtPath (ConvertPathSeperators(assetPath), type);
	}

	// Returns the main asset object at /assetPath/.
	CUSTOM static Object LoadMainAssetAtPath (string assetPath)
	{
		return Scripting::ScriptingWrapperFor(GetMainAsset(ConvertPathSeperators(assetPath)));
	}
	
	// Returns all asset representations at /assetPath/.
	CUSTOM static Object[] LoadAllAssetRepresentationsAtPath (string assetPath)
	{
		vector<PPtr<Object> > representations;
		GetAllAssetRepresentations(ConvertPathSeperators(assetPath), representations);
		return CreateScriptingArrayFromUnityObjects(representations, ClassID(Object));
	}
	
	// Returns an array of all asset objects at /assetPath/. 
	CUSTOM static Object[] LoadAllAssetsAtPath (string assetPath)
	{
		return GetMonoAllAssets(ConvertPathSeperators(assetPath));
	}
	
	//*undocumented*
	CUSTOM static string[] GetAllAssetPaths ()
	{
		AssetDatabase &assets = AssetDatabase::Get ();
		MonoArray *arr = mono_array_new (mono_domain_get (), mono_get_string_class (), assets.size() );
		int index = 0;
			
		for (Assets::const_iterator i=assets.begin ();i != assets.end ();i++, index++)
		{
			Scripting::SetScriptingArrayElement (arr, index, scripting_string_new (GetAssetPathFromGUID (i->first)));
		}

		return arr;
	}

	OBSOLETE error Please use AssetDatabase.Refresh instead
	CSRAW public static void RefreshDelayed (ImportAssetOptions options) { }

	OBSOLETE error Please use AssetDatabase.Refresh instead
	CSRAW public static void RefreshDelayed () { }
	
	// Import any changed assets.
	CUSTOM static void Refresh (ImportAssetOptions options = ImportAssetOptions.Default)
	{
		AssetInterface::Get().Refresh(options);
	}


	
	///*listonly*
	CUSTOM static bool OpenAsset (int instanceID, int lineNumber = -1) { return OpenAsset(instanceID, lineNumber); }
	
	// Opens the asset with associated application.
	CSRAW static public bool OpenAsset (Object target, int lineNumber = -1)
	{
		if (target)
			return OpenAsset(target.GetInstanceID(), lineNumber);
		else
			return false;
	}

	// Opens the asset(s) with associated application(s).
	CSRAW static public bool OpenAsset (Object[] objects)
	{
		bool allOpened = true;
		foreach (Object obj in objects)
			if (!OpenAsset (obj))
				allOpened = false;

		return allOpened;
	}

	// Get the GUID for the asset at /path/
	CUSTOM static string AssetPathToGUID (string path)
	{
		UnityGUID guid;
		if (GetGUIDPersistentManager().PathNameToGUID(ConvertPathSeperators(path), &guid))
			return scripting_string_new(GUIDToString(guid));
		else
			return scripting_string_new("");
	}

	// Translate a GUID to its current asset path
	CUSTOM static string GUIDToAssetPath (string guid)
	{
		return scripting_string_new(GetAssetPathFromGUID(StringToGUID(guid)));
	}

    CUSTOM internal static unsigned int GetAssetHashFromPath (string path)
	{		
		if (const Asset* asset = AssetDatabase::Get().AssetPtrFromPath (path) )
			return (unsigned int)(asset->hash.PackToUInt32());
		return 0;
	}

	CUSTOM internal static int GetInstanceIDFromGUID (string guid)
	{		
		if (const Asset* asset = AssetDatabase::Get().AssetPtrFromGUID (StringToGUID(guid) ) )
			return asset->mainRepresentation.object.GetInstanceID();
		return 0;		
	}	

	// Writes all unsaved asset changes to disk.
	CUSTOM static void SaveAssets ()  { AssetInterface::Get().SaveAssets(); }

	// Retrieves an icon for the asset at the given asset path.
	CUSTOM static Texture GetCachedIcon (string path)
	{
		return Scripting::ScriptingWrapperFor(GetCachedAssetDatabaseIcon (ConvertPathSeperators(path)));
	}
	
	//*undocumented*
	CUSTOM_PROP internal static bool isLocked
	{
		return AssetInterface::Get().IsLocked();
	}
	
	// Replaces that list of labels on an asset.
	CUSTOM static void SetLabels(Object obj, string[] labels)
	{
		vector<UnityStr> converted;
		StringMonoArrayToVector(labels, converted);
		
		UnityGUID guid = ObjectToGUID(obj);
		AssetDatabase::Get().GetLabelsDatabase().SetLabels(guid, converted);
		
	}

	CUSTOM private static void INTERNAL_GetAllLabels (out string[] labels, out float[] scores)
	{
		const std::map<UnityStr, float>& source = AssetDatabase::Get().GetLabelsDatabase().GetAllLabels();
		*labels = mono_array_new (mono_domain_get (), mono_get_string_class(), source.size());
		*scores = mono_array_new(mono_domain_get(), MONO_COMMON.floatSingle, source.size());
		int i=0;
		for (std::map<UnityStr, float>::const_iterator iter = source.begin(); iter != source.end(); ++iter, ++i)
		{
			Scripting::SetScriptingArrayElement(*labels,i,MonoStringNew(iter->first));
			Scripting::SetScriptingArrayElement(*scores,i,iter->second);
		}
		
	}
	
	CSRAW internal static Dictionary<string, float> GetAllLabels()
	{
		string[] labels;
		float[] scores;
		INTERNAL_GetAllLabels(out labels, out scores);
		
		Dictionary<string,float> res = new Dictionary<string,float>(labels.Length);
		for ( int i = 0 ; i < labels.Length; ++i )
		{
			res[labels[i]]=scores[i];
		}
		return res;
	}

	// Returns all labels attached to a given asset.
	CUSTOM static string[] GetLabels( Object obj )
	{
		UnityGUID guid = ObjectToGUID(obj);
		const std::vector<UnityStr>& res = AssetDatabase::Get().GetLabelsDatabase().GetLabels(guid);
		return Scripting::StringVectorToMono(res);
		
	}

	// Removes all labels attached to an asset. 
	CUSTOM static void ClearLabels( Object obj )
	{
		UnityGUID guid = ObjectToGUID(obj);
		AssetDatabase::Get().GetLabelsDatabase().ClearLabels(guid);
	}

	// Match labels in asset
	CUSTOM internal static string[] MatchLabelsPartial(Object obj, string partial)
	{
		UnityGUID guid = ObjectToGUID(obj);
		vector<string> result;
		string arg = partial;
		result = AssetDatabase::Get().GetLabelsDatabase().MatchLabelsPartial(guid, arg);
		return Scripting::StringVectorToMono(result);
	}

	// Given an asset __pathName__, returns the list of all assets it depends on.
	CSRAW static string[] GetDependencies(string pathName)
	{
		string[] input = new string[1];
		input[0]=pathName;
		return GetDependencies(input);
	}
	
	// Given an array of __pathNames__, returns the list of all assets that the assets depend on.
	CUSTOM static string[] GetDependencies(string[] pathNames)
	{
		set<UnityGUID> cguids = MonoPathsToGUIDs(pathNames);
		set<UnityGUID> dependencies = CollectAllDependencies(cguids);
		cguids.insert(dependencies.begin(), dependencies.end());
		return GUIDsToMonoPaths( cguids );
	}
		
	///*listonly*
	CSRAW public static void ExportPackage(string assetPathName, string fileName )
	{
		string[] input = new string[1];
		input[0]=assetPathName;
		ExportPackage(input, fileName, ExportPackageOptions.Default);
	}

	///*listonly*
	CSRAW public static void ExportPackage(string assetPathName, string fileName, ExportPackageOptions flags )
	{
		string[] input = new string[1];
		input[0]=assetPathName;
		ExportPackage(input, fileName, flags);
	}
	
	// Exports the assets identified by __assetPathNames__ to a unitypackage file in __fileName__.
	CUSTOM public static void ExportPackage(string[] assetPathNames, string fileName, ExportPackageOptions flags = ExportPackageOptions.Default)
	{
		set<UnityGUID> cguids = MonoPathsToGUIDs(assetPathNames);
		AssetDatabase* db = &AssetDatabase::Get();
		
		if ( (flags & 2) > 0 ) // recurse
		{
			if( mono_array_length_safe(assetPathNames) == 0 ) // empty list of pathNames + recurse implies get all assets
				db->CollectAllChildren(kAssetFolderGUID, &cguids);
			else
			{
				for ( set<UnityGUID>::iterator i = cguids.begin(); i != cguids.end(); ++i )
				{
					db->CollectAllChildren(*(i), &cguids);
				}
			}
		}
		
		if ( (flags & 4) > 0 ) // include dependencies
		{
			set<UnityGUID> dependencies = CollectAllDependencies(cguids);
			cguids.insert(dependencies.begin(), dependencies.end());
		}
		
		if ( (flags & 8) > 0 ) // include library assets
		{
			set<UnityGUID> roots = db->GetAllRootGUIDs();
			for ( set<UnityGUID>::iterator i = roots.begin(); i != roots.end(); ++i )
			{
				if ( *i != kAssetFolderGUID )
					cguids.insert(*i);
			}
		}
		
		if ( cguids.empty() )
			Scripting::RaiseMonoException("Could not find any assets to export");
		
		if ( (flags & 1) > 0 ) // interactive
			DelayedExportPackage( cguids, fileName );
		else
			ExportPackage( cguids, fileName, true );
	}
	
	// Imports package at __packagePath__ into the current project.
	CSRAW public static void ImportPackage(string packagePath, bool interactive)
	{
		string packageIconPath;
		AssetsItem[] items = AssetServer.ImportPackageStep1(packagePath, out packageIconPath);
		if ( items == null )
			return;
		if ( interactive )
			PackageImport.ShowImportPackage(items, packageIconPath);
		else
			AssetServer.ImportPackageStep2 (items);
		
	}

	CUSTOM internal static string GetUniquePathNameAtSelectedPath (string fileName)
	{
		UnityGUID parentGuid = GetSelectedAsset ();
		return scripting_string_new (GetGUIDPersistentManager ().GenerateUniqueAssetPathName (parentGuid, fileName));
	}

	///*listonly*
	CSRAW public static bool IsOpenForEdit (UnityEngine.Object assetObject)
	{
		string assetPath = GetAssetOrScenePath (assetObject);
		return IsOpenForEdit (assetPath);
	}
	
	///*listonly*
	CSRAW public static bool IsOpenForEdit (string assetPath)
	{
		string message = "";
		return IsOpenForEdit (assetPath, out message);
	}
	
	///*listonly*
	CSRAW public static bool IsOpenForEdit (UnityEngine.Object assetObject, out string message)
	{
		string assetPath = GetAssetOrScenePath (assetObject);
		return IsOpenForEdit (assetPath, out message);
	}

	// Use IsOpenForEdit to determine if the asset is open for edit by the version control.
	CSRAW public static bool IsOpenForEdit (string assetPath, out string message)
	{
		return AssetModificationProcessorInternal.IsOpenForEdit(assetPath, out message);
	}
	
END

CSRAW }
