C++RAW

#include "UnityPrefix.h"
#include "Runtime/Profiler/ProfilerHistory.h"
#include "Runtime/Profiler/ProfilerConnection.h"
#include "Runtime/Profiler/ProfilerProperty.h"
#include "Runtime/Profiler/ProfilerFrameData.h"
#include "Runtime/Profiler/ProfilerStats.h"
#include "Runtime/Scripting/ScriptingUtility.h"
#include "Runtime/Profiler/CollectProfilerStats.h"
#include "Runtime/Scripting/ScriptingExportUtility.h"
#if UNITY_EDITOR
	#include "Editor/Src/EditorUserBuildSettings.h"
#endif

using namespace std;

CSRAW
using System;
using UnityEngine;
using Object=UnityEngine.Object;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Collections;
using System.Collections.Generic;

namespace UnityEditorInternal
{

//*undocumented
ENUM ProfilerViewType 
	Hierarchy = 0,
	Timeline = 1,
	RawHierarchy = 2
END

//*undocumented
ENUM ProfilerMemoryView
	Simple = 0,
	Detailed = 1
END

//*undocumented
ENUM ProfilerColumn 
	FunctionName = 0,
	TotalPercent,
	SelfPercent,
	Calls,
	GCMemory,
	TotalTime,
	SelfTime,
	DrawCalls,
	TotalGPUTime,
	SelfGPUTime,
	TotalGPUPercent,
	SelfGPUPercent,
	WarningCount,
	ObjectName
END

//	SelfGPUTime,
//	GPUTimePercent,
//	SelfGPUTimePercent,


//*undocumented
ENUM ProfilerArea
	CPU,
	GPU,
	Rendering,
	Memory,
	Audio,
	Physics,
	Physics2D,
	AreaCount
END


//*undocumented
//@TODO: This should be renamed to LoadedObjectMemoryType like on C++. But should be done on the memory profiler branch.
ENUM MemoryInfoGCReason
	SceneObject = 0,
	BuiltinResource = 1,
	MarkedDontSave = 2,
	AssetMarkedDirtyInEditor = 3,
	
	SceneAssetReferencedByNativeCodeOnly = 5,
	SceneAssetReferenced = 6,
	
	AssetReferencedByNativeCodeOnly = 8,
	AssetReferenced = 9,

	NotApplicable = 10
END

//*undocumented
[System.Serializable]
[StructLayout (LayoutKind.Sequential)]
CLASS ObjectMemoryInfo
	CSRAW public int    instanceId;
	CSRAW public int    memorySize;
	CSRAW public int    count;
	CSRAW public int    reason;
	CSRAW public string name;
	CSRAW public string className;
END

//*undocumented
[System.Serializable]
[StructLayout (LayoutKind.Sequential)]
CLASS ObjectMemoryStackInfo
	CSRAW public bool   expanded;
	CSRAW public bool   sorted;
	CSRAW public int    allocated;
	CSRAW public int    ownedAllocated;
	CSRAW public ObjectMemoryStackInfo[] callerSites;
	CSRAW public string name;
END

//*undocumented
CLASS ProfilerDriver
	
	
	// This can be used to profile specific parts of the editor
	CUSTOM static void BeginFrame ()
	{
		UnityProfiler::Get().StartProfilingMode(kProfilerGame);
	}

	// SA: ProfilerDriver.BeginFrame
	CUSTOM static void EndFrame ()
	{
		UnityProfiler::Get().EndProfilingMode(kProfilerGame);
	}
	
	CUSTOM static int GetNextFrameIndex (int frame)
	{
		return ProfilerHistory::Get().GetNextFrameIndex(frame);
	}	

	CUSTOM static int GetPreviousFrameIndex (int frame)
	{
		return ProfilerHistory::Get().GetPreviousFrameIndex(frame);
	}	

	CUSTOM_PROP static int firstFrameIndex
	{
		return ProfilerHistory::Get().GetFirstFrameIndex();
	}	

	CUSTOM_PROP static int lastFrameIndex
	{
		return ProfilerHistory::Get().GetLastFrameIndex();
	}	

	CUSTOM_PROP static int maxHistoryLength
	{
		return ProfilerHistory::Get().GetMaxFrameHistoryLength();
	}	
	
	CUSTOM_PROP static string selectedPropertyPath
	{
		return scripting_string_new(ProfilerHistory::Get().GetSelectedPropertyPath());
	}
	{
		ProfilerHistory::Get().SetSelectedPropertyPath(value);
	}

	CUSTOM_PROP static bool profileEditor
	{
		return UnityProfiler::Get().GetProfileEditor();
	}
	{
		UnityProfiler::Get().SetProfileEditor(value);
	}

	
	CUSTOM_PROP static bool deepProfiling
	{
		return UnityProfiler::Get().GetDeepProfiling();
	}
	{
		UnityProfiler::Get().SetDeepProfiling(value);
	}

	CUSTOM static string GetFormattedStatisticsValue (int frame, int identifier)
	{
		return scripting_string_new(ProfilerHistory::Get().GetFormattedStatisticsValue(frame, identifier));
	}

	CUSTOM static void GetStatisticsValues (int identifier, int firstFrame, float scale, float[] buffer, out float maxValue)
	{
		return ProfilerHistory::Get().GetStatisticsValuesBatch(identifier, firstFrame, scale, &GetMonoArrayElement<float>(buffer, 0), mono_array_length_safe(buffer), maxValue);
	}

	CUSTOM static void ClearAllFrames ()
	{
		return ProfilerHistory::Get().CleanupFrameHistory ();
	}

	CUSTOM static string[] GetAllStatisticsProperties ()
	{
		vector<string> values;
		ProfilerHistory::Get().GetAllStatisticsProperties(values);
		return Scripting::StringVectorToMono(values);
	}	

	CUSTOM static string[] GetGraphStatisticsPropertiesForArea (ProfilerArea area)
	{
		vector<string> values;
		ProfilerHistory::Get().GetGraphStatisticsPropertiesForArea(area, values);
		return Scripting::StringVectorToMono(values);
	}	


	CUSTOM static int GetStatisticsIdentifier (string propertyName)
	{
		#if ENABLE_PROFILER && UNITY_EDITOR
		return ProfilerHistory::Get().GetStatisticsIdentifier(propertyName);
		#else
		return -1;
		#endif
	}

	CUSTOM static internal void CaptureHeapshot ()
	{
		#if ENABLE_PROFILER && UNITY_EDITOR
		ProfilerConnection::Get().SendCaptureHeapshotMessage();
		#endif
 	}
 	
	CUSTOM static int[] GetAvailableProfilers ()
	{
		vector<UInt32> values;
		ProfilerConnection::Get().SetupTargetSpecificConnection(GetEditorUserBuildSettings().GetActiveBuildTarget());
		ProfilerConnection::Get().GetAvailableProfilers(values);
		return CreateScriptingArray(&values[0], values.size(), GetMonoManager().GetCommonClasses().int_32);
	}	

	CUSTOM static string GetConnectionIdentifier (int guid)
	{
		return scripting_string_new(ProfilerConnection::Get().GetConnectionIdentification(guid));
	}	

	CUSTOM static bool IsIdentifierConnectable (int guid)
	{
		return ProfilerConnection::Get().IsIdentifierConnectable(guid);
	}

	CUSTOM static internal bool IsIdentifierOnLocalhost (int guid)
	{
		return ProfilerConnection::Get().IsIdentifierOnLocalhost(guid);
	}

	CUSTOM static internal bool IsConnectionEditor ()
	{
		return ProfilerConnection::Get().IsConnectionEditor();
	}

	CUSTOM static void DirectIPConnect (string IP)
	{
		#if ENABLE_PROFILER && UNITY_EDITOR
		ProfilerConnection::Get().DirectIPConnect(IP);
		#endif
	}

	CUSTOM_PROP static int connectedProfiler
	{
		return ProfilerConnection::Get().GetConnectedProfiler();
	}
	{
		ProfilerConnection::Get().SetConnectedProfiler(value);
	}
	
	CUSTOM_PROP static string miniMemoryOverview
	{
		return scripting_string_new(GetMiniMemoryOverview().c_str());
	}	

	CUSTOM static string GetOverviewText (ProfilerArea profilerArea, int frame)
	{
		return scripting_string_new(ProfilerHistory::Get().GetOverviewTextForProfilerArea(frame, profilerArea).c_str());
	}	

	CUSTOM_PROP static uint usedHeapSize
	{
		return GetUsedHeapSize();
	}

	CUSTOM_PROP static uint objectCount
	{
		return Object::GetLoadedObjectCount ();
	}

	CUSTOM_PROP static bool isGPUProfilerBuggyOnDriver
	{
		return ProfilerHistory::Get().IsGPUProfilerBuggyOnDriver();
	}
	
	CUSTOM_PROP static bool isGPUProfilerSupportedByOS
	{
		return ProfilerHistory::Get().IsGPUProfilerSupportedByOS();
	}
	
	CUSTOM_PROP static bool isGPUProfilerSupported
	{
		return ProfilerHistory::Get().IsGPUProfilerSupported();
	}
	
	CUSTOM static void RequestObjectMemoryInfo ()
	{
		ProfilerConnection::Get().SendGetObjectMemoryProfile();
	}
	
END


//*undocumented
// ProfilerProperty provides access to the profile information
CLASS ProfilerProperty

	CSRAW IntPtr m_Ptr;

	C++RAW
 #define GET ExtractMonoObjectData<ProfilerProperty*>(self)	
	
	CUSTOM ProfilerProperty ()
	{
		GET = new ProfilerProperty();
	}

	THREAD_SAFE
	CUSTOM public void Dispose ()
	{
		delete GET;
		GET = NULL;
	}
	
	CSRAW ~ProfilerProperty () { Dispose (); }
	
	CUSTOM void Cleanup ()
	{
		GET->CleanupProperty();
	}

	CUSTOM bool Next (bool enterChildren)
	{
		return GET->GetNext(enterChildren);
	}
	
	CUSTOM void SetRoot (int frame, ProfilerColumn profilerSortColumn, ProfilerViewType viewType)
	{
		GET->SetRoot (frame, profilerSortColumn, viewType);
	}	

	CUSTOM void InitializeDetailProperty (ProfilerProperty source)
	{
		GET->InitializeDetailProperty(*ExtractMonoObjectData<ProfilerProperty*>(source));
	}	


	CUSTOM_PROP bool HasChildren
	{
		return GET->HasChildren();
	}

	CUSTOM_PROP bool onlyShowGPUSamples
	{
		return GET->GetOnlyShowGPUSamples();
	}
	{
		return GET->SetOnlyShowGPUSamples(value);
	}


	CUSTOM_PROP int[] instanceIDs
	{
		dynamic_array<SInt32> instanceIDs;
		GET->GetInstanceIDs(instanceIDs);
		return CreateScriptingArray(&instanceIDs[0], instanceIDs.size(), MONO_COMMON.int_32);
	}
	
	CUSTOM string GetTooltip (ProfilerColumn column)
	{
		return scripting_string_new(GET->GetTooltip(column));
	}

	CUSTOM_PROP int depth
	{
		return GET->GetDepth();
	}
	CUSTOM_PROP string propertyPath
	{
		return scripting_string_new(GET->GetFunctionPath());
	}

	CUSTOM string GetColumn (ProfilerColumn column)
	{
		return scripting_string_new(GET->GetProfilerColumn(column));
	}
	
	CUSTOM_PROP string frameFPS
	{
		return scripting_string_new(GET->GetFrameFPS());
	}	

	CUSTOM_PROP string frameTime
	{
		return scripting_string_new(GET->GetFrameTime());
	}
	
	CUSTOM_PROP string frameGpuTime
	{
		return scripting_string_new(GET->GetFrameGpuTime());
	}	

	CUSTOM_PROP bool frameDataReady
	{
		return (GET->GetFrameData() != NULL);
	}	


	C++RAW
 #undef GET

END


///*undocumented
CLASS ProfilerFrameDataIterator

	CSRAW IntPtr m_Ptr;

	C++RAW #define GET ExtractMonoObjectData<ProfilerFrameDataIterator*>(self)	
	
	CUSTOM ProfilerFrameDataIterator ()
	{
		GET = new ProfilerFrameDataIterator();
	}

	THREAD_SAFE
	CUSTOM public void Dispose ()
	{
		delete GET;
		GET = NULL;
	}
	
	CSRAW ~ProfilerFrameDataIterator () { Dispose (); }
	
	CUSTOM bool Next (bool enterChildren)
	{
		return GET->GetNext(enterChildren);
	}
	
	CUSTOM int GetThreadCount (int frame)
	{
		return GET->GetThreadCount (frame);
	}
	CUSTOM double GetFrameStartS (int frame)
	{
		return GET->GetFrameStartS (frame);
	}
	
	CUSTOM string GetThreadName ()
	{
		const std::string* name = GET->GetThreadName();
		return scripting_string_new(name ? *name : "<unknown thread>");
	}
	
	CUSTOM void SetRoot (int frame, int threadIdx)
	{
		GET->SetRoot (frame, threadIdx);
	}	

	CUSTOM_PROP int group
	{
		return GET->GetGroup();
	}
	
	CUSTOM_PROP int depth
	{
		return GET->GetDepth();
	}

	CUSTOM_PROP string path
	{
		return scripting_string_new(GET->GetFunctionPath());
	}
	CUSTOM_PROP string name
	{
		return scripting_string_new(GET->GetFunctionName());
	}

	CUSTOM_PROP int id
	{
		return GET->GetID();
	}

	CUSTOM_PROP float frameTimeMS
	{
		return GET->GetFrameTimeMS();
	}
	
	CUSTOM_PROP float startTimeMS
	{
		return GET->GetStartTimeMS();
	}
	CUSTOM_PROP float durationMS
	{
		return GET->GetDurationMS();
	}
	
	C++RAW #undef GET

END

CSRAW }
