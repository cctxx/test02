#include "UnityPrefix.h"

// NOTE: much of this file is automatically generated by Tools/GenerateAutoDocs.cmd|command
// Hand-editing the values inside InitializeAutoDocumentation is pointless;
// edit them in C++ header files of the corresponding classes (they use Doxygen syntax)

#include "AutoDocumentation.h"
#include "Runtime/BaseClasses/BaseObject.h"
#include "Runtime/Input/InputManager.h"

using namespace std;
struct ClassData
{
	map<string, string> nameToDocumentation;
	map<string, map<string, int> > nameToValues;
	map<string, pair<float, float> > nameToRange;
	map<string, string > nameToDisplayName;
};
typedef map<string, ClassData> ClassDataMap;
ClassDataMap* gVariable = NULL;

static ClassDataMap& GetVariable()
{
	return *gVariable;
}

void CleanupAutoDocumentation()
{
	UNITY_DELETE(gVariable, kMemEditorUtility);
}

pair<float, float> GetRangeFromDocumentation (const std::string& className, const std::string& variableName)
{
	if (GetVariable().find (className) == GetVariable().end ())
		return make_pair (-numeric_limits<float>::infinity (), numeric_limits<float>::infinity ());
	if (GetVariable()[className].nameToRange.find (variableName) == GetVariable()[className].nameToRange.end ())
		return make_pair (-numeric_limits<float>::infinity (), numeric_limits<float>::infinity ());
	return GetVariable()[className].nameToRange[variableName];
}

std::string GetVariableDocumentation (const std::string& className, const std::string& variableName)
{
	if (GetVariable().find (className) == GetVariable().end ())
		return string ();
	if (GetVariable()[className].nameToDocumentation.find (variableName) == GetVariable()[className].nameToDocumentation.end ())
		return string ();
	return GetVariable()[className].nameToDocumentation[variableName];
}

const std::map<std::string, int>* GetVariableParameter (const std::string& className, const std::string& variableName)
{
	if (GetVariable().find (className) == GetVariable().end ())
		return NULL;
	if (GetVariable()[className].nameToValues.find (variableName) == GetVariable()[className].nameToValues.end ())
		return NULL;
	return &GetVariable()[className].nameToValues[variableName];
}

const char* GetVariableDisplayName (const std::string& className, const std::string& variableName)
{
	if (GetVariable().find (className) == GetVariable().end ())
		return NULL;
	if (GetVariable()[className].nameToDisplayName.find (variableName) == GetVariable()[className].nameToDisplayName.end ())
		return NULL;
	return GetVariable()[className].nameToDisplayName[variableName].c_str();
}

static void AddDocumentation (const char* className, const char* variable, const char* docs)
{
	GetVariable()[className].nameToDocumentation[variable]= docs;

	// If we are dealing with an object derived class also add properties to all derived classes.
	int classID = Object::StringToClassID (className);
	if (classID != -1)
	{
		vector<SInt32> derived;
		Object::FindAllDerivedClasses (classID, &derived);
		for (int i=0;i<derived.size ();i++)
			GetVariable()[Object::ClassIDToString (derived[i])].nameToDocumentation[variable]= docs;
	}
}

static void AddRangedValue (const char* className, const char* variable, pair<float, float> range)
{
	GetVariable()[className].nameToRange[variable] = range;
	
	// If we are dealing with an object derived class also add properties to all derived classes.
	int classID = Object::StringToClassID (className);
	if (classID != -1)
	{
		vector<SInt32> derived;
		Object::FindAllDerivedClasses (classID, &derived);
		for (int i=0;i<derived.size ();i++)
			GetVariable()[Object::ClassIDToString (derived[i])].nameToRange[variable] = range;
	}
}

static void AddEnum (const char* className, const char* variable, int value, const char* name)
{
	GetVariable()[className].nameToValues[variable][name]= value;
	
	// If we are dealing with an object derived class also add properties to all derived classes.
	int classID = Object::StringToClassID (className);
	if (classID != -1)
	{
		vector<SInt32> derived;
		Object::FindAllDerivedClasses (classID, &derived);
		for (int i=0;i<derived.size ();i++)
			GetVariable()[Object::ClassIDToString (derived[i])].nameToValues[variable][name]= value;
	}
}

static void AddDisplayName (const char* className, const char* variable, const char* displayName)
{
	GetVariable()[className].nameToDisplayName[variable]= displayName;
	
	// If we are dealing with an object derived class also add properties to all derived classes.
	int classID = Object::StringToClassID (className);
	if (classID != -1)
	{
		vector<SInt32> derived;
		Object::FindAllDerivedClasses (classID, &derived);
		for (int i=0;i<derived.size ();i++)
			GetVariable()[Object::ClassIDToString (derived[i])].nameToDisplayName[variable]= displayName;
	}
}


void InitializeAutoDocumentation ()
{
	Assert(gVariable == NULL);
	gVariable = UNITY_NEW(ClassDataMap, kMemEditorUtility);

	// ---- Generated Code Begin Marker
	/* Class: Animation */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("Animation", "m_WrapMode", "");
	AddEnum ("Animation", "m_WrapMode", 0, "Default");
	AddEnum ("Animation", "m_WrapMode", 1, "Once");
	AddEnum ("Animation", "m_WrapMode", 2, "Loop");
	AddEnum ("Animation", "m_WrapMode", 4, "PingPong");
	AddEnum ("Animation", "m_WrapMode", 8, "ClampForever");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("Animation", "m_CachedAffectedSendToRootTransform", "When we are animating transforms we cache the affect root transforms (The top most transform that covers all SendTransformChanged messages that need to sent).");
	AddDocumentation ("Animation", "m_CullingType", "");
	AddEnum ("Animation", "m_CullingType", 0, "Always Animate");
	AddEnum ("Animation", "m_CullingType", 1, "Based On Renderers");

	// Note: all this is auto-generated, see at top of file

	/* Class: AnimationClip */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("AnimationClip", "m_WrapMode", "");
	AddEnum ("AnimationClip", "m_WrapMode", 0, "Default");
	AddEnum ("AnimationClip", "m_WrapMode", 1, "Once");
	AddEnum ("AnimationClip", "m_WrapMode", 2, "Loop");
	AddEnum ("AnimationClip", "m_WrapMode", 4, "PingPong");
	AddEnum ("AnimationClip", "m_WrapMode", 8, "ClampForever");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("AnimationClip", "m_CachedRange", "TODO: Serialiaze and do not compute it at all on startup.");

	/* Class: AnimationState */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("AnimationState", "m_WrapMode", "");
	AddEnum ("AnimationState", "m_WrapMode", 0, "Default");
	AddEnum ("AnimationState", "m_WrapMode", 1, "Once");
	AddEnum ("AnimationState", "m_WrapMode", 2, "Loop");
	AddEnum ("AnimationState", "m_WrapMode", 4, "PingPong");
	AddEnum ("AnimationState", "m_WrapMode", 8, "ClampForever");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("AnimationState", "m_UnstoppedLastWrappedTime", ": FIXME HACKED Time stopping");
	AddDocumentation ("AnimationState", "m_BlendMode", "");
	AddEnum ("AnimationState", "m_BlendMode", 0, "Blend");
	AddEnum ("AnimationState", "m_BlendMode", 1, "Additive");

	// Note: all this is auto-generated, see at top of file

	/* Class: Animator */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("Animator", "m_CullingMode", "");
	AddEnum ("Animator", "m_CullingMode", 0, "Always Animate");
	AddEnum ("Animator", "m_CullingMode", 1, "Based On Renderers");

	// Note: all this is auto-generated, see at top of file

	/* Class: AssetBundle */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("AssetBundle", "m_PreloadTable", "Table of objects that need to be pulled from the bundle by the preload manager when a specific asset is loaded from the bundle.");
	AddDocumentation ("AssetBundle", "m_Container", "Map of named assets contained in the bundle.");
	AddDocumentation ("AssetBundle", "m_MainAsset", "AssetInfo for the main asset. Has no associated name.");

	/* Class: AssetBundleBuilder */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("AssetBundleBuilder", "m_IncludedObjects", "Set of objects to persist in the bundle.");
	AddDocumentation ("AssetBundleBuilder", "m_IncludedObjectIDs", "Same as m_IncludedObjects but restricted to just instance IDs.");
	AddDocumentation ("AssetBundleBuilder", "m_IncludedAssets", "GUIDs of all assets included in the bundle.");
	AddDocumentation ("AssetBundleBuilder", "m_BuildAssets", "Records for all the objects that we are writing to the final bundle.");

	/* Class: AudioClip */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("AudioClip", "m_UseHardware", "IPhone only (for now).");

	/* Class: AudioManager */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("AudioManager", "Default Speaker Mode", "");
	AddEnum ("AudioManager", "Default Speaker Mode", 0, "Raw");
	AddEnum ("AudioManager", "Default Speaker Mode", 1, "Mono");
	AddEnum ("AudioManager", "Default Speaker Mode", 2, "Stereo");
	AddEnum ("AudioManager", "Default Speaker Mode", 3, "Quad");
	AddEnum ("AudioManager", "Default Speaker Mode", 4, "Surround");
	AddEnum ("AudioManager", "Default Speaker Mode", 5, "Surround 5.1");
	AddEnum ("AudioManager", "Default Speaker Mode", 6, "Surround 7.1");
	AddEnum ("AudioManager", "Default Speaker Mode", 7, "Prologic DTS");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("AudioManager", "m_DSPBufferSize", "");
	AddEnum ("AudioManager", "m_DSPBufferSize", 0, "Default");
	AddEnum ("AudioManager", "m_DSPBufferSize", 256, "Best latency");
	AddEnum ("AudioManager", "m_DSPBufferSize", 512, "Good latency");
	AddEnum ("AudioManager", "m_DSPBufferSize", 1024, "Best performance");

	// Note: all this is auto-generated, see at top of file

	/* Class: AudioReverbFilter */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("AudioReverbFilter", "m_ReverbPreset", "");
	AddEnum ("AudioReverbFilter", "m_ReverbPreset", 0, "Off");
	AddEnum ("AudioReverbFilter", "m_ReverbPreset", 1, "Generic");
	AddEnum ("AudioReverbFilter", "m_ReverbPreset", 2, "PaddedCell");
	AddEnum ("AudioReverbFilter", "m_ReverbPreset", 3, "Room");
	AddEnum ("AudioReverbFilter", "m_ReverbPreset", 4, "Bathroom");
	AddEnum ("AudioReverbFilter", "m_ReverbPreset", 5, "Livingroom");
	AddEnum ("AudioReverbFilter", "m_ReverbPreset", 6, "Stoneroom");
	AddEnum ("AudioReverbFilter", "m_ReverbPreset", 7, "Auditorium");
	AddEnum ("AudioReverbFilter", "m_ReverbPreset", 8, "Concerthall");
	AddEnum ("AudioReverbFilter", "m_ReverbPreset", 9, "Cave");
	AddEnum ("AudioReverbFilter", "m_ReverbPreset", 10, "Arena");
	AddEnum ("AudioReverbFilter", "m_ReverbPreset", 11, "Hangar");
	AddEnum ("AudioReverbFilter", "m_ReverbPreset", 12, "CarpettedHallway");
	AddEnum ("AudioReverbFilter", "m_ReverbPreset", 13, "Hallway");
	AddEnum ("AudioReverbFilter", "m_ReverbPreset", 14, "StoneCorridor");
	AddEnum ("AudioReverbFilter", "m_ReverbPreset", 15, "Alley");
	AddEnum ("AudioReverbFilter", "m_ReverbPreset", 16, "Forest");
	AddEnum ("AudioReverbFilter", "m_ReverbPreset", 17, "City");
	AddEnum ("AudioReverbFilter", "m_ReverbPreset", 18, "Mountains");
	AddEnum ("AudioReverbFilter", "m_ReverbPreset", 19, "Quarry");
	AddEnum ("AudioReverbFilter", "m_ReverbPreset", 20, "Plain");
	AddEnum ("AudioReverbFilter", "m_ReverbPreset", 21, "Parkinglot");
	AddEnum ("AudioReverbFilter", "m_ReverbPreset", 22, "Sewerpipe");
	AddEnum ("AudioReverbFilter", "m_ReverbPreset", 23, "Underwater");
	AddEnum ("AudioReverbFilter", "m_ReverbPreset", 24, "Drugged");
	AddEnum ("AudioReverbFilter", "m_ReverbPreset", 25, "Dizzy");
	AddEnum ("AudioReverbFilter", "m_ReverbPreset", 26, "Psychotic");
	AddEnum ("AudioReverbFilter", "m_ReverbPreset", 27, "User");

	// Note: all this is auto-generated, see at top of file

	/* Class: AudioReverbZone */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("AudioReverbZone", "m_ReverbPreset", "");
	AddEnum ("AudioReverbZone", "m_ReverbPreset", 0, "Off");
	AddEnum ("AudioReverbZone", "m_ReverbPreset", 1, "Generic");
	AddEnum ("AudioReverbZone", "m_ReverbPreset", 2, "PaddedCell");
	AddEnum ("AudioReverbZone", "m_ReverbPreset", 3, "Room");
	AddEnum ("AudioReverbZone", "m_ReverbPreset", 4, "Bathroom");
	AddEnum ("AudioReverbZone", "m_ReverbPreset", 5, "Livingroom");
	AddEnum ("AudioReverbZone", "m_ReverbPreset", 6, "Stoneroom");
	AddEnum ("AudioReverbZone", "m_ReverbPreset", 7, "Auditorium");
	AddEnum ("AudioReverbZone", "m_ReverbPreset", 8, "Concerthall");
	AddEnum ("AudioReverbZone", "m_ReverbPreset", 9, "Cave");
	AddEnum ("AudioReverbZone", "m_ReverbPreset", 10, "Arena");
	AddEnum ("AudioReverbZone", "m_ReverbPreset", 11, "Hangar");
	AddEnum ("AudioReverbZone", "m_ReverbPreset", 12, "CarpettedHallway");
	AddEnum ("AudioReverbZone", "m_ReverbPreset", 13, "Hallway");
	AddEnum ("AudioReverbZone", "m_ReverbPreset", 14, "StoneCorridor");
	AddEnum ("AudioReverbZone", "m_ReverbPreset", 15, "Alley");
	AddEnum ("AudioReverbZone", "m_ReverbPreset", 16, "Forest");
	AddEnum ("AudioReverbZone", "m_ReverbPreset", 17, "City");
	AddEnum ("AudioReverbZone", "m_ReverbPreset", 18, "Mountains");
	AddEnum ("AudioReverbZone", "m_ReverbPreset", 19, "Quarry");
	AddEnum ("AudioReverbZone", "m_ReverbPreset", 20, "Plain");
	AddEnum ("AudioReverbZone", "m_ReverbPreset", 21, "Parkinglot");
	AddEnum ("AudioReverbZone", "m_ReverbPreset", 22, "Sewerpipe");
	AddEnum ("AudioReverbZone", "m_ReverbPreset", 23, "Underwater");
	AddEnum ("AudioReverbZone", "m_ReverbPreset", 24, "Drugged");
	AddEnum ("AudioReverbZone", "m_ReverbPreset", 25, "Dizzy");
	AddEnum ("AudioReverbZone", "m_ReverbPreset", 26, "Psychotic");
	AddEnum ("AudioReverbZone", "m_ReverbPreset", 27, "User");

	// Note: all this is auto-generated, see at top of file

	/* Class: AudioSource */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("AudioSource", "MinDistance", "Within the minDistance, the volume will stay at the loudest possible. Outside of this mindistance it begins to attenuate.");
	AddDocumentation ("AudioSource", "BypassEffects", "Bypass/ignore any applied effects on AudioSource.");
	AddDocumentation ("AudioSource", "Loop", "Set the source to loop. If loop points are defined in the clip, these will be respected.");
	AddDocumentation ("AudioSource", "m_IgnoreListenerVolume", "backward compatibility props");
	AddDocumentation ("AudioSource", "BypassListenerEffects", "Bypass/ignore any applied effects from listener.");
	AddDocumentation ("AudioSource", "m_Pitch", "Sets the frequency of the sound. Use this to slow down or speed up the sound.");
	AddDocumentation ("AudioSource", "DopplerLevel", "Sets the specific doppler scale for the source.");
	AddDocumentation ("AudioSource", "MaxDistance", "MaxDistance is the distance a sound stops attenuating at.");
	AddDocumentation ("AudioSource", "Pan2D", "Sets a source's pan position linearly. Only applicable on 2D sounds.");
	AddDocumentation ("AudioSource", "rolloffMode", "");
	AddEnum ("AudioSource", "rolloffMode", 0, "Logarithmic Rolloff");
	AddEnum ("AudioSource", "rolloffMode", 1, "Linear Rolloff");
	AddEnum ("AudioSource", "rolloffMode", 2, "Custom Rolloff");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("AudioSource", "IgnoreListenerPause", "Allow source to play even though AudioListener is paused (for GUI sounds).");
	AddDocumentation ("AudioSource", "m_Volume", "Sets the volume of the sound.");
	AddDocumentation ("AudioSource", "BypassReverbZones", "Bypass/ignore any reverb zones.");
	AddDocumentation ("AudioSource", "m_PlayOnAwake", "Play the sound when the scene loads.");
	AddDocumentation ("AudioSource", "Mute", "Mutes the sound.");
	AddDocumentation ("AudioSource", "Priority", "Sets the priority of the source. A sound with a lower priority will more likely be stolen by high priorities sounds.");

	/* Class: BaseRenderer */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("BaseRenderer", "m_LightmapST", "Lightmap tiling and offset.");

	/* Class: BlendTree */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("BlendTree", "m_BlendType", "Blend Node type.");
	AddEnum ("BlendTree", "m_BlendType", 0, "1D");
	AddEnum ("BlendTree", "m_BlendType", 1, "2D Simple Directional");
	AddEnum ("BlendTree", "m_BlendType", 2, "2D Freeform Directional");
	AddEnum ("BlendTree", "m_BlendType", 3, "2D Freeform Cartesian");

	// Note: all this is auto-generated, see at top of file

	/* Class: BoxCollider2D */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("BoxCollider2D", "m_Size", "The size of the box.");
	AddDocumentation ("BoxCollider2D", "m_Center", "The offset of the box.");

	/* Class: Camera */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("Camera", "m_NearClip", "Near clipping plane.");
	AddDocumentation ("Camera", "m_FarClip", "Far clipping plane.");
	AddDocumentation ("Camera", "m_ClearFlags", "");
	AddEnum ("Camera", "m_ClearFlags", 1, "Skybox");
	AddEnum ("Camera", "m_ClearFlags", 2, "Solid Color");
	AddEnum ("Camera", "m_ClearFlags", 3, "Depth only");
	AddEnum ("Camera", "m_ClearFlags", 4, "Don't Clear");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("Camera", "m_BackGroundColor", "The color to which camera clears the screen.");
	AddDocumentation ("Camera", "m_CullingMask", "Which layers the camera does render.");
	AddDocumentation ("Camera", "m_Orthographic", "Is camera orthographic?");
	AddDocumentation ("Camera", "m_EventMask", "Which layers receive events.");
	AddDocumentation ("Camera", "m_TargetTexture", "The texture to render this camera into.");
	AddDocumentation ("Camera", "m_FieldOfView", "Field of view of the camera [ 0.00001, 179  ].");
	AddRangedValue ("Camera", "m_FieldOfView", make_pair<float, float>(0.00001f, 179.0f));
	AddDocumentation ("Camera", "m_Depth", "A camera with a larger depth is drawn on top of a camera with a smaller depth [ -100, 100 ].");
	AddRangedValue ("Camera", "m_Depth", make_pair<float, float>(-100, 100.0f));
	AddDocumentation ("Camera", "m_RenderingPath", "Rendering path to use.");
	AddEnum ("Camera", "m_RenderingPath", -1, "Use Player Settings");
	AddEnum ("Camera", "m_RenderingPath", 0, "Vertex Lit");
	AddEnum ("Camera", "m_RenderingPath", 1, "Forward");
	AddEnum ("Camera", "m_RenderingPath", 2, "Deferred Lighting");

	// Note: all this is auto-generated, see at top of file

	/* Class: CapsuleCollider */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("CapsuleCollider", "m_Height", "[ 0, infinity  ]");
	AddRangedValue ("CapsuleCollider", "m_Height", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("CapsuleCollider", "m_Radius", "[ 0, infinity  ]");
	AddRangedValue ("CapsuleCollider", "m_Radius", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("CapsuleCollider", "m_Direction", "");
	AddEnum ("CapsuleCollider", "m_Direction", 0, "X-Axis");
	AddEnum ("CapsuleCollider", "m_Direction", 1, "Y-Axis");
	AddEnum ("CapsuleCollider", "m_Direction", 2, "Z-Axis");

	// Note: all this is auto-generated, see at top of file

	/* Class: CharacterController */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("CharacterController", "m_Height", "[ 0, infinity  ]");
	AddRangedValue ("CharacterController", "m_Height", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("CharacterController", "m_SkinWidth", "[ 0.0001, infinity  ]");
	AddRangedValue ("CharacterController", "m_SkinWidth", make_pair<float, float>(0.0001f, numeric_limits<float>::infinity ()));
	AddDocumentation ("CharacterController", "m_StepOffset", "[ 0, infinity  ]");
	AddRangedValue ("CharacterController", "m_StepOffset", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("CharacterController", "m_SlopeLimit", "[ 0, 180  ]");
	AddRangedValue ("CharacterController", "m_SlopeLimit", make_pair<float, float>(0.0f, 180.0f));
	AddDocumentation ("CharacterController", "m_Radius", "[ 0, infinity  ]");
	AddRangedValue ("CharacterController", "m_Radius", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("CharacterController", "m_MinMoveDistance", "[ 0, infinity  ]");
	AddRangedValue ("CharacterController", "m_MinMoveDistance", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));

	/* Class: CircleCollider2D */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("CircleCollider2D", "m_Radius", "The radius of the circle. [ 0.0001, 1000000  ].");
	AddRangedValue ("CircleCollider2D", "m_Radius", make_pair<float, float>(0.0001f, 1000000.0f));
	AddDocumentation ("CircleCollider2D", "m_Center", "The offset of the circle.");

	/* Class: CollisionModule */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("CollisionModule", "m_Quality", "Perform approximate world particle collisions.");
	AddDocumentation ("CollisionModule", "m_CollidesWith", "Collides the particles with every collider whose layerMask & m_CollidesWith != 0.");

	/* Class: ConstantForce */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("ConstantForce", "m_Force", "Force applied globally.");
	AddDocumentation ("ConstantForce", "m_Torque", "Torque applied globally.");
	AddDocumentation ("ConstantForce", "m_RelativeTorque", "Torque applied locally.");
	AddDocumentation ("ConstantForce", "m_RelativeForce", "Force applied locally.");

	/* Class: DistanceJoint2D */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("DistanceJoint2D", "m_Anchor", "The local-space anchor from the base rigid-body.");
	AddDocumentation ("DistanceJoint2D", "m_Distance", "The maximum distance which the joint should attempt to maintain between attached bodies. [ 0.005, 1000000  ].");
	AddRangedValue ("DistanceJoint2D", "m_Distance", make_pair<float, float>(0.005f, 1000000.0f));
	AddDocumentation ("DistanceJoint2D", "m_ConnectedAnchor", "The local-space anchor from the connected rigid-body.");

	/* Class: DynamicGLES3VBO */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("DynamicGLES3VBO", "m_QuadArrayIndexBuffer", "Used for kDrawQuads mode.");

	/* Class: EllipsoidParticleEmitter */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("EllipsoidParticleEmitter", "m_MinEmitterRange", "[0...1] relative range to maxEmitterSize where particles will not be spawned");
	AddDocumentation ("EllipsoidParticleEmitter", "m_Ellipsoid", "Size of emission area.");

	/* Class: Flare */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("Flare", "m_FlareTexture", "The texture used for the flare elements.");
	AddDocumentation ("Flare", "m_Elements", "The individual flare elements.");
	AddDocumentation ("Flare", "m_TextureLayout", "Flare element layout in the texture.");
	AddEnum ("Flare", "m_TextureLayout", 0, "1 Large 4 Small");
	AddEnum ("Flare", "m_TextureLayout", 1, "1 Large 2 Medium 8 Small");
	AddEnum ("Flare", "m_TextureLayout", 2, "1 Texture");
	AddEnum ("Flare", "m_TextureLayout", 3, "2x2 Grid");
	AddEnum ("Flare", "m_TextureLayout", 4, "3x3 Grid");
	AddEnum ("Flare", "m_TextureLayout", 5, "4x4 Grid");

	// Note: all this is auto-generated, see at top of file

	/* Class: Font */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("Font", "m_ConvertCase", "");
	AddEnum ("Font", "m_ConvertCase", 0, "Don't change case");
	AddEnum ("Font", "m_ConvertCase", 1, "Convert to upper case characters");
	AddEnum ("Font", "m_ConvertCase", 2, "Convert to lower case characters");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("Font", "m_LineSpacing", "Spacing between lines as multiplum of height of a character.");
	AddDocumentation ("Font", "m_Kerning", "Kerning of space between characters (Smaller than 1.0 pulls them together, Larger pushes them out).");
	AddDocumentation ("Font", "m_AsciiStartOffset", "What is the first ascii character in the texture.");

	/* Class: GLES3VBO */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("GLES3VBO", "m_Indices", "Index data. Copy is kept for emulating quad primitive type.");

	/* Class: GPUSkinningInfo */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("GPUSkinningInfo", "m_BonesPerVertex", "Bones per vertex, must be 1, 2 or 4.");
	AddDocumentation ("GPUSkinningInfo", "m_Stride", "Destination VBO stride.");
	AddDocumentation ("GPUSkinningInfo", "m_DestVBO", "Destination VBO.");
	AddDocumentation ("GPUSkinningInfo", "m_ChannelMap", "Channel map for the VBO.");
	AddDocumentation ("GPUSkinningInfo", "m_VertexCount", "Number of vertices in the skin.");

	/* Class: GUIClip */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("GUIClip", "globalScrollOffset", "This is absolute.");
	AddDocumentation ("GUIClip", "scrollOffset", "physical scrolling offset for coordinates - this is relative to parent.");
	AddDocumentation ("GUIClip", "physicalRect", "The rectangle of this clipping rect.");
	AddDocumentation ("GUIClip", "renderOffset", "rendering offset. This is the global GUIClip->buffer coordinates");

	/* Class: GUIStyle */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("GUIStyle", "m_ImagePosition", "How image and text is combined.");
	AddEnum ("GUIStyle", "m_ImagePosition", 0, "Image Left");
	AddEnum ("GUIStyle", "m_ImagePosition", 1, "Image Above");
	AddEnum ("GUIStyle", "m_ImagePosition", 2, "Image Only");
	AddEnum ("GUIStyle", "m_ImagePosition", 3, "Text Only");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("GUIStyle", "m_Border", "Border of the background images.");
	AddDocumentation ("GUIStyle", "m_Alignment", "Text alignment.");
	AddEnum ("GUIStyle", "m_Alignment", 0, "Upper Left");
	AddEnum ("GUIStyle", "m_Alignment", 1, "Upper Center");
	AddEnum ("GUIStyle", "m_Alignment", 2, "Upper Right");
	AddEnum ("GUIStyle", "m_Alignment", 3, "Middle Left");
	AddEnum ("GUIStyle", "m_Alignment", 4, "Middle Center");
	AddEnum ("GUIStyle", "m_Alignment", 5, "Middle Right");
	AddEnum ("GUIStyle", "m_Alignment", 6, "Lower Left");
	AddEnum ("GUIStyle", "m_Alignment", 7, "Lower Center");
	AddEnum ("GUIStyle", "m_Alignment", 8, "Lower Right");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("GUIStyle", "m_Padding", "Distance from outer edge to contents.");
	AddDocumentation ("GUIStyle", "m_Font", "The font to use. If not set, the font is read from the main GUISkin.");
	AddDocumentation ("GUIStyle", "m_FixedWidth", "If non-0, that axis is always draw at the specified size.");
	AddDocumentation ("GUIStyle", "m_Overflow", "Extra size to use for the background images.");
	AddDocumentation ("GUIStyle", "m_FixedHeight", "If non-0, that axis is always draw at the specified size.");
	AddDocumentation ("GUIStyle", "m_ContentOffset", "Pixel offset to apply to the content of this GUIstyle.");
	AddDocumentation ("GUIStyle", "m_Clipping", "Clipping mode to use.");
	AddEnum ("GUIStyle", "m_Clipping", 0, "Overflow");
	AddEnum ("GUIStyle", "m_Clipping", 1, "Clip");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("GUIStyle", "m_WordWrap", "Word wrap the text?");
	AddDocumentation ("GUIStyle", "m_FontStyle", "The font style to use. Only applicable for dynamic fonts.");
	AddEnum ("GUIStyle", "m_FontStyle", 0, "Normal");
	AddEnum ("GUIStyle", "m_FontStyle", 1, "Bold");
	AddEnum ("GUIStyle", "m_FontStyle", 2, "Italic");
	AddEnum ("GUIStyle", "m_FontStyle", 3, "Bold and Italic");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("GUIStyle", "m_FontSize", "The font size to use. Set to 0 to use default font size. Only applicable for dynamic fonts.");
	AddDocumentation ("GUIStyle", "m_ClipOffset", "Clip offset.");
	AddDocumentation ("GUIStyle", "m_RichText", "Use HTML-style markup.");
	AddDocumentation ("GUIStyle", "m_Margin", "Spacing between this element and ones next to it.");

	/* Class: GUIText */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("GUIText", "m_Anchor", "Where the text-mesh is anchored related to local origo..");
	AddEnum ("GUIText", "m_Anchor", 0, "upper left");
	AddEnum ("GUIText", "m_Anchor", 1, "upper center");
	AddEnum ("GUIText", "m_Anchor", 2, "upper right");
	AddEnum ("GUIText", "m_Anchor", 3, "middle left");
	AddEnum ("GUIText", "m_Anchor", 4, "middle center");
	AddEnum ("GUIText", "m_Anchor", 5, "middle right");
	AddEnum ("GUIText", "m_Anchor", 6, "lower left");
	AddEnum ("GUIText", "m_Anchor", 7, "lower center");
	AddEnum ("GUIText", "m_Anchor", 8, "lower right");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("GUIText", "m_Alignment", "");
	AddEnum ("GUIText", "m_Alignment", 0, "left");
	AddEnum ("GUIText", "m_Alignment", 1, "center");
	AddEnum ("GUIText", "m_Alignment", 2, "right");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("GUIText", "m_LineSpacing", "Spacing between lines as multiplum of height of a character.");
	AddDocumentation ("GUIText", "m_PixelCorrect", "Place & scale the text to a pixel-correct position.");
	AddDocumentation ("GUIText", "m_FontStyle", "The font style to use. Only applicable for dynamic fonts..");
	AddEnum ("GUIText", "m_FontStyle", 0, "Normal");
	AddEnum ("GUIText", "m_FontStyle", 1, "Bold");
	AddEnum ("GUIText", "m_FontStyle", 2, "Italic");
	AddEnum ("GUIText", "m_FontStyle", 3, "Bold and Italic");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("GUIText", "m_FontSize", "The font size to use. Set to 0 to use default font size. Only applicable for dynamic fonts.");
	AddDocumentation ("GUIText", "m_TabSize", "Length of one tab.");
	AddDocumentation ("GUIText", "m_RichText", "Enable HTML-style tags for text formatting.");

	/* Class: GUITexture */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("GUITexture", "m_Color", "Tint color.");
	AddDocumentation ("GUITexture", "m_Texture", "The texture to use.");
	AddDocumentation ("GUITexture", "m_LeftBorder", "The border pixels - this part of texture is never scaled.");
	AddDocumentation ("GUITexture", "m_BottomBorder", "The border pixels - this part of texture is never scaled.");
	AddDocumentation ("GUITexture", "m_TopBorder", "The border pixels - this part of texture is never scaled.");
	AddDocumentation ("GUITexture", "m_RightBorder", "The border pixels - this part of texture is never scaled.");

	/* Class: GradientDeprecated */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("GradientDeprecated", "m_Colors", "The array of colors this interpolator works through.");

	/* Class: HingeJoint2D */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("HingeJoint2D", "m_Anchor", "The local-space anchor from the base rigid-body.");
	AddDocumentation ("HingeJoint2D", "m_Motor", "The joint motor.");
	AddDocumentation ("HingeJoint2D", "m_AngleLimits", "The joint angle limits.");
	AddDocumentation ("HingeJoint2D", "m_UseMotor", "Whether to use the joint motor or not.");
	AddDocumentation ("HingeJoint2D", "m_UseLimits", "Whether to use the angle limits or not.");
	AddDocumentation ("HingeJoint2D", "m_ConnectedAnchor", "The local-space anchor from the connected rigid-body.");

	/* Class: InputAxis */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("InputAxis", "axis", "Axis to use.");
	AddEnum ("InputAxis", "axis", 0, "X axis");
	AddEnum ("InputAxis", "axis", 1, "Y axis");
	AddEnum ("InputAxis", "axis", 2, "3rd axis (Joysticks and Scrollwheel)");
	AddEnum ("InputAxis", "axis", 3, "4th axis (Joysticks)");
	AddEnum ("InputAxis", "axis", 4, "5th axis (Joysticks)");
	AddEnum ("InputAxis", "axis", 5, "6th axis (Joysticks)");
	AddEnum ("InputAxis", "axis", 6, "7th axis (Joysticks)");
	AddEnum ("InputAxis", "axis", 7, "8th axis (Joysticks)");
	AddEnum ("InputAxis", "axis", 8, "9th axis (Joysticks)");
	AddEnum ("InputAxis", "axis", 9, "10th axis (Joysticks)");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("InputAxis", "dead", "Size of the analog dead zone. All analog device values within this range map to neutral.");
	AddDocumentation ("InputAxis", "altPositiveButton", "alternative Button to be pressed for movement in negative direction");
	AddDocumentation ("InputAxis", "invert", "flip positive and negative?");
	AddDocumentation ("InputAxis", "joyNum", "Joystick identifier index.");
	AddEnum ("InputAxis", "joyNum", 0, "Get Motion from all Joysticks");
	AddEnum ("InputAxis", "joyNum", 1, "Joystick 1");
	AddEnum ("InputAxis", "joyNum", 2, "Joystick 2");
	AddEnum ("InputAxis", "joyNum", 3, "Joystick 3");
	AddEnum ("InputAxis", "joyNum", 4, "Joystick 4");
	AddEnum ("InputAxis", "joyNum", 5, "Joystick 5");
	AddEnum ("InputAxis", "joyNum", 6, "Joystick 6");
	AddEnum ("InputAxis", "joyNum", 7, "Joystick 7");
	AddEnum ("InputAxis", "joyNum", 8, "Joystick 8");
	AddEnum ("InputAxis", "joyNum", 9, "Joystick 9");
	AddEnum ("InputAxis", "joyNum", 10, "Joystick 10");
	AddEnum ("InputAxis", "joyNum", 11, "Joystick 11");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("InputAxis", "altNegativeButton", "alternative Button to be pressed for movement in positive direction");
	AddDocumentation ("InputAxis", "descriptiveName", "Name presented to the user for setup if present.");
	AddDocumentation ("InputAxis", "sensitivity", "Speed to move towards target value for digital devices (in units per sec).");
	AddDocumentation ("InputAxis", "positiveButton", "Button to be pressed for movement in negative direction.");
	AddDocumentation ("InputAxis", "type", "");
	AddEnum ("InputAxis", "type", 0, "Key or Mouse Button");
	AddEnum ("InputAxis", "type", 1, "Mouse Movement");
	AddEnum ("InputAxis", "type", 2, "Joystick Axis");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("InputAxis", "snap", "If we have input in opposite direction of current, do we jump to neutral and continue from there?");
	AddDocumentation ("InputAxis", "negativeButton", "Button to be pressed for movement in positive direction.");
	AddDocumentation ("InputAxis", "gravity", "Speed (in units/sec) that the output value falls towards neutral when device at rest.");
	AddDocumentation ("InputAxis", "descriptiveNegativeName", "Name for negative Button presented to the user for setup if present.");

	/* Class: Joint2D */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("Joint2D", "m_CollideConnected", "Whether rigid bodies connected with this joint can collide or not.");
	AddDocumentation ("Joint2D", "m_ConnectedRigidBody", "The rigid body to connect to. No rigid body connects to the scene.");

	/* Class: LensFlare */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("LensFlare", "m_Color", "Color of the flare.");
	AddDocumentation ("LensFlare", "m_Directional", "Is this lensflare directional (true) or positional (false).");
	AddDocumentation ("LensFlare", "m_FadeSpeed", "Fade speed of the flare.");
	AddDocumentation ("LensFlare", "m_IgnoreLayers", "mask for layers that cannot hide flare");
	AddDocumentation ("LensFlare", "m_Flare", "Source flare asset to render.");
	AddDocumentation ("LensFlare", "m_Brightness", "Brightness scale of the flare.");

	/* Class: Light */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("Light", "m_Type", "Light type");
	AddEnum ("Light", "m_Type", 0, "Spot");
	AddEnum ("Light", "m_Type", 1, "Directional");
	AddEnum ("Light", "m_Type", 2, "Point");
	AddEnum ("Light", "m_Type", 3, "Area (baked only)");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("Light", "m_Range", "Light range.");
	AddDocumentation ("Light", "m_Cookie", "Custom cookie (optional).");
	AddDocumentation ("Light", "m_Intensity", "Light intensity [ 0.0, 8.0 ].");
	AddRangedValue ("Light", "m_Intensity", make_pair<float, float>(0.0f, 8.0f));
	AddDocumentation ("Light", "m_SpotAngle", "Angle of the spotlight cone.");
	AddDocumentation ("Light", "m_DrawHalo", "Does the light have a halo?");
	AddDocumentation ("Light", "m_Lightmapping", "Is light baked into lightmaps?");
	AddEnum ("Light", "m_Lightmapping", 0, "RealtimeOnly");
	AddEnum ("Light", "m_Lightmapping", 1, "Auto");
	AddEnum ("Light", "m_Lightmapping", 2, "BakedOnly");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("Light", "m_CullingMask", "The mask used for selectively lighting objects in the scene.");
	AddDocumentation ("Light", "m_RenderMode", "Rendering mode for the light.");
	AddEnum ("Light", "m_RenderMode", 0, "Auto");
	AddEnum ("Light", "m_RenderMode", 1, "Important");
	AddEnum ("Light", "m_RenderMode", 2, "Not Important");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("Light", "m_Shadows", "Shadow settings.");
	AddDocumentation ("Light", "m_Flare", "Does the light have a flare?");
	AddDocumentation ("Light", "m_CookieSize", "Cookie size for directional lights.");

	/* Class: LineRenderer */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("LineRenderer", "m_UseWorldSpace", "Draw lines in worldspace (or localspace).");

	/* Class: ModelImporter */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("ModelImporter", "m_AnimationType", "The type of animation to support / import.");
	AddEnum ("ModelImporter", "m_AnimationType", 0, "None");
	AddEnum ("ModelImporter", "m_AnimationType", 1, "Legacy");
	AddEnum ("ModelImporter", "m_AnimationType", 2, "Generic");
	AddEnum ("ModelImporter", "m_AnimationType", 3, "Humanoid");

	// Note: all this is auto-generated, see at top of file

	/* Class: NavMeshAgent */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("NavMeshAgent", "m_ObstacleAvoidanceType", "");
	AddEnum ("NavMeshAgent", "m_ObstacleAvoidanceType", 0, "None");
	AddEnum ("NavMeshAgent", "m_ObstacleAvoidanceType", 1, "Low Quality");
	AddEnum ("NavMeshAgent", "m_ObstacleAvoidanceType", 2, "Medium Quality");
	AddEnum ("NavMeshAgent", "m_ObstacleAvoidanceType", 3, "Good Quality");
	AddEnum ("NavMeshAgent", "m_ObstacleAvoidanceType", 4, "High Quality");

	// Note: all this is auto-generated, see at top of file

	/* Class: NetworkManager */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("NetworkManager", "m_DebugLevel", "");
	AddEnum ("NetworkManager", "m_DebugLevel", 0, "Off");
	AddEnum ("NetworkManager", "m_DebugLevel", 1, "Informational");
	AddEnum ("NetworkManager", "m_DebugLevel", 2, "Full");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("NetworkManager", "m_PeerType", "");
	AddEnum ("NetworkManager", "m_PeerType", 0, "Server");
	AddEnum ("NetworkManager", "m_PeerType", 1, "Client");
	AddEnum ("NetworkManager", "m_PeerType", 2, "Server-Client");

	// Note: all this is auto-generated, see at top of file

	/* Class: NetworkView */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("NetworkView", "m_StateSynchronization", "");
	AddEnum ("NetworkView", "m_StateSynchronization", 0, "Off");
	AddEnum ("NetworkView", "m_StateSynchronization", 1, "Reliable Delta Compressed");
	AddEnum ("NetworkView", "m_StateSynchronization", 2, "Unreliable");

	// Note: all this is auto-generated, see at top of file

	/* Class: ParticleEmitter */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("ParticleEmitter", "m_UseWorldSpace", "Are particles simulated in WorldSpace or in LocalSpace?");
	AddDocumentation ("ParticleEmitter", "minEnergy", "minimum size [ 0, infinity  ]");
	AddRangedValue ("ParticleEmitter", "minEnergy", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("ParticleEmitter", "m_MinEnergy", "minimum energy [ 0, infinity  ]");
	AddRangedValue ("ParticleEmitter", "m_MinEnergy", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("ParticleEmitter", "m_MaxSize", "maximum size [ 0, infinity  ]");
	AddRangedValue ("ParticleEmitter", "m_MaxSize", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("ParticleEmitter", "maxEnergy", "minimum size [ 0, infinity  ]");
	AddRangedValue ("ParticleEmitter", "maxEnergy", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("ParticleEmitter", "m_EmitterVelocityScale", "Scales velocity of the emitter.");
	AddDocumentation ("ParticleEmitter", "maxEmission", "minimum size [ 0, infinity  ]");
	AddRangedValue ("ParticleEmitter", "maxEmission", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("ParticleEmitter", "m_MaxEmission", "maximum emissions per second [ 0, infinity  ]");
	AddRangedValue ("ParticleEmitter", "m_MaxEmission", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("ParticleEmitter", "minSize", "minimum size [ 0, infinity  ]");
	AddRangedValue ("ParticleEmitter", "minSize", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("ParticleEmitter", "minEmission", "minimum size [ 0, infinity  ]");
	AddRangedValue ("ParticleEmitter", "minEmission", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("ParticleEmitter", "maxSize", "minimum size [ 0, infinity  ]");
	AddRangedValue ("ParticleEmitter", "maxSize", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("ParticleEmitter", "m_RndInitialRotations", "Should initial particle rotations be randomized?");
	AddDocumentation ("ParticleEmitter", "m_MinSize", "minimum size [ 0, infinity  ]");
	AddRangedValue ("ParticleEmitter", "m_MinSize", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("ParticleEmitter", "m_MaxEnergy", "maximum energy [ 0, infinity  ]");
	AddRangedValue ("ParticleEmitter", "m_MaxEnergy", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("ParticleEmitter", "m_MinEmission", "minimum emissions per second [ 0, infinity  ]");
	AddRangedValue ("ParticleEmitter", "m_MinEmission", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));

	/* Class: ParticleRenderer */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("ParticleRenderer", "m_UVAnimation", "Tiled UV settings.");
	AddDocumentation ("ParticleRenderer", "m_VelocityScale", "When Stretch Particles is enabled, defines the length of the particle compared to its velocity.");
	AddDocumentation ("ParticleRenderer", "m_MaxParticleSize", "How large is a particle allowed to be on screen at most? 1 is entire viewport. 0.5 is half viewport.");
	AddDocumentation ("ParticleRenderer", "m_CameraVelocityScale", "How much the camera motion is factored in when determining particle stretching.");
	AddDocumentation ("ParticleRenderer", "m_LengthScale", "When Stretch Particles is enabled, defines the length of the particle compared to its width.");
	AddDocumentation ("ParticleRenderer", "m_StretchParticles", "Should the particles be stretched along their velocity?");
	AddEnum ("ParticleRenderer", "m_StretchParticles", 0, "Billboard");
	AddEnum ("ParticleRenderer", "m_StretchParticles", 3, "Stretched");
	AddEnum ("ParticleRenderer", "m_StretchParticles", 2, "Sorted Billboard");
	AddEnum ("ParticleRenderer", "m_StretchParticles", 4, "Horizontal Billboard");
	AddEnum ("ParticleRenderer", "m_StretchParticles", 5, "Vertical Billboard");

	// Note: all this is auto-generated, see at top of file

	/* Class: PgBaseResult */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PgBaseResult", "m_Conn", "Pointer to PgConn object that created the result set.");
	AddDocumentation ("PgBaseResult", "m_Rows", "Cached row-count (initially -1, but that value is never returned).");
	AddDocumentation ("PgBaseResult", "m_Refs", "Shared integer, that contains the reference count.");
	AddDocumentation ("PgBaseResult", "m_Res", "Shared and reference counted libpq result set opaque object.");

	/* Class: PhysicMaterial */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PhysicMaterial", "staticFriction", "[ 0, infinity  ]");
	AddRangedValue ("PhysicMaterial", "staticFriction", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("PhysicMaterial", "frictionDirection2", "Friction.");
	AddDocumentation ("PhysicMaterial", "m_DynamicFriction", "[ 0, 1  ]");
	AddRangedValue ("PhysicMaterial", "m_DynamicFriction", make_pair<float, float>(0.0f, 1.0f));
	AddDocumentation ("PhysicMaterial", "m_FrictionCombine", "");
	AddEnum ("PhysicMaterial", "m_FrictionCombine", 0, "Average");
	AddEnum ("PhysicMaterial", "m_FrictionCombine", 1, "Minimum");
	AddEnum ("PhysicMaterial", "m_FrictionCombine", 2, "Multiply");
	AddEnum ("PhysicMaterial", "m_FrictionCombine", 3, "Maximum");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PhysicMaterial", "m_Bounciness", "[ 0, 1  ]");
	AddRangedValue ("PhysicMaterial", "m_Bounciness", make_pair<float, float>(0.0f, 1.0f));
	AddDocumentation ("PhysicMaterial", "dynamicFriction", "[ 0, 1  ]");
	AddRangedValue ("PhysicMaterial", "dynamicFriction", make_pair<float, float>(0.0f, 1.0f));
	AddDocumentation ("PhysicMaterial", "bounciness", "[ 0, 1  ]");
	AddRangedValue ("PhysicMaterial", "bounciness", make_pair<float, float>(0.0f, 1.0f));
	AddDocumentation ("PhysicMaterial", "bounceCombine", "");
	AddEnum ("PhysicMaterial", "bounceCombine", 0, "Average");
	AddEnum ("PhysicMaterial", "bounceCombine", 1, "Minimum");
	AddEnum ("PhysicMaterial", "bounceCombine", 2, "Multiply");
	AddEnum ("PhysicMaterial", "bounceCombine", 3, "Maximum");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PhysicMaterial", "m_FrictionDirection2", "Friction.");
	AddDocumentation ("PhysicMaterial", "m_BounceCombine", "");
	AddEnum ("PhysicMaterial", "m_BounceCombine", 0, "Average");
	AddEnum ("PhysicMaterial", "m_BounceCombine", 1, "Minimum");
	AddEnum ("PhysicMaterial", "m_BounceCombine", 2, "Multiply");
	AddEnum ("PhysicMaterial", "m_BounceCombine", 3, "Maximum");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PhysicMaterial", "staticFriction2", "[ 0, infinity  ]");
	AddRangedValue ("PhysicMaterial", "staticFriction2", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("PhysicMaterial", "m_DynamicFriction2", "[ 0, 1  ]");
	AddRangedValue ("PhysicMaterial", "m_DynamicFriction2", make_pair<float, float>(0.0f, 1.0f));
	AddDocumentation ("PhysicMaterial", "dynamicFriction2", "[ 0, 1  ]");
	AddRangedValue ("PhysicMaterial", "dynamicFriction2", make_pair<float, float>(0.0f, 1.0f));
	AddDocumentation ("PhysicMaterial", "m_StaticFriction", "[ 0, infinity  ]");
	AddRangedValue ("PhysicMaterial", "m_StaticFriction", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("PhysicMaterial", "frictionCombine", "");
	AddEnum ("PhysicMaterial", "frictionCombine", 0, "Average");
	AddEnum ("PhysicMaterial", "frictionCombine", 1, "Minimum");
	AddEnum ("PhysicMaterial", "frictionCombine", 2, "Multiply");
	AddEnum ("PhysicMaterial", "frictionCombine", 3, "Maximum");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PhysicMaterial", "m_StaticFriction2", "[ 0, infinity  ]");
	AddRangedValue ("PhysicMaterial", "m_StaticFriction2", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));

	/* Class: Physics2DSettings */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("Physics2DSettings", "m_VelocityIterations", "The number of iterations used to solve simulation velocities. More iterations yield a better simulation but is more expensive. (Default 8) [ 1 , infinity  ].");
	AddRangedValue ("Physics2DSettings", "m_VelocityIterations", make_pair<float, float>(1.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("Physics2DSettings", "m_Gravity", "The gravity applied to all rigid bodies in the scene.");
	AddDocumentation ("Physics2DSettings", "m_RaycastsHitTriggers", "Whether ray/line casts hit triggers or not.");
	AddDocumentation ("Physics2DSettings", "m_PositionIterations", "The number of iterations used to solve simulation positions. More iterations yield a better simulation but is more expensive. (Default 3) [ 1 , infinity  ].");
	AddRangedValue ("Physics2DSettings", "m_PositionIterations", make_pair<float, float>(1.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("Physics2DSettings", "m_DefaultMaterial", "The default material to use on a collider if no material is specified on it.");

	/* Class: PhysicsManager */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PhysicsManager", "m_DefaultIterationCount", "Solver accuracy. Higher value costs more performance. (Default 4) [ 1, 30  ].");
	AddRangedValue ("PhysicsManager", "m_DefaultIterationCount", make_pair<float, float>(1.0f, 30.0f));
	AddDocumentation ("PhysicsManager", "m_BounceThreshold", "A contact with a relative velocity below this will not bounce. (Default 2) [ 0, infinity  ].");
	AddRangedValue ("PhysicsManager", "m_BounceThreshold", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("PhysicsManager", "m_Gravity", "The gravity applied to all rigid bodies in the scene.");
	AddDocumentation ("PhysicsManager", "m_MinPenetrationForPenalty", "The minimum contact penetration value in order to apply a penalty force. (Default 0.01) [ 0 , infinity  ].");
	AddRangedValue ("PhysicsManager", "m_MinPenetrationForPenalty", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("PhysicsManager", "m_SleepVelocity", "The default linear velocity, below which objects start going to sleep. This value can be overridden per rigidbodies with scripting. (Default 0.15) [ 0, infinity  ].");
	AddRangedValue ("PhysicsManager", "m_SleepVelocity", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("PhysicsManager", "m_MaxAngularVelocity", "The maximum angular velocity permitted for any rigid bodies. This can be overridden per rigidbodies with scripting. (Default 7) [ 0, infinity  ].");
	AddRangedValue ("PhysicsManager", "m_MaxAngularVelocity", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("PhysicsManager", "m_PenetrationPenaltyForce", "The penalty force applied to the bodies in an interpenetrating contact is scaled by this value. (Default 0.6) [ 0, 2  ].");
	AddRangedValue ("PhysicsManager", "m_PenetrationPenaltyForce", make_pair<float, float>(0.0f, 2.0f));
	AddDocumentation ("PhysicsManager", "m_SleepAngularVelocity", "The default linear velocity, below which objects start going to sleep. This value can be overridden per rigidbodies with scripting. (Default 0.14) [ 0, infinity  ].");
	AddRangedValue ("PhysicsManager", "m_SleepAngularVelocity", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));

	/* Class: PhysicsMaterial2D */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PhysicsMaterial2D", "m_Friction", "Friction. Range { 0.0, 100000.0 }.");
	AddDocumentation ("PhysicsMaterial2D", "m_Bounciness", "Bounciness. Range { 0.0, 1.0 }.");

	/* Struct: PlayerSettings */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PlayerSettings", "overrideIPodMusic", "Force mixing behavior allowing iPod audio to play with FMOD even if the audio session doesn't usually permit this.");
	AddDocumentation ("PlayerSettings", "displayResolutionDialog", "");
	AddEnum ("PlayerSettings", "displayResolutionDialog", 0, "Disabled");
	AddEnum ("PlayerSettings", "displayResolutionDialog", 1, "Enabled");
	AddEnum ("PlayerSettings", "displayResolutionDialog", 2, "Hidden By Default");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PlayerSettings", "metroTileShowName", "");
	AddEnum ("PlayerSettings", "metroTileShowName", 0, "(not set)");
	AddEnum ("PlayerSettings", "metroTileShowName", 1, "All logos");
	AddEnum ("PlayerSettings", "metroTileShowName", 2, "No logos");
	AddEnum ("PlayerSettings", "metroTileShowName", 3, "Standard logo only");
	AddEnum ("PlayerSettings", "metroTileShowName", 4, "Wide logo only");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PlayerSettings", "m_ActiveColorSpace", "");
	AddEnum ("PlayerSettings", "m_ActiveColorSpace", 0, "Gamma");
	AddEnum ("PlayerSettings", "m_ActiveColorSpace", 1, "Linear");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PlayerSettings", "macFullscreenMode", "");
	AddEnum ("PlayerSettings", "macFullscreenMode", 0, "CaptureDisplay");
	AddEnum ("PlayerSettings", "macFullscreenMode", 1, "FullscreenWindow");
	AddEnum ("PlayerSettings", "macFullscreenMode", 2, "FullscreenWindowWithMenuBarAndDock");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PlayerSettings", "apiCompatibilityLevel", "");
	AddEnum ("PlayerSettings", "apiCompatibilityLevel", 1, ".NET 2.0");
	AddEnum ("PlayerSettings", "apiCompatibilityLevel", 2, ".NET 2.0 Subset");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PlayerSettings", "AndroidPreferredInstallLocation", "");
	AddEnum ("PlayerSettings", "AndroidPreferredInstallLocation", 0, "Automatic");
	AddEnum ("PlayerSettings", "AndroidPreferredInstallLocation", 1, "Prefer External");
	AddEnum ("PlayerSettings", "AndroidPreferredInstallLocation", 2, "Force Internal");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PlayerSettings", "iPhoneScriptCallOptimization", "");
	AddEnum ("PlayerSettings", "iPhoneScriptCallOptimization", 0, "Slow and Safe");
	AddEnum ("PlayerSettings", "iPhoneScriptCallOptimization", 1, "Fast but no Exceptions");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PlayerSettings", "iPhoneSdkVersion", "");
	AddEnum ("PlayerSettings", "iPhoneSdkVersion", 988, "Device SDK");
	AddEnum ("PlayerSettings", "iPhoneSdkVersion", 989, "Simulator SDK");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PlayerSettings", "accelerometerFrequency", "");
	AddEnum ("PlayerSettings", "accelerometerFrequency", 0, "Disabled");
	AddEnum ("PlayerSettings", "accelerometerFrequency", 15, "15 Hz");
	AddEnum ("PlayerSettings", "accelerometerFrequency", 30, "30 Hz");
	AddEnum ("PlayerSettings", "accelerometerFrequency", 60, "60 Hz");
	AddEnum ("PlayerSettings", "accelerometerFrequency", 100, "100 Hz");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PlayerSettings", "targetResolution", "");
	AddEnum ("PlayerSettings", "targetResolution", 0, "Native (default device resolution)");
	AddEnum ("PlayerSettings", "targetResolution", 3, "Auto (Best Performance)");
	AddEnum ("PlayerSettings", "targetResolution", 4, "Auto (Best Quality)");
	AddEnum ("PlayerSettings", "targetResolution", 5, "320p (iPhone)");
	AddEnum ("PlayerSettings", "targetResolution", 6, "640p (iPhone Retina Display)");
	AddEnum ("PlayerSettings", "targetResolution", 7, "768p (iPad)");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PlayerSettings", "wiiHio2Usage", "Wii Hio2 Usage.");
	AddEnum ("PlayerSettings", "wiiHio2Usage", -1, "None");
	AddEnum ("PlayerSettings", "wiiHio2Usage", 0, "Profiler");
	AddEnum ("PlayerSettings", "wiiHio2Usage", 1, "Automation");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PlayerSettings", "AndroidSplashScreenScale", "");
	AddEnum ("PlayerSettings", "AndroidSplashScreenScale", 0, "Center (only scale down)");
	AddEnum ("PlayerSettings", "AndroidSplashScreenScale", 1, "Scale to fit (letter-boxed)");
	AddEnum ("PlayerSettings", "AndroidSplashScreenScale", 2, "Scale to fill (cropped)");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PlayerSettings", "targetGlesGraphics", "");
	AddEnum ("PlayerSettings", "targetGlesGraphics", 1, "OpenGL ES 2.0");
	AddEnum ("PlayerSettings", "targetGlesGraphics", 2, "OpenGL ES 3.0");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PlayerSettings", "flashStrippingLevel", "");
	AddEnum ("PlayerSettings", "flashStrippingLevel", 0, "Disabled");
	AddEnum ("PlayerSettings", "flashStrippingLevel", 2, "Strip ByteCode");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PlayerSettings", "iPhoneStrippingLevel", "");
	AddEnum ("PlayerSettings", "iPhoneStrippingLevel", 0, "Disabled");
	AddEnum ("PlayerSettings", "iPhoneStrippingLevel", 1, "Strip Assemblies");
	AddEnum ("PlayerSettings", "iPhoneStrippingLevel", 2, "Strip ByteCode");
	AddEnum ("PlayerSettings", "iPhoneStrippingLevel", 3, "Use micro mscorlib");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PlayerSettings", "targetDevice", "");
	AddEnum ("PlayerSettings", "targetDevice", 0, "iPhone Only");
	AddEnum ("PlayerSettings", "targetDevice", 1, "iPad Only");
	AddEnum ("PlayerSettings", "targetDevice", 2, "iPhone + iPad");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PlayerSettings", "iosShowActivityIndicatorOnLoading", "");
	AddEnum ("PlayerSettings", "iosShowActivityIndicatorOnLoading", -1, "Don't Show");
	AddEnum ("PlayerSettings", "iosShowActivityIndicatorOnLoading", 0, "White Large");
	AddEnum ("PlayerSettings", "iosShowActivityIndicatorOnLoading", 1, "White");
	AddEnum ("PlayerSettings", "iosShowActivityIndicatorOnLoading", 2, "Gray");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PlayerSettings", "m_MobileRenderingPath", "Rendering path to use on Mobiles.");
	AddEnum ("PlayerSettings", "m_MobileRenderingPath", 0, "Vertex Lit");
	AddEnum ("PlayerSettings", "m_MobileRenderingPath", 1, "Forward");
	AddEnum ("PlayerSettings", "m_MobileRenderingPath", 2, "Deferred Lighting");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PlayerSettings", "iPhoneTargetOSVersion", "");
	AddEnum ("PlayerSettings", "iPhoneTargetOSVersion", 10, "4.0");
	AddEnum ("PlayerSettings", "iPhoneTargetOSVersion", 12, "4.1");
	AddEnum ("PlayerSettings", "iPhoneTargetOSVersion", 14, "4.2");
	AddEnum ("PlayerSettings", "iPhoneTargetOSVersion", 16, "4.3");
	AddEnum ("PlayerSettings", "iPhoneTargetOSVersion", 18, "5.0");
	AddEnum ("PlayerSettings", "iPhoneTargetOSVersion", 20, "5.1");
	AddEnum ("PlayerSettings", "iPhoneTargetOSVersion", 22, "6.0");
	AddEnum ("PlayerSettings", "iPhoneTargetOSVersion", 999, "Unknown");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PlayerSettings", "androidShowActivityIndicatorOnLoading", "");
	AddEnum ("PlayerSettings", "androidShowActivityIndicatorOnLoading", -1, "Don't Show");
	AddEnum ("PlayerSettings", "androidShowActivityIndicatorOnLoading", 0, "Large");
	AddEnum ("PlayerSettings", "androidShowActivityIndicatorOnLoading", 1, "Inversed Large");
	AddEnum ("PlayerSettings", "androidShowActivityIndicatorOnLoading", 2, "Small");
	AddEnum ("PlayerSettings", "androidShowActivityIndicatorOnLoading", 3, "Inversed Small");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PlayerSettings", "defaultScreenOrientation", "");
	AddEnum ("PlayerSettings", "defaultScreenOrientation", 0, "Portrait");
	AddEnum ("PlayerSettings", "defaultScreenOrientation", 1, "Portrait Upside Down");
	AddEnum ("PlayerSettings", "defaultScreenOrientation", 2, "Landscape Right");
	AddEnum ("PlayerSettings", "defaultScreenOrientation", 3, "Landscape Left");
	AddEnum ("PlayerSettings", "defaultScreenOrientation", 4, "Auto Rotation");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PlayerSettings", "metroTileForegroundText", "");
	AddEnum ("PlayerSettings", "metroTileForegroundText", 1, "Light");
	AddEnum ("PlayerSettings", "metroTileForegroundText", 2, "Dark");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PlayerSettings", "AndroidMinSdkVersion", "");
	AddEnum ("PlayerSettings", "AndroidMinSdkVersion", 9, "Android 2.3.1 'Gingerbread' (API level 9)");
	AddEnum ("PlayerSettings", "AndroidMinSdkVersion", 10, "Android 2.3.3 'Gingerbread' (API level 10)");
	AddEnum ("PlayerSettings", "AndroidMinSdkVersion", 11, "Android 3.0 'Honeycomb' (API level 11)");
	AddEnum ("PlayerSettings", "AndroidMinSdkVersion", 12, "Android 3.1 'Honeycomb' (API level 12)");
	AddEnum ("PlayerSettings", "AndroidMinSdkVersion", 13, "Android 3.2 'Honeycomb' (API level 13)");
	AddEnum ("PlayerSettings", "AndroidMinSdkVersion", 14, "Android 4.0 'Ice Cream Sandwich' (API level 14)");
	AddEnum ("PlayerSettings", "AndroidMinSdkVersion", 15, "Android 4.0.3 'Ice Cream Sandwich' (API level 15)");
	AddEnum ("PlayerSettings", "AndroidMinSdkVersion", 16, "Android 4.1 'Jelly Bean' (API level 16)");
	AddEnum ("PlayerSettings", "AndroidMinSdkVersion", 17, "Android 4.2 'Jelly Bean' (API level 17)");
	AddEnum ("PlayerSettings", "AndroidMinSdkVersion", 18, "Android 4.3 'Jelly Bean' (API level 18)");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PlayerSettings", "wiiLoadingScreenRectPlacement", "Placement.");
	AddEnum ("PlayerSettings", "wiiLoadingScreenRectPlacement", 0, "TopLeft");
	AddEnum ("PlayerSettings", "wiiLoadingScreenRectPlacement", 1, "TopCenter");
	AddEnum ("PlayerSettings", "wiiLoadingScreenRectPlacement", 2, "TopRight");
	AddEnum ("PlayerSettings", "wiiLoadingScreenRectPlacement", 3, "MiddleLeft");
	AddEnum ("PlayerSettings", "wiiLoadingScreenRectPlacement", 4, "MiddleCenter");
	AddEnum ("PlayerSettings", "wiiLoadingScreenRectPlacement", 5, "MiddlerRight");
	AddEnum ("PlayerSettings", "wiiLoadingScreenRectPlacement", 6, "BottomLeft");
	AddEnum ("PlayerSettings", "wiiLoadingScreenRectPlacement", 7, "BottomCenter");
	AddEnum ("PlayerSettings", "wiiLoadingScreenRectPlacement", 8, "BottomRight");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PlayerSettings", "AndroidTargetDevice", "");
	AddEnum ("PlayerSettings", "AndroidTargetDevice", 0, "ARMv7 only");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PlayerSettings", "metroCompilationOverrides", "");
	AddEnum ("PlayerSettings", "metroCompilationOverrides", 0, "None");
	AddEnum ("PlayerSettings", "metroCompilationOverrides", 1, "C# against .NET Core");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PlayerSettings", "m_RenderingPath", "Rendering path to use.");
	AddEnum ("PlayerSettings", "m_RenderingPath", 0, "Vertex Lit");
	AddEnum ("PlayerSettings", "m_RenderingPath", 1, "Forward");
	AddEnum ("PlayerSettings", "m_RenderingPath", 2, "Deferred Lighting");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PlayerSettings", "wiiRegion", "");
	AddEnum ("PlayerSettings", "wiiRegion", 1, "Japan");
	AddEnum ("PlayerSettings", "wiiRegion", 2, "USA");
	AddEnum ("PlayerSettings", "wiiRegion", 3, "Europe");
	AddEnum ("PlayerSettings", "wiiRegion", 4, "China");
	AddEnum ("PlayerSettings", "wiiRegion", 5, "Korea");
	AddEnum ("PlayerSettings", "wiiRegion", 6, "Taiwan");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PlayerSettings", "uIStatusBarStyle", "");
	AddEnum ("PlayerSettings", "uIStatusBarStyle", 0, "Default");
	AddEnum ("PlayerSettings", "uIStatusBarStyle", 1, "Black Translucent");
	AddEnum ("PlayerSettings", "uIStatusBarStyle", 2, "Black Opaque");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("PlayerSettings", "prepareIOSForRecording", "If enabled, the AudioSession of iOS will be initialized in recording mode, thus avoiding delays when initializing the Microphone object.");

	/* Class: Projector */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("Projector", "m_Material", "Custom material to apply. If set it overrides, texture & blend mode settings.");

	/* Class: RaycastCollider */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("RaycastCollider", "m_Length", "[ 0, infinity  ]");
	AddRangedValue ("RaycastCollider", "m_Length", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));

	/* Class: RectT */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("RectT", "width", "Rectangle width.");
	AddDocumentation ("RectT", "x", "Rectangle x coordinate.");
	AddDocumentation ("RectT", "y", "Rectangle y coordinate.");
	AddDocumentation ("RectT", "height", "Rectangle height.");

	/* Class: RenderSettings */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("RenderSettings", "m_LinearFogEnd", "End distance for linear fog.");
	AddDocumentation ("RenderSettings", "m_HaloStrength", "Strength of light halos [ 0, 1 ].");
	AddRangedValue ("RenderSettings", "m_HaloStrength", make_pair<float, float>(0.0f, 1.0f));
	AddDocumentation ("RenderSettings", "m_AmbientLight", "Scene ambient color.");
	AddDocumentation ("RenderSettings", "m_FogColor", "Fog color.");
	AddDocumentation ("RenderSettings", "m_Fog", "Use fog in the scene?");
	AddDocumentation ("RenderSettings", "m_FlareFadeSpeed", "Fade time for a flare.");
	AddDocumentation ("RenderSettings", "m_FlareStrength", "Strength of light flares [ 0, 1 ].");
	AddRangedValue ("RenderSettings", "m_FlareStrength", make_pair<float, float>(0.0f, 1.0f));
	AddDocumentation ("RenderSettings", "m_SkyboxMaterial", "The material used to render the skybox.");
	AddDocumentation ("RenderSettings", "m_LinearFogStart", "Starting distance for linear fog.");
	AddDocumentation ("RenderSettings", "m_SpotCookie", "The default spotlight cookie.");
	AddDocumentation ("RenderSettings", "m_HaloTexture", "The light halo texture.");
	AddDocumentation ("RenderSettings", "m_FogMode", "Fog mode to use.");
	AddEnum ("RenderSettings", "m_FogMode", 1, "Linear");
	AddEnum ("RenderSettings", "m_FogMode", 2, "Exponential");
	AddEnum ("RenderSettings", "m_FogMode", 3, "Exp2");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("RenderSettings", "m_FogDensity", "Density for exponential fog.");

	/* Class: RenderTexture */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("RenderTexture", "m_Height", "[ 1, 20000 ]");
	AddRangedValue ("RenderTexture", "m_Height", make_pair<float, float>(1.0f, 20000.0f));
	AddDocumentation ("RenderTexture", "m_AntiAliasing", "Anti-aliasing");
	AddEnum ("RenderTexture", "m_AntiAliasing", 1, "None");
	AddEnum ("RenderTexture", "m_AntiAliasing", 2, "2xMSAA");
	AddEnum ("RenderTexture", "m_AntiAliasing", 4, "4xMSAA");
	AddEnum ("RenderTexture", "m_AntiAliasing", 8, "8xMSAA");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("RenderTexture", "m_VolumeDepth", "[ 1, 20000 ]");
	AddRangedValue ("RenderTexture", "m_VolumeDepth", make_pair<float, float>(1.0f, 20000.0f));
	AddDocumentation ("RenderTexture", "m_Width", "[ 1, 20000 ]");
	AddRangedValue ("RenderTexture", "m_Width", make_pair<float, float>(1.0f, 20000.0f));
	AddDocumentation ("RenderTexture", "m_DepthFormat", "Depth buffer format");
	AddEnum ("RenderTexture", "m_DepthFormat", 0, "No depth buffer");
	AddEnum ("RenderTexture", "m_DepthFormat", 1, "16 bit depth");
	AddEnum ("RenderTexture", "m_DepthFormat", 2, "24 bit depth");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("RenderTexture", "m_ColorFormat", "Color buffer format");
	AddEnum ("RenderTexture", "m_ColorFormat", 0, "RGBA32");
	AddEnum ("RenderTexture", "m_ColorFormat", 1, "Depth texture");

	// Note: all this is auto-generated, see at top of file

	/* Class: Renderer */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("Renderer", "m_Materials", "List of materials to use when rendering.");
	AddDocumentation ("Renderer", "m_LightProbeAnchor", "Light probe lighting is interpolated at the center of the renderer's bounds or at the position of the anchor, if assigned.");

	/* Class: Rigidbody */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("Rigidbody", "m_AngularDrag", "The angular drag coefficient. 0 means no damping. [ 0, infinity  ].");
	AddRangedValue ("Rigidbody", "m_AngularDrag", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("Rigidbody", "m_Interpolate", "This is used to prevent read back from kinematic rigidbodies.");
	AddEnum ("Rigidbody", "m_Interpolate", 0, "None");
	AddEnum ("Rigidbody", "m_Interpolate", 1, "Interpolate");
	AddEnum ("Rigidbody", "m_Interpolate", 2, "Extrapolate");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("Rigidbody", "m_Drag", "The linear drag coefficient. 0 means no damping. [ 0, infinity  ].");
	AddRangedValue ("Rigidbody", "m_Drag", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("Rigidbody", "m_Mass", "The mass of the body. [ 0.0000001, 1000000000  ].");
	AddRangedValue ("Rigidbody", "m_Mass", make_pair<float, float>(0.0000001f, 1000000000.0f));
	AddDocumentation ("Rigidbody", "m_CollisionDetection", "");
	AddEnum ("Rigidbody", "m_CollisionDetection", 0, "Discrete");
	AddEnum ("Rigidbody", "m_CollisionDetection", 1, "Continuous");
	AddEnum ("Rigidbody", "m_CollisionDetection", 2, "Continuous Dynamic");

	// Note: all this is auto-generated, see at top of file

	/* Class: Rigidbody2D */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("Rigidbody2D", "m_IsKinematic", "Whether the body is kinematic or not. If not then the body is dynamic.");
	AddDocumentation ("Rigidbody2D", "m_FixedAngle", "Whether the body's angle is fixed or not.");
	AddDocumentation ("Rigidbody2D", "m_AngularDrag", "The angular drag coefficient. 0 means no damping. [ 0, 1000000  ].");
	AddRangedValue ("Rigidbody2D", "m_AngularDrag", make_pair<float, float>(0.0f, 1000000.0f));
	AddDocumentation ("Rigidbody2D", "m_Interpolate", "The per-frame update mode for the body..");
	AddEnum ("Rigidbody2D", "m_Interpolate", 0, "None");
	AddEnum ("Rigidbody2D", "m_Interpolate", 1, "Interpolate");
	AddEnum ("Rigidbody2D", "m_Interpolate", 2, "Extrapolate");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("Rigidbody2D", "m_GravityScale", "How much gravity affects this body. [ -1000000, 1000000  ].");
	AddRangedValue ("Rigidbody2D", "m_GravityScale", make_pair<float, float>(-1000000, 1000000.0f));
	AddDocumentation ("Rigidbody2D", "m_LinearDrag", "The linear drag coefficient. 0 means no damping. [ 0, 1000000  ].");
	AddRangedValue ("Rigidbody2D", "m_LinearDrag", make_pair<float, float>(0.0f, 1000000.0f));
	AddDocumentation ("Rigidbody2D", "m_Mass", "The mass of the body. [ 0.0001, 1000000  ].");
	AddRangedValue ("Rigidbody2D", "m_Mass", make_pair<float, float>(0.0001f, 1000000.0f));
	AddDocumentation ("Rigidbody2D", "m_CollisionDetection", "The collision detection mode for the body..");
	AddEnum ("Rigidbody2D", "m_CollisionDetection", 0, "Discrete");
	AddEnum ("Rigidbody2D", "m_CollisionDetection", 1, "Continuous");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("Rigidbody2D", "m_SleepingMode", "The sleeping mode for the body..");
	AddEnum ("Rigidbody2D", "m_SleepingMode", 0, "Never Sleep");
	AddEnum ("Rigidbody2D", "m_SleepingMode", 1, "Start Awake");
	AddEnum ("Rigidbody2D", "m_SleepingMode", 2, "Start Asleep");

	// Note: all this is auto-generated, see at top of file

	/* Class: SerializedObject */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("SerializedObject", "m_TypeTree", "Type tree for the first object in m_Objects.");

	/* Class: SkinnedMeshRenderer */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("SkinnedMeshRenderer", "m_UpdateWhenOffscreen", "Unity will calculate an accurate bounding volume representation every frame.");
	AddDocumentation ("SkinnedMeshRenderer", "m_Quality", "Number of bones to use per vertex during skinning.");
	AddEnum ("SkinnedMeshRenderer", "m_Quality", 0, "Auto");
	AddEnum ("SkinnedMeshRenderer", "m_Quality", 1, "1 Bone");
	AddEnum ("SkinnedMeshRenderer", "m_Quality", 2, "2 Bones");
	AddEnum ("SkinnedMeshRenderer", "m_Quality", 4, "4 Bones");

	// Note: all this is auto-generated, see at top of file

	/* Class: SliderJoint2D */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("SliderJoint2D", "m_TranslationLimits", "The joint angle limits.");
	AddDocumentation ("SliderJoint2D", "m_Anchor", "The local-space anchor from the base rigid-body.");
	AddDocumentation ("SliderJoint2D", "m_Motor", "The joint motor.");
	AddDocumentation ("SliderJoint2D", "m_UseMotor", "Whether to use the joint motor or not.");
	AddDocumentation ("SliderJoint2D", "m_Angle", "The translation angle that the joint slides along. [ 0.0, 359.9999  ].");
	AddRangedValue ("SliderJoint2D", "m_Angle", make_pair<float, float>(0.0f, 359.9999f));
	AddDocumentation ("SliderJoint2D", "m_UseLimits", "Whether to use the angle limits or not.");
	AddDocumentation ("SliderJoint2D", "m_ConnectedAnchor", "The local-space anchor from the connected rigid-body.");

	/* Class: SphereCollider */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("SphereCollider", "m_Radius", "The radius of the sphere. [ 0.00001, infinity  ].");
	AddRangedValue ("SphereCollider", "m_Radius", make_pair<float, float>(0.00001f, numeric_limits<float>::infinity ()));

	/* Class: SpringJoint2D */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("SpringJoint2D", "m_Anchor", "The local-space anchor from the base rigid-body.");
	AddDocumentation ("SpringJoint2D", "m_Distance", "The distance which the joint should attempt to maintain between attached bodies. [ 0.005, 1000000  ].");
	AddRangedValue ("SpringJoint2D", "m_Distance", make_pair<float, float>(0.005f, 1000000.0f));
	AddDocumentation ("SpringJoint2D", "m_DampingRatio", "The damping ratio for the oscillation whilst trying to achieve the specified distance. 0 means no damping. 1 means critical damping. [ 0.0, 1.0  ].");
	AddRangedValue ("SpringJoint2D", "m_DampingRatio", make_pair<float, float>(0.0f, 1.0f));
	AddDocumentation ("SpringJoint2D", "m_Frequency", "The frequency in Hertz for the oscillation whilst trying to achieve the specified distance. [ 0.0, 1000000  ].");
	AddRangedValue ("SpringJoint2D", "m_Frequency", make_pair<float, float>(0.0f, 1000000.0f));
	AddDocumentation ("SpringJoint2D", "m_ConnectedAnchor", "The local-space anchor from the connected rigid-body.");

	/* Class: TextMesh */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("TextMesh", "m_Anchor", "Where the text-mesh is anchored related to local origo..");
	AddEnum ("TextMesh", "m_Anchor", 0, "upper left");
	AddEnum ("TextMesh", "m_Anchor", 1, "upper center");
	AddEnum ("TextMesh", "m_Anchor", 2, "upper right");
	AddEnum ("TextMesh", "m_Anchor", 3, "middle left");
	AddEnum ("TextMesh", "m_Anchor", 4, "middle center");
	AddEnum ("TextMesh", "m_Anchor", 5, "middle right");
	AddEnum ("TextMesh", "m_Anchor", 6, "lower left");
	AddEnum ("TextMesh", "m_Anchor", 7, "lower center");
	AddEnum ("TextMesh", "m_Anchor", 8, "lower right");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("TextMesh", "m_CharacterSize", "Size of one character (as its height, since Aspect may change its width).");
	AddDocumentation ("TextMesh", "m_Alignment", "");
	AddEnum ("TextMesh", "m_Alignment", 0, "left");
	AddEnum ("TextMesh", "m_Alignment", 1, "center");
	AddEnum ("TextMesh", "m_Alignment", 2, "right");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("TextMesh", "m_LineSpacing", "Spacing between lines as multiplum of height of a character.");
	AddDocumentation ("TextMesh", "m_OffsetZ", "How much to offset the generated mesh from the Z-position=0.");
	AddDocumentation ("TextMesh", "m_FontStyle", "The font style to use. Only applicable for dynamic fonts..");
	AddEnum ("TextMesh", "m_FontStyle", 0, "Normal");
	AddEnum ("TextMesh", "m_FontStyle", 1, "Bold");
	AddEnum ("TextMesh", "m_FontStyle", 2, "Italic");
	AddEnum ("TextMesh", "m_FontStyle", 3, "Bold and Italic");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("TextMesh", "m_FontSize", "The font size to use. Set to 0 to use default font size. Only applicable for dynamic fonts.");
	AddDocumentation ("TextMesh", "m_TabSize", "Length of one tab.");

	/* Class: TimeManager */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("TimeManager", "m_TimeScale", "How fast compared to the real time does the game time progress (1.0 is realtime, .5 slow motion) [ -infinity, 100  ].");
	AddRangedValue ("TimeManager", "m_TimeScale", make_pair<float, float>(-numeric_limits<float>::infinity (), 100.0f));

	/* Class: TrailRenderer */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("TrailRenderer", "m_Time", "How long the tail should be (seconds). { 0, infinity}.");
	AddDocumentation ("TrailRenderer", "m_MinVertexDistance", "The minimum distance to spawn a new point on the trail [ 0, infinity ].");
	AddRangedValue ("TrailRenderer", "m_MinVertexDistance", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("TrailRenderer", "m_Autodestruct", "Destroy GameObject when there is no trail?");

	/* Class: TransformFeedbackSkinningInfo */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("TransformFeedbackSkinningInfo", "m_BoneCount", "Stores the bone count from the previous call to UpdateSourceBones. Used to select the most suitable shader version.");

	/* Class: Unity::Cloth */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("Cloth", "m_Damping", "Motion damping coefficient. 0 = disabled. [ 0, 1  ].");
	AddRangedValue ("Cloth", "m_Damping", make_pair<float, float>(0.0f, 1.0f));
	AddDocumentation ("Cloth", "m_ExternalAcceleration", "External acceleration applied to the cloth.");
	AddDocumentation ("Cloth", "m_Thickness", "Thickness of the Cloth surface. [ 0.001, 10000  ].");
	AddRangedValue ("Cloth", "m_Thickness", make_pair<float, float>(0.001f, 10000.0f));
	AddDocumentation ("Cloth", "m_RandomAcceleration", "Random acceleration applied to the cloth.");
	AddDocumentation ("Cloth", "m_StretchingStiffness", "Stretching stiffness. [ 0.001, 1  ].");
	AddRangedValue ("Cloth", "m_StretchingStiffness", make_pair<float, float>(0.001f, 1.0f));
	AddDocumentation ("Cloth", "m_UseGravity", "Should gravitational acceleration be applied to the cloth?");
	AddDocumentation ("Cloth", "m_SelfCollision", "Can the cloth collide with itself?");
	AddDocumentation ("Cloth", "m_BendingStiffness", "Bending stiffness. 0 = disabled. [ 0, 1  ].");
	AddRangedValue ("Cloth", "m_BendingStiffness", make_pair<float, float>(0.0f, 1.0f));

	/* Class: Unity::ConfigurableJoint */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("ConfigurableJoint", "m_RotationDriveMode", "");
	AddEnum ("ConfigurableJoint", "m_RotationDriveMode", 0, "X & YZ");
	AddEnum ("ConfigurableJoint", "m_RotationDriveMode", 1, "Slerp");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("ConfigurableJoint", "m_ProjectionMode", "");
	AddEnum ("ConfigurableJoint", "m_ProjectionMode", 0, "None");
	AddEnum ("ConfigurableJoint", "m_ProjectionMode", 1, "Position and Rotation");
	AddEnum ("ConfigurableJoint", "m_ProjectionMode", 2, "Position Only");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("ConfigurableJoint", "m_XMotion", "");
	AddEnum ("ConfigurableJoint", "m_XMotion", 0, "Locked");
	AddEnum ("ConfigurableJoint", "m_XMotion", 1, "Limited");
	AddEnum ("ConfigurableJoint", "m_XMotion", 2, "Free");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("ConfigurableJoint", "m_ZMotion", "");
	AddEnum ("ConfigurableJoint", "m_ZMotion", 0, "Locked");
	AddEnum ("ConfigurableJoint", "m_ZMotion", 1, "Limited");
	AddEnum ("ConfigurableJoint", "m_ZMotion", 2, "Free");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("ConfigurableJoint", "m_AngularZMotion", "");
	AddEnum ("ConfigurableJoint", "m_AngularZMotion", 0, "Locked");
	AddEnum ("ConfigurableJoint", "m_AngularZMotion", 1, "Limited");
	AddEnum ("ConfigurableJoint", "m_AngularZMotion", 2, "Free");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("ConfigurableJoint", "m_YMotion", "");
	AddEnum ("ConfigurableJoint", "m_YMotion", 0, "Locked");
	AddEnum ("ConfigurableJoint", "m_YMotion", 1, "Limited");
	AddEnum ("ConfigurableJoint", "m_YMotion", 2, "Free");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("ConfigurableJoint", "m_AngularYMotion", "");
	AddEnum ("ConfigurableJoint", "m_AngularYMotion", 0, "Locked");
	AddEnum ("ConfigurableJoint", "m_AngularYMotion", 1, "Limited");
	AddEnum ("ConfigurableJoint", "m_AngularYMotion", 2, "Free");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("ConfigurableJoint", "m_AngularXMotion", "");
	AddEnum ("ConfigurableJoint", "m_AngularXMotion", 0, "Locked");
	AddEnum ("ConfigurableJoint", "m_AngularXMotion", 1, "Limited");
	AddEnum ("ConfigurableJoint", "m_AngularXMotion", 2, "Free");

	// Note: all this is auto-generated, see at top of file

	/* Class: Unity::InteractiveCloth */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("InteractiveCloth", "m_AttachmentResponse", "Force to apply back to attached rigidbodies, if two way interaction is enabled for the attachment. [ 0, 1  ].");
	AddRangedValue ("InteractiveCloth", "m_AttachmentResponse", make_pair<float, float>(0.0f, 1.0f));
	AddDocumentation ("InteractiveCloth", "m_Friction", "Friction. [ 0, 1  ].");
	AddRangedValue ("InteractiveCloth", "m_Friction", make_pair<float, float>(0.0f, 1.0f));
	AddDocumentation ("InteractiveCloth", "m_Pressure", "Air pressure inside a closed cloth mesh. 0 = disabled. 1 = same pressure as outside atmosphere. [ 0, 10000  ].");
	AddRangedValue ("InteractiveCloth", "m_Pressure", make_pair<float, float>(0.0f, 10000.0f));
	AddDocumentation ("InteractiveCloth", "m_CollisionResponse", "Force to apply back to colliding rigidbodies. 0 = disabled. [ 0, 10000  ].");
	AddRangedValue ("InteractiveCloth", "m_CollisionResponse", make_pair<float, float>(0.0f, 10000.0f));
	AddDocumentation ("InteractiveCloth", "m_Density", "Density (mass per area). [ 0.001, 10000  ].");
	AddRangedValue ("InteractiveCloth", "m_Density", make_pair<float, float>(0.001f, 10000.0f));
	AddDocumentation ("InteractiveCloth", "m_TearFactor", "How far vertices need to stretch until they tear. 0 = disabled. [ 0, 10000  ].");
	AddRangedValue ("InteractiveCloth", "m_TearFactor", make_pair<float, float>(0.0f, 10000.0f));
	AddDocumentation ("InteractiveCloth", "m_AttachmentTearFactor", "How far vertices need to stretch until attachments tear off, if tearing is enabled for the attachment. [ 0.001, 10000  ].");
	AddRangedValue ("InteractiveCloth", "m_AttachmentTearFactor", make_pair<float, float>(0.001f, 10000.0f));

	/* Class: Unity::Joint */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("Joint", "m_BreakTorque", "Maximum torque the joint can withstand before breaking. Infinity means unbreakable. [ 0.001, infinity  ].");
	AddRangedValue ("Joint", "m_BreakTorque", make_pair<float, float>(0.001f, numeric_limits<float>::infinity ()));
	AddDocumentation ("Joint", "m_BreakForce", "Maximum force the joint can withstand before breaking. Infinity means unbreakable. [ 0.001, infinity  ].");
	AddRangedValue ("Joint", "m_BreakForce", make_pair<float, float>(0.001f, numeric_limits<float>::infinity ()));

	/* Class: Unity::SpringJoint */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("SpringJoint", "m_Damper", "[ 0, infinity  ]");
	AddRangedValue ("SpringJoint", "m_Damper", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("SpringJoint", "m_MinDistance", "[ 0, infinity  ]");
	AddRangedValue ("SpringJoint", "m_MinDistance", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("SpringJoint", "m_MaxDistance", "[ 0, infinity  ]");
	AddRangedValue ("SpringJoint", "m_MaxDistance", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("SpringJoint", "m_Spring", "[ 0, infinity  ]");
	AddRangedValue ("SpringJoint", "m_Spring", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));

	/* Class: WheelCollider */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("WheelCollider", "m_Radius", "[ 0, infinity  ]");
	AddRangedValue ("WheelCollider", "m_Radius", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("WheelCollider", "m_Mass", "[ 0.0001, infinity  ]");
	AddRangedValue ("WheelCollider", "m_Mass", make_pair<float, float>(0.0001f, numeric_limits<float>::infinity ()));
	AddDocumentation ("WheelCollider", "m_SuspensionDistance", "[ 0, infinity  ]");
	AddRangedValue ("WheelCollider", "m_SuspensionDistance", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));

	/* Class: WindZone */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("WindZone", "m_Mode", "");
	AddEnum ("WindZone", "m_Mode", 0, "Directional");
	AddEnum ("WindZone", "m_Mode", 1, "Spherical");

	// Note: all this is auto-generated, see at top of file

	/* Class: WorldParticleCollider */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("WorldParticleCollider", "m_CollisionEnergyLoss", "Seconds of energy a particle loses when colliding.");
	AddDocumentation ("WorldParticleCollider", "m_MinKillVelocity", "The velocity at which a particle is killed after the bounced velocity is calculated.");
	AddDocumentation ("WorldParticleCollider", "m_SendCollisionMessage", "Should we send out a collision message for every particle that has collided?");
	AddDocumentation ("WorldParticleCollider", "m_CollidesWith", "Collides the particles with every collider whose layerMask & m_CollidesWith != 0.");

	/* Class: OpenGLView */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("OpenGLView", "m_UseRealScreenCoords", "Set this to true to make GUIToScreenCoordinates user real screen coordinate (like the editor) Games (and hence, gameView uses (0,0) as the topleft - no matter where they are on the physical screen - that's false :).");

	/* Struct: AudioParameters */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("AudioParameters", "rolloffMode", "");
	AddEnum ("AudioParameters", "rolloffMode", 0, "kRolloffLogarithmic");
	AddEnum ("AudioParameters", "rolloffMode", 1, "kRolloffLinear");
	AddEnum ("AudioParameters", "rolloffMode", 2, "kRolloffCustom");

	// Note: all this is auto-generated, see at top of file

	/* Struct: CullResults */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("CullResults", "shadowCullData", ": Whats up with this thing? Does seem related...");

	/* Struct: DelayedCallManager::Callback */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("Callback", "object", "The object to pass to m_Call.");
	AddDocumentation ("Callback", "call", "The function call to execute.");

	/* Struct: EditorCurveBinding */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("EditorCurveBinding", "classID", ": Rename to propertyName, thats how it is called in C#");

	/* Struct: Flare::FlareElement */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("FlareElement", "m_Color", "Element color tint.");
	AddDocumentation ("FlareElement", "m_Zoom", "Make the flare size dependent on visibility?");
	AddDocumentation ("FlareElement", "m_Size", "The size of the element.");
	AddDocumentation ("FlareElement", "m_ImageIndex", "The image index from the flare texture.");
	AddDocumentation ("FlareElement", "m_Rotate", "Rotate the flare in respect to light angle?");
	AddDocumentation ("FlareElement", "m_Position", "The position of the element (0 = light, 1 = screen center).");
	AddDocumentation ("FlareElement", "m_UseLightColor", "Pick up the color from a light source?");
	AddDocumentation ("FlareElement", "m_Fade", "Make the flare fade dependent on visibility?");

	/* Struct: Font::CharacterInfo */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("CharacterInfo", "vert", "Rectangle for where to render the glyph.");
	AddDocumentation ("CharacterInfo", "uv", "UV coordinates for this glyph.");

	/* Struct: GLES3VBO::Stream */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("Stream", "curBufferNdx", "Current buffer in swap chain.");
	AddDocumentation ("Stream", "channelMask", "Shader channels which this stream contains.");
	AddDocumentation ("Stream", "cpuBuf", "CPU-side copy, used for Recreate() and emulating mapbuffer.");

	/* Struct: GUIStyleState */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("GUIStyleState", "textColor", "The color of the text.");
	AddDocumentation ("GUIStyleState", "background", "Background image used by this style.");

	/* Struct: ImportMeshSettings */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("ImportMeshSettings", "splitTangentsAcrossUV", "60 (default)");

	/* Struct: InputEvent */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("InputEvent", "pressure", "Stylus pressure.");
	AddDocumentation ("InputEvent", "mousePosition", "Position of mouse events.");
	AddDocumentation ("InputEvent", "modifiers", "keyboard modifier flags. (bitfield of Modifiers enum)");
	AddDocumentation ("InputEvent", "character", "unicode keyboard character (with modifiers).");
	AddDocumentation ("InputEvent", "keycode", "The keyboard scancode of the event.");
	AddDocumentation ("InputEvent", "delta", "Delta of mouse events.");
	AddDocumentation ("InputEvent", "type", "Which type of event.");
	AddDocumentation ("InputEvent", "button", "mouse button number. (bitfield of MouseButton enum)");

	/* Struct: JointAngleLimits2D */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("JointAngleLimits2D", "m_LowerAngle", "The lower angle (in degrees) limit to constrain the joint to. [ -359.9999, 359.9999  ].");
	AddRangedValue ("JointAngleLimits2D", "m_LowerAngle", make_pair<float, float>(-359.9999f, 359.9999f));
	AddDocumentation ("JointAngleLimits2D", "m_UpperAngle", "The upper angle (in degrees) limit to constrain the joint to. [ -359.9990, 359.9999  ].");
	AddRangedValue ("JointAngleLimits2D", "m_UpperAngle", make_pair<float, float>(-359.9990f, 359.9999f));

	/* Struct: JointDrive */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("JointDrive", "mode", "The mode of what this dirves.");
	AddEnum ("JointDrive", "mode", 0, "Disabled");
	AddEnum ("JointDrive", "mode", 1, "position");
	AddEnum ("JointDrive", "mode", 2, "velocity");
	AddEnum ("JointDrive", "mode", 3, "position and velocity");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("JointDrive", "maximumForce", "The maximum force the drive can exert to reach the target velocity. [ 0, infinity ].");
	AddRangedValue ("JointDrive", "maximumForce", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("JointDrive", "positionDamper", "The damping used to reach the target [ 0, infinity  ].");
	AddRangedValue ("JointDrive", "positionDamper", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("JointDrive", "positionSpring", "The spring used to reach the target [ 0, infinity  ].");
	AddRangedValue ("JointDrive", "positionSpring", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));

	/* Struct: JointLimits */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("JointLimits", "minBounce", "[ 0, 1 ]");
	AddRangedValue ("JointLimits", "minBounce", make_pair<float, float>(0.0f, 1.0f));
	AddDocumentation ("JointLimits", "maxBounce", "[ 0, 1 ]");
	AddRangedValue ("JointLimits", "maxBounce", make_pair<float, float>(0.0f, 1.0f));

	/* Struct: JointMotor */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("JointMotor", "targetVelocity", "target velocity of motor");
	AddDocumentation ("JointMotor", "force", "maximum motor force / torque [ 0, infinity  ]");
	AddRangedValue ("JointMotor", "force", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));

	/* Struct: JointMotor2D */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("JointMotor2D", "m_MaximumMotorForce", "The maximum force the motor can use to achieve the desired motor speed. [ 0.0, 1000000  ].");
	AddRangedValue ("JointMotor2D", "m_MaximumMotorForce", make_pair<float, float>(0.0f, 1000000.0f));
	AddDocumentation ("JointMotor2D", "m_MotorSpeed", "The target motor speed in degrees/second. [ -1000000, 1000000  ].");
	AddRangedValue ("JointMotor2D", "m_MotorSpeed", make_pair<float, float>(-1000000, 1000000.0f));

	/* Struct: JointSpring */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("JointSpring", "spring", "spring coefficient [ 0, infinity  ]");
	AddRangedValue ("JointSpring", "spring", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));
	AddDocumentation ("JointSpring", "targetPosition", "target value (angle/position) of spring where the spring force is zero.");
	AddDocumentation ("JointSpring", "damper", "damper coefficient [ 0, infinity  ]");
	AddRangedValue ("JointSpring", "damper", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));

	/* Struct: JointTranslationLimits2D */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("JointTranslationLimits2D", "m_UpperTranslation", "The upper translation limit to constrain the joint to. [ -1000000, 1000000  ].");
	AddRangedValue ("JointTranslationLimits2D", "m_UpperTranslation", make_pair<float, float>(-1000000, 1000000.0f));
	AddDocumentation ("JointTranslationLimits2D", "m_LowerTranslation", "The lower translation limit to constrain the joint to. [ -1000000, 1000000  ].");
	AddRangedValue ("JointTranslationLimits2D", "m_LowerTranslation", make_pair<float, float>(-1000000, 1000000.0f));

	/* Struct: LineParameters */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("LineParameters", "endWidth", "The width (in worldspace) at the line end.");
	AddDocumentation ("LineParameters", "startWidth", "The width (in worldspace) at the line start.");

	/* Struct: MenuItem */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("MenuItem", "m_Target", "the target for the event.");
	AddDocumentation ("MenuItem", "m_Command", "Command name. If empty, item is a separator.");
	AddDocumentation ("MenuItem", "m_Name", "Name of the command (without prefix).");
	AddDocumentation ("MenuItem", "m_Position", "Integer position (this is what we sort by).");
	AddDocumentation ("MenuItem", "m_Submenu", "Pointer to a submenu.");

	/* Struct: NetworkViewID */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("NetworkViewID", "m_Type", "");
	AddEnum ("NetworkViewID", "m_Type", 0, "Allocated");
	AddEnum ("NetworkViewID", "m_Type", 1, "Scene");

	// Note: all this is auto-generated, see at top of file

	/* Struct: ParticleRenderer::UVAnimation */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("UVAnimation", "yTile", "Number of texture tiles in the Y direction.");
	AddDocumentation ("UVAnimation", "xTile", "Number of texture tiles in the X direction.");
	AddDocumentation ("UVAnimation", "cycles", "Number of cycles over a particle's life span.");

	/* Struct: ParticleSystemRendererData */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("ParticleSystemRendererData", "maxParticleSize", "How large is a particle allowed to be on screen at most? 1 is entire viewport. 0.5 is half viewport.");
	AddDocumentation ("ParticleSystemRendererData", "normalDirection", "Value between 0.0 and 1.0. If 1.0 is used, normals will point towards camera. If 0.0 is used, normals will point out in the corner direction of the particle.");
	AddDocumentation ("ParticleSystemRendererData", "lengthScale", "When Stretch Particles is enabled, defines the length of the particle compared to its width.");
	AddDocumentation ("ParticleSystemRendererData", "velocityScale", "When Stretch Particles is enabled, defines the length of the particle compared to its velocity.");
	AddDocumentation ("ParticleSystemRendererData", "sortingFudge", "Lower the number, most likely that these particles will appear in front of other transparent objects, including other particles.");
	AddDocumentation ("ParticleSystemRendererData", "cachedMeshUserNode", "Node hooked into the mesh user list of cached meshes so we get notified when a mesh goes away.");
	AddDocumentation ("ParticleSystemRendererData", "cameraVelocityScale", "How much the camera motion is factored in when determining particle stretching.");
	AddDocumentation ("ParticleSystemRendererData", "sortMode", "");
	AddEnum ("ParticleSystemRendererData", "sortMode", 0, "None");
	AddEnum ("ParticleSystemRendererData", "sortMode", 1, "By Distance");
	AddEnum ("ParticleSystemRendererData", "sortMode", 2, "Youngest First");
	AddEnum ("ParticleSystemRendererData", "sortMode", 3, "Oldest First");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("ParticleSystemRendererData", "renderMode", "");
	AddEnum ("ParticleSystemRendererData", "renderMode", 0, "Billboard");
	AddEnum ("ParticleSystemRendererData", "renderMode", 1, "Stretched");
	AddEnum ("ParticleSystemRendererData", "renderMode", 2, "Horizontal Billboard");
	AddEnum ("ParticleSystemRendererData", "renderMode", 3, "Vertical Billboard");
	AddEnum ("ParticleSystemRendererData", "renderMode", 4, "Mesh");

	// Note: all this is auto-generated, see at top of file

	/* Struct: QualitySettings::QualitySetting */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("QualitySetting", "blendWeights", "Bone count for mesh skinning");
	AddEnum ("QualitySetting", "blendWeights", 1, "1 Bone");
	AddEnum ("QualitySetting", "blendWeights", 2, "2 Bones");
	AddEnum ("QualitySetting", "blendWeights", 4, "4 Bones");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("QualitySetting", "shadowProjection", "Shadow projection");
	AddEnum ("QualitySetting", "shadowProjection", 0, "Close Fit");
	AddEnum ("QualitySetting", "shadowProjection", 1, "Stable Fit");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("QualitySetting", "vSyncCount", "Limit refresh rate to avoid tearing");
	AddEnum ("QualitySetting", "vSyncCount", 0, "Don't Sync");
	AddEnum ("QualitySetting", "vSyncCount", 1, "Every VBlank");
	AddEnum ("QualitySetting", "vSyncCount", 2, "Every Second VBlank");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("QualitySetting", "shadowDistance", "Shadow drawing distance.");
	AddDocumentation ("QualitySetting", "shadowResolution", "Shadow resolution");
	AddEnum ("QualitySetting", "shadowResolution", 0, "Low Resolution");
	AddEnum ("QualitySetting", "shadowResolution", 1, "Medium Resolution");
	AddEnum ("QualitySetting", "shadowResolution", 2, "High Resolution");
	AddEnum ("QualitySetting", "shadowResolution", 3, "Very High Resolution");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("QualitySetting", "shadowCascades", "Number of cascades for directional light shadows");
	AddEnum ("QualitySetting", "shadowCascades", 1, "No Cascades");
	AddEnum ("QualitySetting", "shadowCascades", 2, "Two Cascades");
	AddEnum ("QualitySetting", "shadowCascades", 4, "Four Cascades");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("QualitySetting", "anisotropicTextures", "When to enable anisotropic texturing");
	AddEnum ("QualitySetting", "anisotropicTextures", 0, "Disabled");
	AddEnum ("QualitySetting", "anisotropicTextures", 1, "Per Texture");
	AddEnum ("QualitySetting", "anisotropicTextures", 2, "Forced On");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("QualitySetting", "particleRaycastBudget", "Number of rays to cast for approximate world collisions.");
	AddDocumentation ("QualitySetting", "shadows", "Shadow quality");
	AddEnum ("QualitySetting", "shadows", 0, "Disable Shadows");
	AddEnum ("QualitySetting", "shadows", 1, "Hard Shadows Only");
	AddEnum ("QualitySetting", "shadows", 2, "Hard and Soft Shadows");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("QualitySetting", "antiAliasing", "Screen anti aliasing");
	AddEnum ("QualitySetting", "antiAliasing", 0, "Disabled");
	AddEnum ("QualitySetting", "antiAliasing", 2, "2x Multi Sampling");
	AddEnum ("QualitySetting", "antiAliasing", 4, "4x Multi Sampling");
	AddEnum ("QualitySetting", "antiAliasing", 8, "8x Multi Sampling");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("QualitySetting", "pixelLightCount", "Number of pixel lights to use.");
	AddDocumentation ("QualitySetting", "softParticles", "Use soft blending for particles?");
	AddDocumentation ("QualitySetting", "softVegetation", "Use soft shading for terrain vegetation?");
	AddDocumentation ("QualitySetting", "textureQuality", "Base texture level");
	AddEnum ("QualitySetting", "textureQuality", 0, "Full Res");
	AddEnum ("QualitySetting", "textureQuality", 1, "Half Res");
	AddEnum ("QualitySetting", "textureQuality", 2, "Quarter Res");
	AddEnum ("QualitySetting", "textureQuality", 3, "Eighth Res");

	// Note: all this is auto-generated, see at top of file

	/* Struct: SceneCullingParameters */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("SceneCullingParameters", "sceneVisbilityForShadowCulling", "This stores the visibility of previous culling operations.");

	/* Struct: SceneNode */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("SceneNode", "disable", ": Maybe we can use Renderer* = NULL instead, we already set this to null for static objects...");

	/* Struct: ShadowSettings */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("ShadowSettings", "m_Type", "Shadow cast options");
	AddEnum ("ShadowSettings", "m_Type", 0, "No Shadows");
	AddEnum ("ShadowSettings", "m_Type", 1, "Hard Shadows");
	AddEnum ("ShadowSettings", "m_Type", 2, "Soft Shadows");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("ShadowSettings", "m_Resolution", "Shadow resolution");
	AddEnum ("ShadowSettings", "m_Resolution", -1, "Use Quality Settings");
	AddEnum ("ShadowSettings", "m_Resolution", 0, "Low Resolution");
	AddEnum ("ShadowSettings", "m_Resolution", 1, "Medium Resolution");
	AddEnum ("ShadowSettings", "m_Resolution", 2, "High Resolution");
	AddEnum ("ShadowSettings", "m_Resolution", 3, "Very High Resolution");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("ShadowSettings", "m_Softness", "Shadow softness [ 1.0, 8.0 ].");
	AddRangedValue ("ShadowSettings", "m_Softness", make_pair<float, float>(1.0f, 8.0f));
	AddDocumentation ("ShadowSettings", "m_SoftnessFade", "Shadow softness fadeout [ 0.1, 5.0 ].");
	AddRangedValue ("ShadowSettings", "m_SoftnessFade", make_pair<float, float>(0.1f, 5.0f));
	AddDocumentation ("ShadowSettings", "m_Strength", "Shadow intensity [ 0.0, 1.0 ].");
	AddRangedValue ("ShadowSettings", "m_Strength", make_pair<float, float>(0.0f, 1.0f));
	AddDocumentation ("ShadowSettings", "m_Bias", "Bias for shadows [ 0.0, 10.0 ].");
	AddRangedValue ("ShadowSettings", "m_Bias", make_pair<float, float>(0.0f, 10.0f));

	/* Struct: SoftJointLimit */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("SoftJointLimit", "spring", "If greater than zero, the limit is soft. The spring will pull the joint back. { 0, infinity }.");
	AddDocumentation ("SoftJointLimit", "bounciness", "When the joint hits the limit. This will determine how bouncy it will be. { 0, 1 }.");
	AddDocumentation ("SoftJointLimit", "damper", "If spring is greater than zero, the limit is soft. This is the damping of spring. { 0, infinity }.");

	/* Struct: TextureSettings */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("TextureSettings", "m_WrapMode", "Texture wrapping mode.");
	AddEnum ("TextureSettings", "m_WrapMode", 0, "Repeat");
	AddEnum ("TextureSettings", "m_WrapMode", 1, "Clamp");

	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("TextureSettings", "m_MipBias", "Bias used for LOD-selection (0 = none).");
	AddDocumentation ("TextureSettings", "m_Aniso", "Anisotropy factor (1 = None, 0 = Always disabled).");

	/* Struct: ThreadedAwakeData */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("ThreadedAwakeData", "completedThreadAwake", "refactor to safeLoaded");

	/* Struct: VAOCacheKeyGLES30 */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("VAOCacheKeyGLES30", "bufferIndices", "4 indices with 8 bits each");

	/* Struct: VertexArrayInfoGLES30 */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("VertexArrayInfoGLES30", "enabledArrays", "Bitmask of enabled arrays.");

	/* Struct: VertexInputInfoGLES30 */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("VertexInputInfoGLES30", "stride", "Attribute stride.");
	AddDocumentation ("VertexInputInfoGLES30", "numComponents", "Number of components.");
	AddDocumentation ("VertexInputInfoGLES30", "pointer", "Pointer or offset.");
	AddDocumentation ("VertexInputInfoGLES30", "componentType", "Component type - of type VertexChannelFormat.");

	/* Struct: WheelFrictionCurve */
	// Note: all this is auto-generated, see at top of file
	AddDocumentation ("WheelFrictionCurve", "extremumValue", "Extremum Value. [ 0.001, infinity  ].");
	AddRangedValue ("WheelFrictionCurve", "extremumValue", make_pair<float, float>(0.001f, numeric_limits<float>::infinity ()));
	AddDocumentation ("WheelFrictionCurve", "asymptoteSlip", "Asymptote Slip. [ 0.001, infinity  ].");
	AddRangedValue ("WheelFrictionCurve", "asymptoteSlip", make_pair<float, float>(0.001f, numeric_limits<float>::infinity ()));
	AddDocumentation ("WheelFrictionCurve", "extremumSlip", "Extremum Slip. [ 0.001, infinity  ].");
	AddRangedValue ("WheelFrictionCurve", "extremumSlip", make_pair<float, float>(0.001f, numeric_limits<float>::infinity ()));
	AddDocumentation ("WheelFrictionCurve", "asymptoteValue", "Asymptote Value. [ 0.001, infinity  ].");
	AddRangedValue ("WheelFrictionCurve", "asymptoteValue", make_pair<float, float>(0.001f, numeric_limits<float>::infinity ()));
	AddDocumentation ("WheelFrictionCurve", "stiffnessFactor", "Stiffness Factor. [ 0, infinity  ].");
	AddRangedValue ("WheelFrictionCurve", "stiffnessFactor", make_pair<float, float>(0.0f, numeric_limits<float>::infinity ()));

	// ---- Generated Code End Marker
}
