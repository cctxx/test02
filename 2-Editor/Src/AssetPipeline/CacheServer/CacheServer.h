#ifndef CACHE_SERVER_H
#define CACHE_SERVER_H

#include "../AssetDatabaseStructs.h"
#include "Runtime/Serialize/SerializationMetaFlags.h"
#include "Runtime/Threads/Mutex.h"
#include <deque>

enum { kCacheServerDataLayoutVersion = 1 };

struct AssetImporterSelection;
struct AssetImportingTimerStats;
class AssetImporter;

struct CacheServerAssetInfo
{
	LibraryRepresentation                       mainRepresentation;
	std::vector<LibraryRepresentation>          representations;
	AssetLabels                                 labels;
	SInt32                                      assetImporterClassID;
	std::vector<pair<UnityGUID, UnityStr> >  externalReferencesForValidation;
	
	DECLARE_SERIALIZE (CacheServerAssetInfo)
};

struct CacheServerData
{
	std::string metaDataPath;
	std::string assetInfoData;
	UInt64      downloadSize;
	
	CacheServerData () { downloadSize = 0; }
};

struct CachedAssetRequest
{
	// Input provided from outside
	UnityStr			assetPath;
	UnityGUID           guid;
	int                 importerClassID;
	bool				sentDownloadRequest;
	MdFour              hash;

	// Output generated by download process
	CacheServerData     downloadedData;

	CachedAssetRequest (const UnityGUID& g, const std::string& inPath, int inImporterClass, const MdFour& inHash) 
		: guid(g), 
		assetPath (inPath), 
		importerClassID(inImporterClass), 
		hash(inHash),
		sentDownloadRequest(false) { }
};

class CacheServer
{
public:
	
	bool CommitToCacheServer (const Asset& asset, AssetImporter& importer, const UnityGUID& selfGUID, const std::string& assetPath, const AssetImporterSelection& importerSelection);
	bool LoadFromCacheServer (Asset& asset, const UnityGUID& selfGUID, const std::string& assetPath, const AssetImporterSelection& importerSelection, int options);
	
	void DownloadCachedAssets (const CachedAssetRequest* requests, size_t requestSize, AssetImportingTimerStats* stats);
	void ClearCachedAssetRequests ();
	
	CachedAssetRequest* GetCompletedRequest (const UnityGUID& guid);
	
private:

	CachedAssetRequest* PopDownloadRequest ();
	void SendPendingDownloadRequests ();


	void ProcessDownloadRequests ();
	void UpdateProgress (int idx);

	static void* ProcessHashRequestsThreadLoop (void* userData);

	std::vector<CachedAssetRequest>  m_AllRequests;
	std::deque<CachedAssetRequest*>  m_DownloadRequests;
	std::map<UnityGUID, CachedAssetRequest*> m_Completed;
	
	AssetImportingTimerStats*        m_TimerStats;
};

CacheServer& GetCacheServer ();

#endif