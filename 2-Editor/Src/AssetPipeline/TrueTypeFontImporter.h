#ifndef TRUETYPEFONTIMPORTER_H
#define TRUETYPEFONTIMPORTER_H

#include "AssetImporter.h"
#include "ImportMesh.h"
#include <vector>
#include <iostream>
#include <string>
#include "Runtime/Math/Color.h"
#include "Runtime/Filters/Misc/Font.h"
#include "Runtime/Misc/UTF8.h"
#include "External/freetype2/include/ft2build.h"
#include FT_FREETYPE_H
#include FT_GLYPH_H
#include "Runtime/Mono/MonoScript.h"

class Texture2D;
class ImageReference;

class TrueTypeFontImporter : public AssetImporter {
  public:
	
	REGISTER_DERIVED_CLASS (TrueTypeFontImporter, AssetImporter)
	DECLARE_OBJECT_SERIALIZE (TrueTypeFontImporter)

	TrueTypeFontImporter (MemLabelId label, ObjectCreationMode mode);
	// ~TrueTypeFontImporter (); declared-by-macro
	virtual void GenerateAssetData ();
	static void InitializeClass ();
	static void CleanupClass () {}
	
	int GetFontSize() const { return m_FontSize; }
	void SetFontSize(int size) { m_FontSize =  std::min(500, std::max(1, size)); SetDirty(); }

	GET_SET_COMPARE_DIRTY (int, ForceTextureCase, m_ForceTextureCase);
	GET_SET_COMPARE_DIRTY (bool, IncludeFontData, m_IncludeFontData);
	GET_SET_COMPARE_DIRTY (bool, Use2xBehaviour, m_Use2xBehaviour);
	GET_SET_COMPARE_DIRTY (int, CharacterSpacing, m_CharacterSpacing);
	GET_SET_COMPARE_DIRTY (int, CharacterPadding, m_CharacterPadding);
	GET_SET_COMPARE_DIRTY (std::string, CustomCharacters, m_CustomCharacters);
	GET_SET_COMPARE_DIRTY (int, FontRenderingMode, m_FontRenderingMode);

	FontNames& GetFontNames() { return m_FontNames; }

	std::string GetFontNameFromTTFData ();

	bool IsFormatSupported();

	PPtr<Font> GenerateEditableFont (string path);

	/// Does the audio need to be reimported for the targetPlatform or is it already in the right format
	static bool DoesAssetNeedReimport (const string& assetPath, BuildTargetPlatform targetPlatform, bool unload);	

	static void GetFallbackFontReferences (Font *font);

private:
	typedef UNITY_VECTOR (kMemFont, char) FontData;

	static bool ReadFontDataFromFile(const std::string& path, FontData &fontData);
	static int OpenFreeTypeFace (const std::string& path, FT_Face& outFace, FontData& fontData);

	bool AllocateTexture(Texture2D& texture, FT_Face face, const dynamic_array<UnicodeChar>& chars, int& imageWidth, int& imageHeight, int& lineHeight, int margin);
	void RenderCharsToTexture(ImageReference& texture, FT_Face face, Font& font, const dynamic_array<UnicodeChar>& chars, int imageWidth, int imageHeight, int lineHeight, int margin);
  	void SetupKerningValues(FT_Face face, Font& font, const dynamic_array<UnicodeChar>& chars);

	void GenerateFont (Font &font, dynamic_array<UnicodeChar> &chars, Texture2D &texture, bool includeFontData);

	float GetCharacterAscent(FT_Face face, UnicodeChar ch);
	float GetAscent(FT_Face face, const dynamic_array<UnicodeChar>& chars);

	static bool LoadFontLibrary();
	static std::string GetFontNameFromTTFData (std::string path);

	// Import settings
	int                                m_FontSize;
	int                                m_ForceTextureCase;
	int                                m_CharacterSpacing;
	int                                m_CharacterPadding;
	UNITY_VECTOR(kMemFont,UnityStr)    m_FontNames;
	bool                               m_IncludeFontData;
	UnityStr                           m_CustomCharacters;
	bool                               m_Use2xBehaviour;
	int								   m_FontRenderingMode;
	
	// Data generated by import process

	struct Output
	{
		DECLARE_SERIALIZE(Output)

		bool  hasEmptyFontData;
	};
	
	Output                             m_Output;

	static FT_Library ms_FTLibrary;
};

#endif
