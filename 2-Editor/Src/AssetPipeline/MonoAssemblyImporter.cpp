#include "UnityPrefix.h"
#include "MonoAssemblyImporter.h"
#include "MonoCompilationPipeline.h"
#include "Runtime/Serialize/TransferFunctions/SerializeTransfer.h"
#include "Runtime/Serialize/TransferFunctions/TransferNameConversions.h"
#include "Runtime/Utilities/PathNameUtility.h"
#include "Runtime/Utilities/File.h"
#include "Runtime/Mono/MonoManager.h"
#include "Runtime/Graphics/Image.h"
#include "Editor/Src/Utility/ObjectImages.h"
#include "Runtime/Mono/MonoScript.h"
#include "Runtime/Utilities/FileUtilities.h"
#include "MonoImporter.h"
#include "Runtime/Scripting/ScriptingUtility.h"
#include "Editor/Src/Application.h"
#include "Editor/Mono/MonoEditorUtility.h"
#include "DefaultImporter.h"
#include "AssetInterface.h"
#include "Runtime/Graphics/Texture2D.h"
#include "AssetDatabase.h"

IMPLEMENT_CLASS_HAS_INIT (MonoAssemblyImporter)
IMPLEMENT_OBJECT_SERIALIZE (MonoAssemblyImporter)

// Increasing the version number causes an automatic reimport when the last imported version is a different.
// Only increase this number if an older version of the importer generated bad data or the importer applies data optimizations that can only be done in the importer.
// Usually when adding a new feature to the importer, there is no need to increase the number since the feature should probably not auto-enable itself on old import settings.
enum { kMonoAssemblyImporterVersion = 2 };

template<class T>
void MonoAssemblyImporter::Transfer (T& transfer)
{
	Super::Transfer(transfer);

	transfer.SetVersion (1);

	TRANSFER(m_IconMap);
	
	TRANSFER (m_ExecutionOrder);

	PostTransfer (transfer);
}

MonoAssemblyImporter::MonoAssemblyImporter (MemLabelId label, ObjectCreationMode mode)
:	Super(label, mode)
{}

MonoAssemblyImporter::~MonoAssemblyImporter ()
{}

int MonoAssemblyImporter::CanLoadPathName (const string& pathName, int* queue)
{
	/// The Monoimporter uses the queue to determine if it is the last script in the refresh queue.
	/// Thus this queue should be unique
	/// We compile scripts first so that when downloading from maint we don't lose properties because when loading a prefab
	/// the script variables might not be available in the script yet!
	*queue = -999998;

	string ext = GetPathNameExtension (pathName);

	// Also support .NET dll importing
	if (!StrICmp(ext, "dll") && DetectDotNetDll (pathName))
		return kCopyAsset;
	else
		return 0;
}

void MonoAssemblyImporter::InitializeClass ()
{ 
	RegisterCanLoadPathNameCallback (CanLoadPathName, ClassID (MonoAssemblyImporter), kMonoAssemblyImporterVersion);
	RegisterAllowNameConversion("MonoAssemblyImporter", "icons", "m_IconMap");
}

void MonoAssemblyImporter::Reset ()
{
	Super::Reset ();
	m_ExecutionOrder.clear();
	m_IconMap.clear();
}


void MonoAssemblyImporter::GenerateAssetData ()
{
	// Make sure there is always a default importer to represent the asset
	{
		DefaultAsset* tmp = RecycleExistingAssetObjectHashBased<DefaultAsset>("");
		tmp->AwakeFromLoad(kDefaultAwakeFromLoad);
	}

	// Read the dll data
	bool isEditorDll = IsEditorOnlyScriptDllPath(GetAssetPathName());
	string dllName = GetLastPathNameComponent(GetAssetPathName());
	
	// Reject the assembly if it looks like one of our
	// own deployed ones.
	if (IsBlacklistedDllName (dllName))
	{
		LogImportError ("Assembly DLL name is reserved for internal use: " + GetAssetPathName() + " (did files generated by a build accidentally end up in your Assets/ folder?)");
		return;
	}

	////@TODO: This uses the ReflectionAssembly space, and doesn't unload the. Fix it.
	MonoArray* names = NULL;
	MonoArray* nameSpaces = NULL;
	
	void* params[] = { 
			MonoStringNew(GetAssetPathName()),
			&names,
			&nameSpaces };
	
	CallStaticMonoMethod("AssemblyHelper", "ExtractAllClassesThatInheritMonoBehaviourAndScriptableObject", params);
	
	for (int i=0;i<mono_array_length_safe(names);i++)
	{
		string name = MonoStringToCpp(GetMonoArrayElement<MonoString*>(names, i));
		string nameSpace = MonoStringToCpp(GetMonoArrayElement<MonoString*>(nameSpaces, i));
		if (!name.empty())
		{
			CreateMonoScriptForClass (dllName, name, nameSpace, isEditorDll);
		}
	}
	
	// Register dll with mono manager
	SetupCustomDll(dllName, GetAssetPathName());
	
	// Recompile scripts
	DirtyAllScriptCompilers();
	
	bool startCompilation = !(GetImportFlags() & kNextImportHasSamePriority);
	if (startCompilation)
	{
		ForceRecompileAllScriptsAndDlls(GetImportFlags());
	}
}

void MonoAssemblyImporter::CreateMonoScriptForClass(const std::string& assemblyName, const std::string& className, const std::string& nameSpace, bool isEditorDll)
{
	string fullName = nameSpace;
	if (fullName.empty())
		fullName = className;
	else
		fullName += className;

	MonoScript* script = RecycleExistingAssetObjectHashBased<MonoScript>(fullName);
	if (script)
	{
		///@TODO: MAKE CUSTOM ICON
		Image image = GetImageNamed("TextAsset Icon");
		SetThumbnail (image, script->GetInstanceID ());
		
		script->SetName(className.c_str());
		script->Init ("", className, nameSpace, assemblyName, isEditorDll);
		
		// Apply execution order
		ExecutionOrder::iterator found = m_ExecutionOrder.find(script->GetScriptFullClassName());
		if (found != m_ExecutionOrder.end())
			script->SetExecutionOrder(found->second);

		// Apply user icon
		IconMap::iterator it = m_IconMap.find(script->GetScriptFullClassName());
		if (it != m_IconMap.end())
			script->SetIcon(PPtr<Object> (it->second.GetInstanceID()));

		#if !UNITY_RELEASE
		// Mono assemblies will be build async w/o linkning back to scripts, so we can't simply delay check
		// that's why we skip checking 
		//   actually AwakeFromLoad will be called, and if smth goes wrong - we'll see  that from the first test that uses prefabs
		script->HackSetAwakeWasCalled();
		#endif

		if (isEditorDll)
			GetMonoScriptManager().RegisterEditorScript(*script);
		else
			GetMonoScriptManager().RegisterRuntimeScript(*script);
	}
	else
	{
		LogImportWarning(fullName + " could not be generated because of a hash conflict. Please choose a different name for the class if you need it to be accessible in the editor.");
	}
}

void MonoAssemblyImporter::SetExecutionOrder (const std::string& className, int executionOrder)
{
	if (executionOrder == 0)
		m_ExecutionOrder.erase(className);
	else
		m_ExecutionOrder[className] = executionOrder;

	SetDirty();
}

void MonoAssemblyImporter::SetIcon (const std::string& className, PPtr<Texture2D> icon)
{
	if (icon.IsNull())
		m_IconMap.erase(className);
	else
		m_IconMap[className] = icon;

	SetDirty();
}

void SetMonoScriptExecutionOrder (MonoScript& monoScript, int executionOrder)
{
	MonoImporter* monoImporter = dynamic_pptr_cast<MonoImporter*> (FindAssetImporterForObject (monoScript.GetInstanceID()));
	if (monoImporter)
	{
		monoImporter->SetExecutionOrder (executionOrder);
		AssetInterface::Get().ImportAtPath(monoImporter->GetAssetPathName());
	}
	
	MonoAssemblyImporter* monoAssemblyImporter = dynamic_pptr_cast<MonoAssemblyImporter*> (FindAssetImporterForObject (monoScript.GetInstanceID()));
	if (monoAssemblyImporter)
	{
		monoAssemblyImporter->SetExecutionOrder (monoScript.GetScriptFullClassName(), executionOrder);
		AssetInterface::Get().ImportAtPath(monoAssemblyImporter->GetAssetPathName());
	}
}

void MonoAssemblyImporter::UnloadObjectsAfterImport (UnityGUID guid)
{
	// Intentially left blank.
	// MonoScripts are never unloaded and always kept in memory.
}

void CopyMonoScriptIconToImporters (MonoScript& monoScript)
{
	PPtr<Object> icon = monoScript.GetIcon ();

	MonoImporter* monoImporter = dynamic_pptr_cast<MonoImporter*> (FindAssetImporterForObject (monoScript.GetInstanceID()));
	if (monoImporter)
	{
		monoImporter->SetIcon (PPtr<Texture2D> (icon.GetInstanceID()));
		AssetInterface::Get().ImportAtPath(monoImporter->GetAssetPathName());
	}
	
	MonoAssemblyImporter* monoAssemblyImporter = dynamic_pptr_cast<MonoAssemblyImporter*> (FindAssetImporterForObject (monoScript.GetInstanceID()));
	if (monoAssemblyImporter)
	{
		monoAssemblyImporter->SetIcon (monoScript.GetScriptFullClassName(), PPtr<Texture2D> (icon.GetInstanceID()));
		AssetInterface::Get().ImportAtPath(monoAssemblyImporter->GetAssetPathName());
	}
}

