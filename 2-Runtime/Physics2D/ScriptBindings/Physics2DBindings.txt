C++RAW
#include "UnityPrefix.h"
#include "Configuration/UnityConfigure.h"
#include "Runtime/Scripting/ScriptingExportUtility.h"
#include "Runtime/Scripting/ScriptingUtility.h"
#include "Runtime/Scripting/ScriptingManager.h"

#include "Runtime/Physics2D/Physics2DManager.h"
#include "Runtime/Physics2D/Physics2DMaterial.h"
#include "Runtime/Physics2D/Physics2DSettings.h"
#include "Runtime/Physics2D/RigidBody2D.h"
#include "Runtime/Physics2D/PolygonCollider2D.h"
#include "Runtime/Physics2D/SpriteCollider2D.h"
#include "Runtime/Physics2D/CircleCollider2D.h"
#include "Runtime/Physics2D/BoxCollider2D.h"
#include "Runtime/Physics2D/EdgeCollider2D.h"

#include "Runtime/Physics2D/Joint2D.h"
#include "Runtime/Physics2D/SpringJoint2D.h"
#include "Runtime/Physics2D/DistanceJoint2D.h"
#include "Runtime/Physics2D/HingeJoint2D.h"
#include "Runtime/Physics2D/SliderJoint2D.h"

#include "Runtime/Geometry/Ray.h"
#include "Runtime/Graphics/SpriteFrame.h"
#include "Runtime/Graphics/Polygon2D.h"
#include "Runtime/Misc/GameObjectUtility.h"

CSRAW

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace UnityEngine
{


CONDITIONAL ENABLE_2D_PHYSICS
NONSEALED_CLASS Physics2D
	CSRAW public const int IgnoreRaycastLayer = 1 << 2;
	CSRAW public const int DefaultRaycastLayers = ~IgnoreRaycastLayer;
	CSRAW public const int AllLayers = ~0;


	// --------------------------------------------------------------------------


	THREAD_SAFE
	CUSTOM_PROP static int velocityIterations { return GetPhysics2DSettings().GetVelocityIterations (); } { SCRIPTINGAPI_THREAD_CHECK(SetVelocityIterations) return GetPhysics2DSettings().SetVelocityIterations (value); }	
	CUSTOM_PROP static int positionIterations { return GetPhysics2DSettings().GetPositionIterations (); } { SCRIPTINGAPI_THREAD_CHECK(SetPositionIterations) return GetPhysics2DSettings().SetPositionIterations (value); }	
	CUSTOM_PROP static Vector2 gravity { return GetPhysics2DSettings().GetGravity (); } { SCRIPTINGAPI_THREAD_CHECK(set_gravity) return GetPhysics2DSettings().SetGravity (value); }	
	CUSTOM_PROP static bool raycastsHitTriggers { return GetPhysics2DSettings().GetRaycastsHitTriggers (); } { SCRIPTINGAPI_THREAD_CHECK(SetRaycastsHitTriggers) return GetPhysics2DSettings().SetRaycastsHitTriggers (value); }	


	// --------------------------------------------------------------------------


	CUSTOM static public void IgnoreLayerCollision (int layer1, int layer2, bool ignore = true)
	{
		GetPhysics2DSettings().IgnoreCollision(layer1, layer2, ignore);
	}

	CUSTOM static public bool GetIgnoreLayerCollision (int layer1, int layer2)
	{
		return GetPhysics2DSettings().GetIgnoreCollision(layer1, layer2);
	}


	// --------------------------------------------------------------------------


	C++RAW

	// Create a managed array of native ray-cast hits.
	static ScriptingArrayPtr CreateManagedRaycastArrayFromNative (RaycastHit2D* nativeHits, size_t size)
	{
		// Return an empty array if no hits.
		if (size == 0)
			return CreateEmptyStructArray (MONO_COMMON.raycastHit2D);

		// Generate scripting array.
		ScriptingArrayPtr scriptArray = CreateScriptingArray<RaycastHit2D> (MONO_COMMON.raycastHit2D, size);

		// Transfer elements.
		RaycastHit2D* scriptHit = Scripting::GetScriptingArrayStart<RaycastHit2D> (scriptArray);
		for (size_t i = 0; i < size; ++i, ++scriptHit, ++nativeHits)
		{
			// Transfer members.
			scriptHit->point = nativeHits->point;
			scriptHit->normal = nativeHits->normal;
			scriptHit->fraction = nativeHits->fraction;
			scriptHit->collider = reinterpret_cast<Collider2D*>(ScriptingGetObjectReference (nativeHits->collider));
		}
		return scriptArray;
	}

	CSRAW


	// --------------------------------------------------------------------------


	CUSTOM private static void Internal_Linecast (Vector2 start, Vector2 end, int layerMask, float minDepth, float maxDepth, out RaycastHit2D raycastHit)
	{
		if (GetPhysics2DManager ().Linecast (start, end, layerMask, minDepth, maxDepth, raycastHit, 1) == 1)
			raycastHit->collider = reinterpret_cast<Collider2D*>(ScriptingGetObjectReference (raycastHit->collider));
	}

	// Returns the first hit along the specified line.
	CSRAW public static RaycastHit2D Linecast (Vector2 start, Vector2 end, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity)
	{
		RaycastHit2D raycastHit;
		Internal_Linecast (start, end, layerMask, minDepth, maxDepth, out raycastHit);
		return raycastHit;
	}

	// Returns all hits along the specified line.
	CUSTOM public static RaycastHit2D[] LinecastAll (Vector2 start, Vector2 end, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity)
	{
		dynamic_array<RaycastHit2D> raycastHits(kMemTempAlloc);
		if (GetPhysics2DManager ().LinecastAll (start, end, layerMask, minDepth, maxDepth, &raycastHits) == 0)
			return CreateEmptyStructArray (MONO_COMMON.raycastHit2D);

		return CreateManagedRaycastArrayFromNative (raycastHits.data (), raycastHits.size ());
	}

	// Returns all hits along the line (limited by the size of the array).  This does not produce any garbage.
	CUSTOM public static int LinecastNonAlloc (Vector2 start, Vector2 end, RaycastHit2D[] results, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity)
	{
		RaycastHit2D* raycastHits = Scripting::GetScriptingArrayStart<RaycastHit2D>(results);
		const int resultCount = GetPhysics2DManager ().Linecast (start, end, layerMask, minDepth, maxDepth, raycastHits, GetScriptingArraySize(results));

		for (size_t i = 0; i < resultCount; ++i, ++raycastHits)
			raycastHits->collider = reinterpret_cast<Collider2D*>(ScriptingGetObjectReference (raycastHits->collider));

		return resultCount;
	}

	CUSTOM private static void Internal_Raycast (Vector2 origin, Vector2 direction, float distance, int layerMask, float minDepth, float maxDepth, out RaycastHit2D raycastHit)
	{
		if (GetPhysics2DManager ().Raycast (origin, direction, distance, layerMask, minDepth, maxDepth, raycastHit, 1) == 1)
			raycastHit->collider = reinterpret_cast<Collider2D*>(ScriptingGetObjectReference (raycastHit->collider));
	}

	// Returns the first hit along the ray.
	CSRAW public static RaycastHit2D Raycast (Vector2 origin, Vector2 direction, float distance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity)
	{
		RaycastHit2D raycastHit;
		Internal_Raycast (origin, direction, distance, layerMask, minDepth, maxDepth, out raycastHit);
		return raycastHit;
	}

	// Returns all hits along the ray.
	CUSTOM public static RaycastHit2D[] RaycastAll (Vector2 origin, Vector2 direction, float distance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity)
	{
		dynamic_array<RaycastHit2D> raycastHits(kMemTempAlloc);
		if (GetPhysics2DManager ().RaycastAll (origin, direction, distance, layerMask, minDepth, maxDepth, &raycastHits) == 0)
			return CreateEmptyStructArray(MONO_COMMON.raycastHit2D);

		return CreateManagedRaycastArrayFromNative (raycastHits.data (), raycastHits.size ());
	}

	// Returns all hits along the ray (limited by the size of the array).  This does not produce any garbage.
	CUSTOM public static int RaycastNonAlloc (Vector2 origin, Vector2 direction, RaycastHit2D[] results, float distance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity)
	{
		RaycastHit2D* raycastHits = Scripting::GetScriptingArrayStart<RaycastHit2D>(results);
		const int resultCount = GetPhysics2DManager ().Raycast (origin, direction, distance, layerMask, minDepth, maxDepth, raycastHits, GetScriptingArraySize(results));

		for (size_t i = 0; i < resultCount; ++i, ++raycastHits)
			raycastHits->collider = reinterpret_cast<Collider2D*>(ScriptingGetObjectReference (raycastHits->collider));

		return resultCount;
	}


	// --------------------------------------------------------------------------


	CUSTOM private static void Internal_GetRayIntersection (Ray ray, float distance, int layerMask, out RaycastHit2D raycastHit)
	{
		if (GetPhysics2DManager ().GetRayIntersection (ray.GetOrigin (), ray.GetDirection (), distance, layerMask, raycastHit, 1) == 1)
			raycastHit->collider = reinterpret_cast<Collider2D*>(ScriptingGetObjectReference (raycastHit->collider));
	}

	// Returns the first hit intersecting the 3D ray.
	CSRAW public static RaycastHit2D GetRayIntersection (Ray ray, float distance = Mathf.Infinity, int layerMask = DefaultRaycastLayers)
	{
		RaycastHit2D raycastHit;
		Internal_GetRayIntersection (ray, distance, layerMask, out raycastHit);
		return raycastHit;
	}
	 
	// Returns all hits intersecting the 3D ray.
	CUSTOM public static RaycastHit2D[] GetRayIntersectionAll (Ray ray, float distance = Mathf.Infinity, int layerMask = DefaultRaycastLayers)
	{
		dynamic_array<RaycastHit2D> raycastHits(kMemTempAlloc);
		if (GetPhysics2DManager ().GetRayIntersectionAll (ray.GetOrigin (), ray.GetDirection (), distance, layerMask, &raycastHits) == 0)
			return CreateEmptyStructArray(MONO_COMMON.raycastHit2D);

		return CreateManagedRaycastArrayFromNative (raycastHits.data (), raycastHits.size ());
	}	

	// Returns all hits intersecting the 3D ray (limited by the size of the array).  This does not produce any garbage.
	CUSTOM public static int GetRayIntersectionNonAlloc (Ray ray, RaycastHit2D[] results, float distance = Mathf.Infinity, int layerMask = DefaultRaycastLayers)
	{
		RaycastHit2D* raycastHits = Scripting::GetScriptingArrayStart<RaycastHit2D>(results);
		const int resultCount = GetPhysics2DManager ().GetRayIntersection (ray.GetOrigin (), ray.GetDirection (), distance, layerMask, raycastHits, GetScriptingArraySize(results));

		for (size_t i = 0; i < resultCount; ++i, ++raycastHits)
			raycastHits->collider = reinterpret_cast<Collider2D*>(ScriptingGetObjectReference (raycastHits->collider));

		return resultCount;
	}	


	// --------------------------------------------------------------------------


	// Returns a collider overlapping the point.
	CUSTOM public static Collider2D OverlapPoint (Vector2 point, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity)
	{
		Collider2D* collider;
		const int resultCount = GetPhysics2DManager ().OverlapPoint (point, layerMask, minDepth, maxDepth, &collider, 1);

		if (resultCount == 0)
			return SCRIPTING_NULL;

		return Scripting::ScriptingWrapperFor (collider);
	}

	// Returns all colliders overlapping the point.
	CUSTOM public static Collider2D[] OverlapPointAll (Vector2 point, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity)
	{
		dynamic_array<Collider2D*> colliderHits(kMemTempAlloc);
		GetPhysics2DManager ().OverlapPointAll (point, layerMask, minDepth, maxDepth, &colliderHits);

		// Generate scripting array.
		return CreateScriptingArrayFromUnityObjects(colliderHits, ScriptingClassFor(Collider2D));
	}

	// Returns all colliders overlapping the point (limited by the size of the array).  This does not produce any garbage.
	CUSTOM public static int OverlapPointNonAlloc (Vector2 point, Collider2D[] results, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity)
	{
		Collider2D** colliderHits = Scripting::GetScriptingArrayStart<Collider2D*>(results);
		const int resultCount = GetPhysics2DManager ().OverlapPoint (point, layerMask, minDepth, maxDepth, colliderHits, GetScriptingArraySize(results));

		for (size_t i = 0; i < resultCount; ++i)
			colliderHits[i] = reinterpret_cast<Collider2D*>(ScriptingGetObjectReference (colliderHits[i]));

		return resultCount;
	}

	// Returns a collider overlapping the circle.
	CUSTOM public static Collider2D OverlapCircle (Vector2 point, float radius, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity)
	{
		Collider2D* collider;
		const int resultCount = GetPhysics2DManager ().OverlapCircle (point, radius, layerMask, minDepth, maxDepth, &collider, 1);

		if (resultCount == 0)
			return SCRIPTING_NULL;

		return Scripting::ScriptingWrapperFor (collider);
	}

	// Returns all colliders overlapping the circle.
	CUSTOM public static Collider2D[] OverlapCircleAll (Vector2 point, float radius, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity)
	{
		dynamic_array<Collider2D*> colliderHits(kMemTempAlloc);
		GetPhysics2DManager ().OverlapCircleAll (point, radius, layerMask, minDepth, maxDepth, &colliderHits);

		// Generate scripting array.
		return CreateScriptingArrayFromUnityObjects(colliderHits, ScriptingClassFor(Collider2D));
	}

	// Returns all colliders overlapping the circle (limited by the size of the array).  This does not produce any garbage.
	CUSTOM public static int OverlapCircleNonAlloc (Vector2 point, float radius, Collider2D[] results, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity)
	{
		Collider2D** colliderHits = Scripting::GetScriptingArrayStart<Collider2D*>(results);
		const int resultCount = GetPhysics2DManager ().OverlapCircle (point, radius, layerMask, minDepth, maxDepth, colliderHits, GetScriptingArraySize(results));

		for (size_t i = 0; i < resultCount; ++i)
			colliderHits[i] = reinterpret_cast<Collider2D*>(ScriptingGetObjectReference (colliderHits[i]));

		return resultCount;
	}

	// Returns a collider overlapping the area.
	CUSTOM public static Collider2D OverlapArea (Vector2 pointA, Vector2 pointB, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity)
	{
		Collider2D* collider;
		const int resultCount = GetPhysics2DManager ().OverlapArea (pointA, pointB, layerMask, minDepth, maxDepth, &collider, 1);

		if (resultCount == 0)
			return SCRIPTING_NULL;

		return Scripting::ScriptingWrapperFor (collider);
	}

	// Returns all colliders overlapping the area.
	CUSTOM public static Collider2D[] OverlapAreaAll (Vector2 pointA, Vector2 pointB, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity)
	{
		dynamic_array<Collider2D*> colliderHits(kMemTempAlloc);
		GetPhysics2DManager ().OverlapAreaAll (pointA, pointB, layerMask, minDepth, maxDepth, &colliderHits);

		// Generate scripting array.
		return CreateScriptingArrayFromUnityObjects(colliderHits, ScriptingClassFor(Collider2D));
	}

	// Returns all colliders overlapping the area (limited by the size of the array).  This does not produce any garbage.
	CUSTOM public static int OverlapAreaNonAlloc (Vector2 pointA, Vector2 pointB, Collider2D[] results, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity)
	{
		Collider2D** colliderHits = Scripting::GetScriptingArrayStart<Collider2D*>(results);
		const int resultCount = GetPhysics2DManager ().OverlapArea (pointA, pointB, layerMask, minDepth, maxDepth, colliderHits, GetScriptingArraySize(results));

		for (size_t i = 0; i < resultCount; ++i)
			colliderHits[i] = reinterpret_cast<Collider2D*>(ScriptingGetObjectReference (colliderHits[i]));

		return resultCount;
	}

END


// NOTE: must match memory layout of native RaycastHit2D
CONDITIONAL ENABLE_2D_PHYSICS
STRUCT RaycastHit2D
	CSRAW private Vector2 m_Point;
	CSRAW private Vector2 m_Normal;
	CSRAW private float m_Fraction;
	#if UNITY_WINRT
	CSRAW private int m_ColliderHandle;
	#else
	CSRAW private Collider2D m_Collider;
	#endif
	
	CSRAW public Vector2 point { get { return m_Point; } set { m_Point = value; } }
	CSRAW public Vector2 normal { get { return m_Normal; } set { m_Normal = value; } }
	CSRAW public float fraction { get { return m_Fraction; } set { m_Fraction = value; } }
	
	CONDITIONAL !UNITY_WINRT
	CSRAW public Collider2D collider { get { return m_Collider; }   }
	
	CONDITIONAL UNITY_WINRT
	CSRAW public Collider2D collider { get { return UnityEngineInternal.ScriptingUtils.GCHandleToObject<Collider2D>(m_ColliderHandle); } }

	CSRAW public Rigidbody2D rigidbody { get { return collider != null ? collider.attachedRigidbody : null; }  }
	
	CSRAW public Transform transform { get {
		Rigidbody2D body = rigidbody;
		if (body != null)
			return body.transform;
		else if (collider != null)
			return collider.transform;
		else
			return null;
	} }

	// Implicitly convert a hit to a boolean based upon whether a collider reference exists or not.
	CSRAW public static implicit operator bool (RaycastHit2D hit) { return hit.collider != null; }

	// Compare the hit by fraction along the ray.  If no colliders exist then fraction is moved "up".  This allows sorting an array of sparse results.
	CSRAW public int CompareTo(RaycastHit2D other) { if (collider == null) return 1; if (other.collider == null) return -1; return fraction.CompareTo(other.fraction); }
END


// [[Rigidbody2D]] interpolation mode.
ENUM RigidbodyInterpolation2D
	// No Interpolation.
	None = 0,
	
	// Interpolation will always lag a little bit behind but can be smoother than extrapolation.
	Interpolate = 1,

	// Extrapolation will predict the position of the rigidbody based on the current velocity.
	Extrapolate = 2
END


// [[Rigidbody2D]] sleeping mode.
ENUM RigidbodySleepMode2D
	// Never sleep.
	NeverSleep = 0,

	// Start the rigid body awake.
	StartAwake = 1,

	// Start the rigid body asleep.
	StartAsleep = 2
END


// [[Rigidbody2D]] collision detection mode.
ENUM CollisionDetectionMode2D
	// Provides standard (and least expensive) collision detection suitable for most circumstances.
	None = 0,
	
	// Provides the most accurate collision detection to present tunnelling but is more expensive.  Use for vert fast moving objects only.
	Continuous = 1
END


CONDITIONAL ENABLE_2D_PHYSICS
CLASS Rigidbody2D : Component
	// The linear velocity vector of the object.
	AUTO_PROP Vector2 velocity GetVelocity SetVelocity
	
	// The angular velocity vector of the object in degrees/sec.
	AUTO_PROP float angularVelocity GetAngularVelocity SetAngularVelocity

	// The (linear) drag of the object.
	AUTO_PROP float drag GetDrag SetDrag

	// The angular drag of the object.
	AUTO_PROP float angularDrag GetAngularDrag SetAngularDrag

	// Controls the effect of gravity on the object.
	AUTO_PROP float gravityScale GetGravityScale SetGravityScale

	// Controls whether the object is kinematic or dynamic.
	AUTO_PROP bool isKinematic GetIsKinematic SetIsKinematic

	// Controls whether the objects angle can be changed by collisions with other objects.
	AUTO_PROP bool fixedAngle IsFixedAngle SetFixedAngle

	// Checks whether the rigid body is sleeping or not.
	CUSTOM bool IsSleeping() { return self->IsSleeping(); }

	// Checks whether the rigid body is awake or not.
	CUSTOM bool IsAwake() { return !self->IsSleeping(); }

	// Sets the rigid body into a sleep state.
	CUSTOM void Sleep() { self->SetSleeping(true); }

	// Wakes the rigid from sleeping.
	CUSTOM void WakeUp() { self->SetSleeping(false); }

	// Interpolation allows you to smooth out the effect of running physics at a fixed rate.
	AUTO_PROP RigidbodyInterpolation2D interpolation GetInterpolation SetInterpolation

	// Controls how the object sleeps.
	AUTO_PROP RigidbodySleepMode2D sleepMode GetSleepMode SetSleepMode

	// The Rigidbody's collision detection mode.
	AUTO_PROP CollisionDetectionMode2D collisionDetectionMode GetCollisionDetectionMode SetCollisionDetectionMode

	// Controls the mass of the object by adjusting the density of all colliders attached to the object.
	AUTO_PROP float mass GetMass SetMass

	CUSTOM void AddForce (Vector2 force) { self->AddForce (force); }
	CUSTOM void AddTorque (float torque) { self->AddTorque (torque); }
	CUSTOM void AddForceAtPosition (Vector2 force, Vector2 position) { self->AddForceAtPosition (force, position); }
END


CONDITIONAL ENABLE_2D_PHYSICS
NONSEALED_CLASS Collider2D : Behaviour
	AUTO_PROP bool isTrigger GetIsTrigger SetIsTrigger
	AUTO_PTR_PROP Rigidbody2D attachedRigidbody GetRigidbody

    // Gets the number of shapes this collider has generated.
	AUTO_PROP int shapeCount GetShapeCount

	// Checks whether the specified point overlaps the collider or not.
	CUSTOM public bool OverlapPoint (Vector2 point) { return self->OverlapPoint(point); }

	// The shared physics material of this collider.
	CUSTOM_PROP PhysicsMaterial2D sharedMaterial { return Scripting::ScriptingWrapperFor (self->GetMaterial ()); } { self->SetMaterial (value); }

    // OnCollisionEnter2D is called when this [[Collider2D]] has begun touching another [[Collider2D]].
	CSNONE void OnCollisionEnter2D (Collision2D info);

    // OnCollisionStay2D is called once per frame for this [[Collider2D]] if it is continuing to touch another [[Collider2D]].
    CSNONE void OnCollisionStay2D (Collision2D info);

    // OnCollisionExit2D is called when this [[Collider2D]] has stopped touching another [[Collider2D]].
	CSNONE void OnCollisionExit2D (Collision2D info);

    // OnTriggerEnter2D is called when a [[Collider2D]] has begun touching another [[Collider2D]] configured as a trigger.
	CSNONE void OnTriggerEnter2D (Collider2D other);

    // OnTriggerStay2D is called once per frame for a [[Collider2D]] if it is continuing to touch another [[Collider2D]] configured as a trigger.
	CSNONE void OnTriggerStay2D (Collider2D other);

    // OnTriggerExit2D is called when a [[Collider2D]] has stopped touching another [[Collider2D]] configured as a trigger.
	CSNONE void OnTriggerExit2D (Collider2D other);

END


CONDITIONAL ENABLE_2D_PHYSICS
CLASS CircleCollider2D : Collider2D
	AUTO_PROP Vector2 center GetCenter SetCenter
	AUTO_PROP float radius GetRadius SetRadius
END


CONDITIONAL ENABLE_2D_PHYSICS
CLASS BoxCollider2D : Collider2D
	AUTO_PROP Vector2 center GetCenter SetCenter
	AUTO_PROP Vector2 size GetSize SetSize
END


CONDITIONAL ENABLE_2D_PHYSICS
CLASS EdgeCollider2D : Collider2D
	
	// Reset to a single horizontal edge.
	CUSTOM void Reset() { self->Reset (); }

	// Get the number of edges.  This is one less than the number of points.
	CUSTOM_PROP int edgeCount { { return self->GetEdgeCount (); } }

	// Get the number of points.  This cannot be less than two which will form a single edge.
	CUSTOM_PROP int pointCount { { return self->GetPointCount (); } }

	// Get or set the points defining multiple continuous edges.
	CUSTOM_PROP Vector2[] points
	{
		return CreateScriptingArrayStride<Vector2f>(self->GetPoints ().data (), self->GetPointCount (), MONO_COMMON.vector2, sizeof(Vector2f));
	}
	{		
		if (self->SetPoints (Scripting::GetScriptingArrayStart<Vector2f> (value), GetScriptingArraySize (value)))
			return;

		ErrorString("Invalid points assigned to 2D edge collider.");
	}

END


CONDITIONAL (ENABLE_2D_PHYSICS && ENABLE_SPRITECOLLIDER)
CLASS SpriteCollider2D : Collider2D

	CUSTOM_PROP Sprite sprite
	{
		return Scripting::ScriptingWrapperFor(self->GetSprite());
	}
	{
		self->SetSprite(value);
	}

END


CONDITIONAL ENABLE_2D_PHYSICS
CLASS PolygonCollider2D : Collider2D

	// Get/Set a single path of points.
	CUSTOM_PROP Vector2[] points
	{
		return CreateScriptingArrayStride<Vector2f>(self->GetPoly().GetPoints(), self->GetPoly().GetPointCount(), MONO_COMMON.vector2, sizeof(*self->GetPoly().GetPoints()));
	}
	{
		self->GetPoly().SetPoints(Scripting::GetScriptingArrayStart<Vector2f>(value), GetScriptingArraySize(value));
		self->RefreshPoly();
	}

	// Get the specified path of points.
	CUSTOM Vector2[] GetPath(int index)
	{
		if (index >= self->GetPoly().GetPathCount())
		{
			Scripting::RaiseOutOfRangeException("Path %d does not exist.", index);
			return SCRIPTING_NULL;
		}
				
		const Polygon2D::TPath& path = self->GetPoly().GetPath(index);
		return CreateScriptingArrayStride<Vector2f>(path.data(), path.size(), MONO_COMMON.vector2, sizeof(*path.data()));
	}

	// Set the specified path of points.
	CUSTOM void SetPath(int index, Vector2[] points)
	{
		const Vector2f* arrayStart = Scripting::GetScriptingArrayStart<Vector2f>(points);
		const int arraySize = GetScriptingArraySize(points);
		Polygon2D::TPath path;
		path.assign(arrayStart, arrayStart+arraySize);
		self->GetPoly().SetPath(index, path);
		self->RefreshPoly();
	}

	// Get the number of paths.
	CUSTOM_PROP int pathCount { return self->GetPoly().GetPathCount(); } { self->GetPoly().SetPathCount(value); self->RefreshPoly(); }

	// Get the total number of points in all paths.
	CUSTOM int GetTotalPointCount() { return self->GetPoly().GetTotalPointCount(); }

	// Create a primitive n-sided polygon.
	CUSTOM void CreatePrimitive(int sides, Vector2 scale = Vector2.one, Vector2 offset = Vector2.zero)
	{
		if (sides < 3)
		{
			ErrorString ("Cannot create a 2D polygon primitive collider with less than two sides.");
			return;
		}

		if (scale.x <= 0.0f || scale.y <= 0.0f)
		{
			ErrorString ("Cannot create a 2D polygon primitive collider with an axis scale less than or equal to zero.");
			return;
		}

		self->CreatePrimitive (sides, scale, offset);
	}

END

// Describes a contact point where the collision occurs.
CONDITIONAL ENABLE_2D_PHYSICS
STRUCT ContactPoint2D
	CSRAW internal Vector2  m_Point;
	CSRAW internal Vector2  m_Normal;
	CSRAW internal Collider2D m_Collider;
	CSRAW internal Collider2D m_OtherCollider;

	// The point of contact.
	CSRAW public Vector2 point  { get { return m_Point; } }

	// Normal of the contact point.
	CSRAW public Vector2 normal { get { return m_Normal; } }

	// The first collider in contact.
	CSRAW public Collider2D collider { get { return m_Collider; } }

	// The other collider in contact.
	CSRAW public Collider2D otherCollider { get { return m_OtherCollider; } }
END

CONDITIONAL ENABLE_2D_PHYSICS
CSRAW [StructLayout (LayoutKind.Sequential)]
NONSEALED_CLASS Collision2D
	CSRAW internal Rigidbody2D    m_Rigidbody;
	CSRAW internal Collider2D     m_Collider;
	CSRAW internal ContactPoint2D[] m_Contacts;
	CSRAW internal Vector2        m_RelativeVelocity;
	
	CSRAW public Rigidbody2D rigidbody { get { return m_Rigidbody; } }
	CSRAW public Collider2D collider { get { return m_Collider; } }
	CSRAW public Transform transform { get { return rigidbody != null ? rigidbody.transform : collider.transform; } }
	CSRAW public GameObject gameObject { get { return m_Rigidbody != null ? m_Rigidbody.gameObject : m_Collider.gameObject; } }
	CSRAW public ContactPoint2D[] contacts { get { return m_Contacts; } }
	CSRAW public Vector2 relativeVelocity { get { return m_RelativeVelocity; } }

END


// JointAngleLimits2D is used by the [[HingeJoint2D]] to limit the joints angle.
CONDITIONAL ENABLE_2D_PHYSICS
STRUCT JointAngleLimits2D
	CSRAW private float m_LowerAngle;
	CSRAW private float m_UpperAngle;
	
	// The lower angle limit of the joint.
	CSRAW public float min { get { return m_LowerAngle; } set { m_LowerAngle = value; } }

	// The upper angle limit of the joint.
	CSRAW public float max { get { return m_UpperAngle; } set { m_UpperAngle = value; } }
END


// JointTranslationLimits2D is used by the [[SliderJoint2D]] to limit the joints translation.
CONDITIONAL ENABLE_2D_PHYSICS
STRUCT JointTranslationLimits2D
	CSRAW private float m_LowerTranslation;
	CSRAW private float m_UpperTranslation;
	
	// The lower translation limit of the joint.
	CSRAW public float min { get { return m_LowerTranslation; } set { m_LowerTranslation = value; } }

	// The upper translation limit of the joint.
	CSRAW public float max { get { return m_UpperTranslation; } set { m_UpperTranslation = value; } }
END


// JointMotor2D is used by the [[HingeJoint2D]] and [[SliderJoint2D]] to motorize a joint.
CONDITIONAL ENABLE_2D_PHYSICS
STRUCT JointMotor2D
	CSRAW private float m_MotorSpeed;
	CSRAW private float m_MaximumMotorTorque;
	
	// The target motor speed in degrees/second.
	CSRAW public float motorSpeed { get { return m_MotorSpeed; } set { m_MotorSpeed = value; } }

	// The maximum torque in N-m the motor can use to achieve the desired motor speed.
	CSRAW public float maxMotorTorque { get { return m_MaximumMotorTorque; } set { m_MaximumMotorTorque = value; } }
END


// Joint2D is the base class for all 2D joints.
CONDITIONAL ENABLE_2D_PHYSICS
NONSEALED_CLASS Joint2D : Behaviour

	// A reference to another rigid-body this joint connects to.
	AUTO_PTR_PROP Rigidbody2D connectedBody GetConnectedBody SetConnectedBody

	// Whether the connected rigid-bodies should collide with each other or not.
	AUTO_PROP bool collideConnected GetCollideConnected SetCollideConnected
	
END

// The SpringJoint2D ensures that the two connected rigid-bodies stay at a specific distance apart using a spring system.
CONDITIONAL ENABLE_2D_PHYSICS
CLASS SpringJoint2D : Joint2D

	// The Position of the anchor around which the joints motion is constrained.
	AUTO_PROP Vector2 anchor GetAnchor SetAnchor

	// The Position of the anchor around which the joints motion is constrained.
	AUTO_PROP Vector2 connectedAnchor GetConnectedAnchor SetConnectedAnchor

	// The distance the joint should maintain between the two connected rigid-bodies.
	AUTO_PROP float distance GetDistance SetDistance

	// The damping ratio for the oscillation whilst trying to achieve the specified distance.  0 means no damping.  1 means critical damping.  range { 0.0, 1.0 }
	AUTO_PROP float dampingRatio GetDampingRatio SetDampingRatio

	// The frequency in Hertz for the oscillation whilst trying to achieve the specified distance.  range { 0.0, infinity }
	AUTO_PROP float frequency GetFrequency SetFrequency

END


// The DistanceJoint2D ensures that the two connected rigid-bodies stay at a maximum specific distance apart.
CONDITIONAL ENABLE_2D_PHYSICS
CLASS DistanceJoint2D : Joint2D

	// The Position of the anchor around which the joints motion is constrained.
	AUTO_PROP Vector2 anchor GetAnchor SetAnchor

	// The Position of the anchor around which the joints motion is constrained.
	AUTO_PROP Vector2 connectedAnchor GetConnectedAnchor SetConnectedAnchor

	// The maximum distance the joint should maintain between the two connected rigid-bodies.
	AUTO_PROP float distance GetDistance SetDistance

END


// The HingeJoint2D constrains the two connected rigid-bodies around the anchor points not restricting the relative rotation of them.  Can be used for wheels, rollers, chains, rag-dol joints, levers etc.
CONDITIONAL ENABLE_2D_PHYSICS
CLASS HingeJoint2D : Joint2D

	// Setting the motor or limit automatically enabled them.

	// The Position of the anchor around which the joints motion is constrained.
	AUTO_PROP Vector2 anchor GetAnchor SetAnchor

	// The Position of the anchor around which the joints motion is constrained.
	AUTO_PROP Vector2 connectedAnchor GetConnectedAnchor SetConnectedAnchor

	// Enables the joint's motor.
	AUTO_PROP bool useMotor GetUseMotor SetUseMotor

	// Enables the joint's limits.
	AUTO_PROP bool useLimits GetUseLimits SetUseLimits

	// The motor will apply a force up to a maximum torque to achieve the target velocity in degrees per second.
	AUTO_PROP JointMotor2D motor GetMotor SetMotor

	// The limits of the hinge joint.
	AUTO_PROP JointAngleLimits2D limits GetLimits SetLimits

END

// The SliderJoint2D constrains the two connected rigid-bodies to have on degree of freedom: translation along a fixed axis.  Relative motion is prevented.
CONDITIONAL ENABLE_2D_PHYSICS
CLASS SliderJoint2D : Joint2D

	// Setting the motor or limit automatically enabled them.

	// The Position of the anchor around which the joints motion is constrained.
	AUTO_PROP Vector2 anchor GetAnchor SetAnchor

	// The Position of the anchor around which the joints motion is constrained.
	AUTO_PROP Vector2 connectedAnchor GetConnectedAnchor SetConnectedAnchor

	// The translation angle that the joint slides along.
	AUTO_PROP float angle GetAngle SetAngle

	// Enables the joint's motor.
	AUTO_PROP bool useMotor GetUseMotor SetUseMotor

	// Enables the joint's limits.
	AUTO_PROP bool useLimits GetUseLimits SetUseLimits

	// The motor will apply a force up to a maximum torque to achieve the target velocity in degrees per second.
	AUTO_PROP JointMotor2D motor GetMotor SetMotor

	// The limits of the slider joint.
	AUTO_PROP JointTranslationLimits2D limits GetLimits SetLimits

END

CONDITIONAL ENABLE_2D_PHYSICS
CLASS PhysicsMaterial2D : Object

	CUSTOM private static void Internal_Create ([Writable]PhysicsMaterial2D mat, string name)
	{
		PhysicsMaterial2D* material = NEW_OBJECT (PhysicsMaterial2D);
		SmartResetObject(*material);
		material->SetNameCpp (name);
		Scripting::ConnectScriptingWrapperToObject (mat.GetScriptingObject(), material);
	}
	
	// Creates a new material.
	CSRAW public PhysicsMaterial2D () { Internal_Create (this,null); }

	// Creates a new material named /name/.
	CSRAW public PhysicsMaterial2D (string name) { Internal_Create (this,name); }

	//  How bouncy is the surface? A value of 0 will not bounce. A value of 1 will bounce without any loss of energy.
	AUTO_PROP float bounciness GetBounciness SetBounciness

	// The friction.
	AUTO_PROP float friction GetFriction SetFriction

END

CSRAW }
